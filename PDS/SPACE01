*PROCESS       XREF(SHORT,UNREFS)
*PROCESS       NODXREF
*PROCESS       NORXREF
*PROCESS       NOALIGN

*---------------------------------------------------------------------*
*                                                                     *
*   Assembler Variables                                               *
*  These variables define various names, processing defaults, etc.,   *
*  and should be reviewed before assembling.                          *
*                                                                     *
*  &PGMNAME                                                           *
*      Used in the Assembler listing, message IDs, etc                *
*  &VERSION                                                           *
*      Used in Title, Statistics line                                 *
*                                                                     *
*  &PNLNAME                                                           *
*      Name of panel used in ISPF display, mode ISPF(S)               *
*  &SORT_Prompt_Popup_Panel                                           *
*      Name of the panel used to pronpt, if required, for options for *
*      the SORT command, under ISPF(S) or ISPF(B)                     *
*  &OUTPUT_Prompt_Popup_Panel                                         *
*      Name of the panel used to pronpt, if required, for options for *
*      the OUTPUT command, under ISPF(S) or ISPF(B)                   *
*                                                                     *
*  &ISPF_by_Default                                                   *
*      Use ISPF for on-line displays                                  *
*  &ISPF_Default_Type                                                 *
*      Default type of ISPF display                                   *
*                                                                     *
*  &Fore_LSPACE_Wait                                                  *
*      Maximum seconds to wait for LSPACE to complete when running in *
*      the foreground (TSO)                                           *
*  &Back_LSPACE_Wait                                                  *
*      Maximum seconds to wait for LSPACE to complete when running in *
*      the background (Batch and STC)                                 *
*                                                                     *
*  &Default_SubTask_Count                                             *
*      Default  number of subtasks to dispatch to issue LSPACEs. If 0,*
*      defaults to (number of engines * 2) + 1.                       *
*  &Max_SubTask_Count                                                 *
*      Maximum  number of subtasks to dispatch to issue LSPACEs. If 0,*
*      defaults to 16.                                                *
*                                                                     *
*---------------------------------------------------------------------*
         LCLC  &PGMNAME              Program Name
&PGMNAME SETC  'SPACE'
         LCLC  &VERSION              Program Version
&VERSION SETC  'V2.24'

         LCLC  &PNLNAME              Panel Name for ISPF(S)
&PNLNAME SETC  'SSCSPC02'

         LCLC  &SORT_Prompt_Popup_Panel Name for SORT pop-up prompt
&SORT_Prompt_Popup_Panel SETC 'SSCSPC03'

         LCLC  &OUTPUT_Prompt_Popup_Panel  Name for OUTPUT pop-up prmt
&OUTPUT_Prompt_Popup_Panel SETC 'SSCSPC04'

         LCLB  &ISPF_by_Default      Use ISPF if available?
&ISPF_by_Default SETB 1               Yes, if available
*&ISPF_by_Default SETB 0               No, TSO line-by-line as default

         LCLC  &ISPF_Default_Type    Default ISPF display type
&ISPF_Default_Type SETC 'SPACE'       Customized SPACE panel
*&ISPF_Default_Type SETC 'EDIF'        Edit
*&ISPF_Default_Type SETC 'BRIF'        Browse
*&ISPF_Default_Type SETC 'NONE'        None, TSO line-by-line

         LCLA  &Fore_LSPACE_Wait     LSPACE Wait time in foreground
&Fore_LSPACE_Wait SETA 5              5 seconds

         LCLA  &Back_LSPACE_Wait     LSPACE Wait time in background
&Back_LSPACE_Wait SETA 0              LSPACE/MIH default

         LCLA  &Default_SubTask_Count Number of Subtasks to dispatch
&Default_SubTask_Count SETA 0          2 * Nbr engines + 1

         LCLA  &Max_SubTask_Count     Maximum Subtasks to dispatch
&Max_SubTask_Count     SETA 16         Compatibility with prev versions


*---------------------------------------------------------------------*
*  Do some trivial validation on the Assembly Variables               *
*---------------------------------------------------------------------*
         AIF   (&Default_SubTask_Count GE 0).VAL_010
         MNOTE 4,'Value of &&Default_SubTask_Count negative - using Dyn+
               amic SubTask count'
&Default_SubTask_Count SETA 0
.VAL_010 ANOP
         AIF   (&Max_SubTask_Count GE 0).VAL_020
         MNOTE 4,'Value of &&Max_SubTask_Count negative - using default+
                value of 16'
&Max_SubTask_Count     SETA 16
.VAL_020 ANOP
         AIF   (&Max_SubTask_Count GE &Default_SubTask_Count).VAL_030
         MNOTE 4,'&&Max_SubTask_Count less than &&Default_SubTask_Count+
                 - using max of &Default_SubTask_Count'
&Max_SubTask_Count     SETA &Default_SubTask_Count
.VAL_030 ANOP
         AIF   (&Fore_LSPACE_Wait GE 0).VAL_040
         MNOTE 4,'&&Fore_LSPACE_Wait is negative - setting to 5 sec.'
&Fore_LSPACE_Wait      SETA 5
.VAL_040 ANOP
         AIF   (&Back_LSPACE_Wait GE 0).VAL_050
         MNOTE 4,'&&Back_LSPACE_Wait is negative - setting to 0'
&Back_LSPACE_Wait      SETA 0
.VAL_050 ANOP


&PGMNAME TITLE 'Display DASD Free Space'
*---------------------------------------------------------------------*
*                                                                     *
*  Program   : SPACE                                                  *
*                                                                     *
*  Abstract  : This program will display the free space on DASD       *
*              volumes, as selected by the user. This program can     *
*              run as a batch job or TSO command, using ISPF Dialogue *
*              Manager facilities, if appropriate.                    *
*                                                                     *
*  Inputs    :                                                        *
*      Parameters :If Batch, N/A                                      *
*                  If TSO Command, R1 = A(CPPL) (see comments below   *
*                                                for operands)        *
*      Files      :If Batch, SYSIN = Control cards                    *
*      Other      :If TSO Cmd, Command Buffer                         *
*                                                                     *
*  Outputs:                                                           *
*      Returncodes:                                                   *
*      Messages   :xxxxx                                              *
*      Files      :If Batch, SYSPRINT = output Messages               *
*      Other      :None                                               *
*                                                                     *
*  Program     Reentrant, problem key and state, standard linkage,    *
*  Attributes: APF-authorized(maybe), AMODE(31), RMODE(ANY)           *
*                                                                     *
*  Implement-:  Unless you have the PTFs for IBM APAR OW48527 APPLYed *
*  ation        on the system(s) on which this program is running,    *
*               this program must be be APF Authorized.               *
*               It is recommended that it also be installed as a TSO  *
*               command, taking advantage of ISPF Dialog Manager      *
*               Services, if available. To do this, it must:          *
*                 - reside in a TSO STEPLIB or LNKLST library         *
*                 - be named in the AUTHTSF (but *not* the AUTHCMD)   *
*                   section of SYS1.PARMLIB(IKJTSOxx).                *
*               Note that all code runs in Problem State and Key; APF *
*                    authorization is required to issue SYSEVENTs.    *
*                    See below for further information.               *
*                                                                     *
*  Special   :  This program was written to be run either as a program*
*  Notes       or a TSO command; if as a TSO command, it will use     *
*              ISPF Dialog Manager services, if available.            *
*               If this program runs on a system which does *not*     *
*              have the PTFs for IBM APAR OW48527 installed, it       *
*              needs to be APF authorized (it uses SYSEVENT DONTSWAP *
*              and OKSWAP while retrieving DASD info - there is an    *
*              explanation below, for those of you who have way too   *
*              much time on your hands). Unfortunately, ISPF DM       *
*              Services are not available to Authorized TSO Commands. *
*              The following strategy (?) is used:                    *
*               - The command is invoked as non-authorized (even      *
*                 though the load module is LINKed AC(1), because     *
*                 it is not named in AUTHCMD)                         *
*               - IKJEFTSR is used to re-invoke itself to perform     *
*                 the authorized bits (this time it is authorized     *
*                 because it is named in AUTHTSF)                     *
*               - The original (unauthorized) command then uses       *
*                 ISPF DM Services to display the results.            *
*                                                                     *
*               When running in Batch, TSO PARSE is used to scan      *
*              the control cards (from SYSIN), so the syntax of the   *
*              batch control cards is the same as the TSO Command     *
*              syntax.                                                *
*                                                                     *
*               The following comments apply only when running on     *
*              systems that do *not* have the PTFs for IBM APAR       *
*              OW48527 installed:                                     *
*               This program issues LSPACE macros to retrieve usage   *
*              data for a volume. If LSPACE is issued against a DASD  *
*              volume that is RESERVEd on another system, it will     *
*              hang until the RESERVE is released. This gets          *
*              particularly annoying when being run from TSO.         *
*               The program gets hung because:                        *
*                - LSPACE creates an ESTAE with PURGE=NONE            *
*                - LSPACE invokes CVAF                                *
*                - CVAF creates an ESTAE with PURGE=QUIESCE           *
*                - CVAF tries to touch the device, and hangs because  *
*                  of a RESERVE                                       *
*                - A CANCEL is issued for the Address Space           *
*                - When the 1st ESTAE (CVAFs) gets scheduled, an      *
*                  attempt is made to QUIESCE the I/O, which never    *
*                  happens, so we hang.                               *
*              (Thanks to the IBM ETR folks for their help in figuring*
*               out what was going on).                               *
*                                                                     *
*              To try to circumvent this situation, we issue STIMERMs *
*              with an exit before issuing LSPACEs. If the exit is    *
*              invoked, an ESTAE with PURGE=HALT is extablished, and  *
*              an ABEND U522 issued within the STIMERM exit.          *
*              The ESTAE from the STIMERM exit is invoked first, so   *
*              the I/O is PURGEd, and the ESTAE percolates to the     *
*              CVAF and LSPACE ESTAEs, which can now run because the  *
*              I/O has been PURGEd.                                   *
*              So far so good, no APF-authorization required, but ... *
*              while the LSPACE is trying to get to a RESERVEd device,*
*              but before the STIMERM pops, SRM/WM may kick in        *
*              and decide that we should be swapped out. If (s)he     *
*              does this. the TCBs will be made non-dispatchable,     *
*              and an attempt will be made to quiesce the I/O.        *
*              The I/O cannot, in fact, be quiesced, so we end up     *
*              with a non-dispatchable Address Space waiting for an   *
*              'unquiescable' I/O to be quiesced. When the STIMERM    *
*              pops, the exit (which would get us out of this mess)   *
*              cannot run because we are non-dispatchable.            *
*              All this is a long way of saying that we have to be    *
*              APF authorized, so we can issue SYSEVENT DONTSWAP      *
*              while the LSPACE tasks are running, so that the        *
*              STIMERM Exit can be dispatched to ESTAE and ABEND.     *
*                                                                     *
*              Note that APAR OW48527 addresses this problem by       *
*              allowing the invoker of LSPACE to specify a time-out,  *
*              defaulting to 5 seconds. This program determines if    *
*              the appropriate PTFs have been APPLYed to the active   *
*              system by checking the LSPACE SVC for literals that    *
*              are present only when the PTFs have been installed.    *
*                                                                     *
*                                                                     *
*  Coding    : All data areas in Dynamic Storage have names starting  *
*   Notes       with '@'. One area of Dynamic Storage is acquired     *
*               during initialization, and is used as a LIFO stack    *
*               for dynamic storage.                                  *
*                                                                     *
*              The names of the Routines follow the pattern:          *
*                 xnnnnn                                              *
*               where x    is an alphabetic character, and            *
*                     n    is a numeric character.                    *
*                                                                     *
*              Data in dynamic storage that are globally accessible   *
*               have names of the form:                               *
*                @_anyname                                            *
*              Data associated with a routine typically have names:   *
*                 x_anyname or @x_anyname                             *
*               where 'x' is the alphabetic character associated      *
*                         with the routine                            *
*              Addressability to globally-accessible dynamic data is  *
*               via R12; local dynamic data is addressable via R13.   *
*                                                                     *
*              Each routine establishes it's own base register,       *
*               typically R11, for local, read-only variables. Note   *
*               that there is no base register for the code, except   *
*               where required  around macros, etc., when R2 is used, *
*               so be careful if you use R2 for other purposes.       *
*                                                                     *
*                                                                     *
*  Change                                                             *
*  History   : 1990/06/11 SDDA030 - V1.0                              *
*                                 - New                               *
*              1996/03/13 SDDA030 - V1.1                              *
*                                   Added 4-digit UCB capability      *
*                                   (D00010)                          *
*              1997/05/16 SDDA030 - V1.2                              *
*                                 - Corrected IKJPARS PCL to accept   *
*                                   4-digit UCBs (C00010)             *
*                                 - Made Y2K compliant (!)            *
*                                 - ATTACH subtasks to issue LSPACE   *
*                                   (D00010, H00010)                  *
*              1998/09/17 SDDA030 - V2.0                              *
*                                 - Removed APF checks, and used      *
*                                   UCBSCAN with DCEAREA operand to   *
*                                   get DCE info (D00010).            *
*                                 - Corrected communications between  *
*                                   mother and daughter TCBs (D07000, *
*                                   H00010).                          *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Added Statistics display          *
*                                 - Runs RMODE(ANY), moving SYSIN and *
*                                   SYSPRINT I/O routines to 24-bit   *
*                                   storage. Also move STLINENO       *
*                                   routine to 24-bit storage.        *
*              1998/11/13 SDDA030 - V2.2                              *
*                                 - Used IKJPARS to parse operands in *
*                                   batch.                            *
*              1998/11/23 SDDA030 - V2.3                              *
*                                 - Updated STIMERM exit to POST SPACE*
*                                   only if subtask is in SVC 78      *
*                                   (LSPACE).                         *
*              1999/01/14 SDDA030 - V2.4                              *
*                                 - Made check for ISPF, TSO command  *
*                                   or CALL/PGM= checks more consis-  *
*                                   tent across Batch/TSO environs.   *
*              1999/03/03 SDDA030 - V2.5                              *
*                                 - Added version-release variable    *
*                                   and a new statistics line to      *
*                                   display it.                       *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*                                 - Moved SYSIN and SYSPRINT routines *
*                                   back into mainline code (rather   *
*                                   than moving them below-the-line). *
*              1999/07/30 SDDA030 - V2.7                              *
*                                 - Added code to cope with SYSIN     *
*                                   allocated to the terminal (31-bit *
*                                   SAM is not supported).            *
*                                 - Added CPU Time to the statistics. *
*                                 - Added TSO HELP comments.          *
*              1999/08/20 SDDA030 - V2.8                              *
*                                 - Fixed up and documented the       *
*                                   STACK macro.                      *
*                                 - Added internal stack statistics.  *
*                                 - Added Wait Time to the statistics.*
*                                 - Added Routine W00010 to manage    *
*                                   VolTbl                            *
*              1999/09/01 SDDA030 - V2.9                              *
*                                 - Changed method of obtaining totals*
*                                   to avoid CDS instruction.         *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Changed default display order to  *
*                                   ascending order of unit address.  *
*                                 - Flagged volumes initialized as SMS*
*                                   (in the VTOC), but not SMS managed*
*                                   (in the UCB).                     *
*                                 - Reset Stack statistics for each   *
*                                   iteration.                        *
*                                 - Added 'ISPF' keyword to display   *
*                                   data via ISPF table and panel if  *
*                                   ISPF services are available.      *
*                                 - Removed ISPF initialization stuff;*
*                                   now invoked as a CMD with the     *
*                                   ISPF keyword.                     *
*                                 - Moved most of TSO Cmd init. code  *
*                                   from C00010 to G00010.            *
*                                 - Honoured NOHEADINGS, NODETAILS and*
*                                   NOTOTALS when outputting to ISPF. *
*                                 - Added # vols to Totals line (in   *
*                                   DevType field).                   *
*                                 - Made the generation of headings   *
*                                   more consistent across environ-   *
*                                   ments.                            *
*                                 - Added keyword descriptions when   *
*                                   Parse fails in batch.             *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Added SORT keywords for all fields*
*                                 - Added ASCENDING/DESCENDING kwds.  *
*                                 - Added capability of writing output*
*                                   to an file:                       *
*                                    OUTFILE(ddname)                  *
*                                    OUTDATA(ALL/CB/DISPLAY)          *
*                                 - Saved control block data in       *
*                                   the volume table.                 *
*                                 - Added 24-bit Stack for DCBs,      *
*                                   STLINENO, etc.                    *
*                                 - Added &PGMNAME variable, using it *
*                                   for CSECT name, literals, etc.    *
*              2000/05/23 SDDA030 - V2.12                             *
*                                 - Used IOSCDR to test if we can get *
*                                   out to our DASD before issuing    *
*                                   LSPACE. Note that this requires   *
*                                   that we be APF-authorized or have *
*                                   RACF access to IOSCDR - see       *
*                                   'Special Notes', above.           *
*                                 - Added checks to see if we can     *
*                                   issue IOSCDR.                     *
*                                 - Removed STIMERM-related stuff,    *
*                                   since we can't DETACH once LSPACE *
*                                   has been issued.                  *
*                                 - Added message if we can't issue   *
*                                   IOSCDR to check RESERVEs.         *
*                                 - Added messages when ISPF DM is not*
*                                   available and the user requested  *
*                                   ISPF output.                      *
*                                 - Added msgids to error messages.   *
*                                 - Added )M info to TSO Help.        *
*                                 - Removed WTOs from Stack overflows.*
*                                 - Re-organized internal code:       *
*                                   - broke out ISPF output handling  *
*                                   - re-labeled and re-sequenced     *
*                                     labels.                         *
*                                 - Left stats line updates as late as*
*                                   possible (V00010).                *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Removed IOSCDR stuff added in     *
*                                   V2.12; instead, ESTAE PURGE=HALT  *
*                                   and ABEND in the STIMERM exit.    *
*                                 - Made ourselves non-swappable while*
*                                   daughter tasks are running.       *
*                                 - Added IKJEFTSR to re-invoke our-  *
*                                   selves APFed.                     *
*                                 - Added message if not APFed.       *
*                                 - Added IKJEFTSR failure msg.       *
*                                 - Set RC=4 if no units found.       *
*                                 - Added MULT to TBADD.              *
*                                 - Added non-swappable time to stats.*
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Added EDIF/BRIF support.          *
*                                 - Allowed &PGMNAME as 1st word      *
*                                   in batch control cards.           *
*                                 - Populated Stats lines only once.  *
*                                 - Added &PNLNAME for panel name.    *
*                                 - Used (GTSIZE-1) as line size for  *
*                                   TSO line-by-line output.          *
*                                 - Added VTOCIX, Frag Indx, SMS      *
*                                   StorGrp and CHPID info.           *
*                                 - Moved formatting and totalling    *
*                                   routines back into mainline, to   *
*                                   reduce non-swap time.             *
*                                 - Forced ISPF(B) if panel for       *
*                                   ISPF(S) not available.            *
*                                 - Added execution environment stats *
*                                   lines.                            *
*                                 - Added conditional assembly stuff  *
*                                   for APAR OW48527.                 *
*                                 - Used SYS1.NUCLEUS(IECDINIT), CSECT*
*                                   IECDDEVT to get device type.      *
*                                 - Added check to ensure IKJEFTSR    *
*                                   invokes the same code as was orig-*
*                                   inally invoked.                   *
*                                 - Added SMS volume status and ass-  *
*                                   ociated sort field (SMSSTAT).     *
*                                 - Added 'N/A' in SMS fields for     *
*                                   non-SMSed volumes (so REXX words  *
*                                   are consistent).                  *
*                                 - Added keyword NOLSPACE, for when  *
*                                   you only need UCBs and Volsers (ie*
*                                   at IPL to vary devices OFFLINE    *
*                                   based on volser).                 *
*              2001/11/12 SDDA030 - V2.15                             *
*                                 - Added lists of volsers, UCBs in   *
*                                   selection parms.                  *
*                                 - Added XVOL, XUCB for excluding    *
*                                   lists of volsers, units.          *
*                                 - Corrected STIMERM time bug (micro,*
*                                   not milli, stupid!)               *
*                                 - Used the ratio of SubTasks to LPs *
*                                   as a factor in calculating STIMER *
*                                   times for LSPACE.                 *
*                                 - Checked Assembler version when    *
*                                   generating our assembly time      *
*                                   stamp.                            *
*                                 - Retrieved all devices via EDTINFO *
*                                   when selecting by esoteric.       *
*              2002/02/12 SDDA030 - V2.16                             *
*                                 - Used Dynamic displays (rather than*
*                                   TBDISPL) for ISPF(S)              *
*                                 - Added LEFT/RIGHT processing for   *
*                                   ISPF(S)                           *
*                                 - Removed implicit SORT in ISPF(S); *
*                                   added SORT cmd to ISPF(S)         *
*                                 - Added sort prompt pop-up panel in *
*                                   ISPF(B) and ISPF(S).              *
*                                 - Added 'Line x of y' in ISPF(S).   *
*                                 - Added 'Top of Data' and 'Bottom   *
*                                   of Data' to ISPF(S).              *
*                                 - Distributed with &ISPF_by_Default *
*                                   set to 1 (Yes).                   *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - Added STORGRP as a selection      *
*                                   criterion (as suggested by Ian    *
*                                   Hobbs).                           *
*                                 - Added bytes of free space/volume. *
*                                 - Moved Frag Index, and added check *
*                                   for max of 999.                   *
*                                 - Changed RDJFCBs to SWAREQs.       *
*                                 - Added SSREQ to SMS for volumes in *
*                                   a STORGRP.                        *
*                                 - Removed sort-by-column facility,  *
*                                   and added numeric sort fields, so,*
*                                   for instance, 1.1G sorts higher   *
*                                   than 1.1K.                        *
*                                 - Generated LSPACE error messages   *
*                                   internally, instead of asking     *
*                                   LSPACE to do it.                  *
*                                 - Scaled numbers by 1000 instead of *
*                                   1024.                             *
*                                 - BASR to, rather than ATTACH,      *
*                                   H00010 if we only have 1 subtask. *
*                                 - Added indicators for CHPIDs not   *
*                                   phys or log available.            *
*                                 - Calculated total Free % based on  *
*                                   bytes rather than tracks          *
*                                 - Changed internal STACK macro to   *
*                                   SSCSTACK, so it doesn't conflict  *
*                                   with IBM's STACK in ATSOMAC.      *
*              2002/06/11 SDDA030 - V2.18                             *
*                                 - Moved detail line formatting back *
*                                   into subtask.                     *
*                                 - Subtask statistics populated by   *
*                                   subtask itself.                   *
*                                 - Total line populated by last      *
*                                   subtask to end.                   *
*                                 - Added 'CS collisions' to subtask  *
*                                   statistics.                       *
*                                 - If running with OW48527, don't    *
*                                   WAIT for subtasks to finish; start*
*                                   outputting lines as soon as       *
*                                   possible.                         *
*              2002/08/08 SDDA030 - V2.19                             *
*                                 - Dynamically determined the status *
*                                   of APAR OW48527 by checking       *
*                                   IGC0007H (LSPACE) for the literal *
*                                   'I/O TIMEOUT'                     *
*                                 - Removed &OW48527 conditional      *
*                                   assembly stuff                    *
*                                 - Converted Branches to Jumps,      *
*                                   BASRs to BRAS, etc.               *
*                                 - Removed 'CS collisions' from      *
*                                   subtask stats, since they always  *
*                                   seemed to be 0.                   *
*                                 - Corrected bug when selecting by   *
*                                   multiple STORGRPs.                *
*                                 - If we fail APF checks, POST all   *
*                                   lines in VolTbl as complete.      *
*                                 - Corrected S0C4 when selecting by  *
*                                   Unit and no DASD UCBs found (and  *
*                                   thus no VolTbl created).          *
*                                 - Corrected bug where the SMS       *
*                                   Anomaly msg was not being put out *
*                                   in ISPF modes.                    *
*                                 - WAITed for up to 2.5 seconds for  *
*                                   any subtasks to finish before     *
*                                   terminating.                      *
*              2003/01/16 SDDA030 - V2.20                             *
*                                 - Corrected bug in eliminating stats*
*                                   lines after finding out we aren't *
*                                   APF'd (E80010).                   *
*                                 - Corrected bug when finding TIOT   *
*                                   entry for the OUTFILE DDName.     *
*                                 - Used consistent registers to      *
*                                   address VolTbl_Ent throughout.    *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Fixed S0C4 when adjusting UCB pat-*
*                                   terns after no UCBs found when    *
*                                   selecting by UCB.                 *
*                                 - Added line commands in ISPF(S)    *
*                                   and ISPF(B) modes:                *
*                                   . ISPF(x) to switch display modes *
*                                 - Removed @_No_UCBs_Found flag;     *
*                                   check nbr vols in table instead.  *
*                                 - Added Vol Capacity field in the   *
*                                   display, after VTOC stuff.        *
*                                 - Allowed system symbols and sub-   *
*                                   stringing in command line (ran the*
*                                   command line through ASASYMBM).   *
*                                 - Returned correct SMS status (ins- *
*                                   tead of status of 1st vol in      *
*                                   STORGRP).                         *
*                                 - Used ATTACHX instead of ATTACH.   *
*                                 - Added S00010 to WAIT for and      *
*                                   DETACH subtask TCBs - avoids SA03 *
*                                   abends.                           *
*                                 - If we read from SYSIN, send output*
*                                   to SYSPRINT, even if ISPF is      *
*                                   available.                        *
*                                 - Treated SYSPRINT (almost) like    *
*                                   an OUTFILE - DCB characteristics  *
*                                   now honoured.                     *
*              2004/10/15 SDDA030 - V2.22                             *
*                                 - Fixed bug when returning SMS      *
*                                   status (Thanks Angel Luis Domin-  *
*                                   guez).                            *
*                                 - Added SYSSTATE ARCHLVL=1          *
*              2005/01/20 SDDA030 - V2.23                             *
*                                 - Used CSRSI to retrieve info in-   *
*                                   stead of crawling through control *
*                                   blocks.                           *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Added check for z/OS.e in stats.  *
*                                 - Use TRKCALC to get generally acc- *
*                                   epted value for Tracksize, instead*
*                                   of using DS4DEVTK.                *
*                                 - Rounded displayed values.         *
*                                 - Display actual value of field in  *
*                                   SMSG area when in ISPF(S) and the *
*                                   cursor is on a numeric field and  *
*                                   ENTER is hit.                     *
*                                 - IDENTIFY H00010 with a unique name*
*                                   so we can run multiple copies     *
*                                   simultaneously.                   *
*                                 - Added LINESIZE keyword.           *
*                                 - Standardized internal calling     *
*                                   sequence so that A(@_Dynam),      *
*                                   A(31-bit Stack Pointer) and       *
*                                   A(24-bit Stack Pointer) are always*
*                                   the 1st 3 parms.                  *
*                                 - Added name and version to title.  *
*                                 - Added max LSPACE Wait time        *
*                                   defaults and MAXLWAIT keyword.    *
*                                 - Dynamically calculated nbr        *
*                                   subtasks = 2*engines + 1          *
*                                 - Added default and max Subtask     *
*                                   counts Assembly variables - thanks*
*                                   to MJ Cleary for the suggestion.  *
*                                 - Added display of installation     *
*                                   defaults to stats lines.          *
*                                 - Flagged emulated devices with     *
*                                   '*E*' following device type.      *
*                                 - Saved registers on the Linkage    *
*                                   Stack when we don't know who the  *
*                                   caller is (and thus the size of   *
*                                   the save area in R13).            *
*                                 - Used conditional STORAGE OBTAINs  *
*                                   when expanding VolTbl.            *
*                                 - Used separate 24-bit stack for    *
*                                   OUTFILE stuff (DCBs, etc).        *
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*                                                                     *
*  To Do     : Handle CVAF Abends (S18B).                             *
*                                                                     *
*---------------------------------------------------------------------*
         TITLE 'TSO HELP'
*---------------------------------------------------------------------*
*                                                                     *
*)F Function -                                                        *
*  The SPACE command displays DASD volume usage statistics, based on  *
*  user-specified characteristics.                                    *
*                                                                     *
*)X Syntax -                                                          *
*         SPACE UNIT/UCB('Unit-mask')                                 *
*               VOLUME('Volume-mask')                                 *
*               NAME('Esoteric-name')                                 *
*               ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)         *
*               STORGRP('SMS-Storage-Group-Name')                     *
*               XUNIT/XUCB('Unit-mask')                               *
*               XVOLUME('Volume-mask')                                *
*               SORT(id)                                              *
*               ASCENDING/DESCENDING                                  *
*               MAXTASKS('#Subtasks')                                 *
*               OUTFILE(ddname)                                       *
*               OUTDATA(Display|CB|All)                               *
*               NOHEADINGS/NOHDG                                      *
*               NODETAILS                                             *
*               NOTOTALS                                              *
*               NOECHO                                                *
*               STATISTICS|STATS                                      *
*               ISPF(Space|Edif|Brif|None)                            *
*               NOLSPACE                                              *
*               LINESIZE                                              *
*               MAXLWAIT(secs)                                        *
*                                                                     *
*  Required - None                                                    *
*  Default  - UNIT(*) VOLUME(*)                                       *
*  Alias    - None                                                    *
*  Notes    -                                                         *
*                                                                     *
*)M Messages -                                                        *
*                                                                     *
*))SPACE01I No Devices/Volumes match selection criteria               *
*           This message is issued when no online DASD devices were   *
*           found that satisfied the selection criteria defined.      *
*                                                                     *
*))SPACE02I Insufficient APF authorization                            *
*           The SPACE command requires APF authorization, but is cur- *
*           rently not authorized.                                    *
*                                                                     *
*))SPACE03I ISPF DM Services unavailable xx-yy                        *
*           This message is issued when the SPACE command could not   *
*           use ISPF Dialogue Management Services to display the      *
*           results of the command in ISPF format. Either the required*
*           ISPF modules were unavailable, or the environment is such *
*           that ISPF Dialogue Management Services are not functional.*
*           In the message, xx indicates which ISPF service is        *
*           unavailable, and yy is the return code from that service. *
*                                                                     *
*))SPACE04I Forcing non-ISPF output                                   *
*           This message is issued when the user has requested that   *
*           the command output be displayed using ISPF Dialogue       *
*           Management Services, but these services are unavailable.  *
*           The command output is displayed using TSO line-by-line    *
*           facilities (PUTLINE).                                     *
*                                                                     *
*))SPACE05I CSVQUERY unavailable on this system xxxxx                 *
*           The CSVQUERY function was attempted to verify that APAR   *
*           OW48527 had been APPLYed to this system, but CSVQUERY is  *
*           not available. 'xxxxx' is the Operating System level on   *
*           which this program is executing.                          *
*                                                                     *
*))SPACE06I Program not found in STEPLIB/LNKLST                       *
*           This command requires that the processing program reside  *
*           in the current STEPLIB or system LNKLST concatenation,    *
*           but the program cannot be located.                        *
*                                                                     *
*))SPACE07I IKJEFTSR error xx-yy                                      *
*           The TSO/E Service Routine IKJEFTSR could not complete     *
*           successfully. xx is the Return Code, and yy the reason    *
*           code.                                                     *
*                                                                     *
*))SPACE08I LSPACE failed for at least 1 volume                       *
*           The data presented in the table is incomplete because     *
*           information for at least 1 DASD volume was unavailable.   *
*                                                                     *
*))SPACE09I Incompatible versions of SPACE found                      *
*           The TSO/E Service Routine IKJEFTSR invoked a different    *
*           version of SPACE (from LNKLST/STEPLIB) than was           *
*           originally invoked (from ISPLLIB?).                       *
*                                                                     *
*))SPACE10I Insufficient storage: nnn volumes omitted                 *
*           Not enough (above-the-line) storage was available to      *
*           save the information for all selected DASD volumes. nnn   *
*           indicates how many volumes were not processed.            *
*                                                                     *
*))SPACE11I Internal error - unknown invocation type                  *
*           The program could not determine how it was invoked. This  *
*           is most likely to occur when it is being reinvoked via    *
*           IKJEFTSR, but the parameters passed are unrecognized.     *
*                                                                     *
*))SPACE12I OUTFILE DDname xxxxxxxx not useable - ignored.            *
*           This message is issued when the user has requested that   *
*           the volume usage data be written to a file, by specifying *
*           OUTFILE(xxxxxxxx) on the command line. DDName xxxxxxxx    *
*           could not be OPENed for output.                           *
*                                                                     *
*)O Operands -                                                        *
*))UNIT('Unit-mask') or                                               *
*   UCB('Unit-mask')    specifies the selection criterion based on    *
*                       UCB address. Wildcard characters can be used: *
*                        '*' - all remaining characters               *
*                        '?' - any single character                   *
*                        '%' - any single character                   *
*                       Default is '*'.                               *
*                       If 'Unit-mask' is less than 4 characters, it  *
*                       is right-filled with asterisks.               *
*                       If no UCBs match the 'Unit-mask', and an ast- *
*                       erisk is the last character in 'Unit-mask',   *
*                       the trailing asterisk is dropped, a '0'       *
*                       inserted in the 1st position of 'Unit-mask',  *
*                       and the UCB scan repeated. This process is    *
*                       repeated until UCBs are found, or there are no*
*                       more trailing asterisks in 'Unit-mask'.       *
*                       Note that a DASD volume must satisfy *all*    *
*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *
*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *
*                       ected.                                        *
*                                                                     *
*))XUNIT('Unit-mask') or                                              *
*   XUCB('Unit-mask')   specifies the exclusion criterion based on    *
*                       UCB address.                                  *
*                                                                     *
*))VOLUME('Volume-mask')                                              *
*                       specifies the selection criterion based on    *
*                       volume serial number. Wildcard characters can *
*                       be used:                                      *
*                        '*' - all remaining characters               *
*                        '?' - any single character                   *
*                        '%' - any single character                   *
*                       Default is '*'.                               *
*                       If 'Volume-mask' is less than 6 characters,   *
*                       it is right-filled with asterisks             *
*                       Note that a DASD volume must satisfy *all*    *
*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *
*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *
*                       ected.                                        *
*                                                                     *
*))XVOLUME('Volume-mask')                                             *
*                       specifies the exclusion criterion based on    *
*                       volume serial number.                         *
*                                                                     *
*))NAME('Esoteric-Name')                                              *
*                       specifies the selection criterion based on    *
*                       generic or esoteric name.                     *
*                       Default is that selection is not based on     *
*                       generic/esoteric name.                        *
*                       Note that a DASD volume must satisfy *all*    *
*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *
*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *
*                       ected.                                        *
*                                                                     *
*))ATTRIBUTE(STORAGE|STG|PRIVATE|PVT|PUBLIC|SMS)                      *
*                       specifies the selection criterion based on    *
*                       mount attribute. Only one of the options      *
*                       above can be specified.                       *
*                       Default is that selection is not based on     *
*                       mount attribute.                              *
*                       Note that a DASD volume must satisfy *all*    *
*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *
*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *
*                       ected.                                        *
*                                                                     *
*))STORGRP('SMS-Storage_Group_Name') or                               *
*       SG('SMS-Storage_Group_Name')                                  *
*                       specifies the selection criterion based on    *
*                       SMS Storage Group. Wildcard characters can be *
*                       used:                                         *
*                        '*' - all remaining characters               *
*                        '?' - any single character                   *
*                        '%' - any single character                   *
*                       Default is that selection is not based on     *
*                       SMS Storage Group Names.                      *
*                       Note that a DASD volume must satisfy *all*    *
*                       criteria specified (UNIT, XUNIT, VOL, XVOL,   *
*                       NAME, ATTRIBUTE, and/or STORGRP) to be sel-   *
*                       ected.                                        *
*                                                                     *
*))SORT(id)             specifies the order in which the selected     *
*                       DASD volumes are displayed:                   *
*                        id: VOL     - Volser                         *
*                            UCB     - UCB Name (Device Address)      *
*                            DEVT    - Device Type                    *
*                            ATTR    - Mount Attribute                *
*                            FREET   - Free Tracks on Volume          *
*                            FREEC   - Free Cylinders on volume       *
*                            FREEP   - % Volume free                  *
*                            FREEB   - # Bytes on Volume free         *
*                            FREEE   - # Free Extents on volume       *
*                            LARGET  - Largest Free Tracks            *
*                            LARGEC  - Largest Free Cylinders         *
*                            VFREED  - VTOC Free DSCBs                *
*                            VFREEP  - % VTOC Free                    *
*                            VTRK    - Tracks allocated to VTOC       *
*                            VIX     - VTOC Index Status              *
*                            VOLSIZE - Volume Capacity (Bytes)        *
*                            FRAG    - Fragmentation Index            *
*                            STORGRP - SMS Storage Group              *
*                            SMSSTAT - SMS Volume Status              *
*                            CHPIDS  - CHPIDs                         *
*                       By default, the display is unsorted, and will *
*                       normally appear in ascending order of UCB.    *
*                                                                     *
*))ASCENDING|DESCENDING specifies the sort order. Significant only    *
*                       when a SORT id is specified.                  *
*                       Default is ASCENDING.                         *
*                                                                     *
*))MAXTASKS('#Subtasks') specifies the maximum number of sub-tasks to *
*                       be ATTACHed to retrieve volume information.   *
*                       If specified, '#Subtasks' must be numeric.    *
*                       A maximum of 16 subtasks can be ATTACHed.     *
*                       Default is (number-of-active-CPUs + 1).       *
*                                                                     *
*))OUTFILE('ddname')    specifies that the output is to be written to *
*                       the dataset allocated to 'ddname'. This output*
*                       is generated in addition to the normal output.*
*                       Default is no additional output is generated. *
*                                                                     *
*))OUTDATA(Display|CB|All) specifies the content of the data written  *
*                       to the 'ddname' specified in OUTFILE, above.  *
*                        DISPLAY writes an image of the max display   *
*                                output (235 bytes)                   *
*                        CB      writes machine-readable copies of the*
*                                following control blocks, as returned*
*                                by the appropriate MVS services:     *
*                                  UCB Copy        (48 bytes)         *
*                                  DCE Copy        (48 bytes)         *
*                                  LSPACE Data     (36 bytes)         *
*                                  F4 DSCB         (96 bytes)         *
*                        ALL     writes both CB and DISPLAY, in that  *
*                                order (228 bytes of CB and 235 bytes *
*                                of DISPLAY)                          *
*                       Default is ALL.                               *
*                                                                     *
*))NOHEADINGS|NOHDG     specifies that headings (and page breaks) are *
*                       to be suppressed.                             *
*                                                                     *
*))NODETAILS            specifies that detail lines (one per selected *
*                       DASD volume) are to be suppressed.            *
*                                                                     *
*))NOTOTALS             specifies that total lines are to be          *
*                       suppressed.                                   *
*                                                                     *
*))NOECHO               specifies that the command line is not to be  *
*                       listed in Batch.                              *
*                                                                     *
*))STATISTICS|STATS     specifies that internal version and exec-     *
*                       ution statistics are to be produced.          *
*                                                                     *
*))ISPF(Space|Edif|Brif|None)                                         *
*                       specifies the ISPF services to be used to     *
*                       present output:                               *
*                       Space causes the output to be displayed using *
*                             a customized panel. This is the default *
*                             if ISPF is specified.                   *
*                       Edif  invokes ISPF Edit to present the        *
*                             output                                  *
*                       Brif  invokes ISPF Browse to present the      *
*                             output                                  *
*                       None  uses TSO line-by-line output (PUTLINE)  *
*                             to present the output.                  *
*))NOLSPACE             specifies that no VTOC information is to be   *
*                       gathered - displays only UCB, Volser, DevType,*
*                       Attr, SMS Info, CHPIDs, Remote Copy Data.     *
*))LINESIZE(nnn)        specifies the maximum length of the line to be*
*                       displayed (in TSO line-by-line). Default is   *
*                       the value returned by the GTSIZE service minus*
*                       1. As well as a number, the literal 'MAX' can *
*                       be specified, indicating that all available   *
*                       data will be displayed.                       *
*))MAXLWAIT(nnn)        specifies the maximum number of seconds that  *
*                       each LSPACE will be allowed to complete; after*
*                       this number of seconds, the LSPACE will be    *
*                       terminated with an I/O TIMEOUT message. 0     *
*                       signifies no maximum.                         *
*                                                                     *
*---------------------------------------------------------------------*
         TITLE 'Assembly Variables'
         LCLC  &ASMDT,&ASMTM         Assembly Date/Time
&ASMDT   SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)
&ASMTM   SETC  '&SYSTIME'

         TITLE 'Register Equates'
         YREGS
         TITLE '''IEABRC'''
         COPY  IEABRC
         TITLE '''SSCSTACK'' Macro'
         MACRO
&NAME    SSCSTACK &TYPE,              INIT, PUSH, POP, or TERM         +
               &LOC=,                 ABOVE/BELOW (TYPE=INIT)          +
               &LEN=,                 Length required (TYPE=INIT/PUSH) +
               &STACK=,               Stack origin                     +
               &ADDR=,                Storage address                  +
               &OVERFLOW=,            Overflow action (TYPE=PUSH)      +
               &WTOMSG=               Overflow WTO (If OVERFLOW=WTO)
         PUSH  PRINT
         PRINT NOGEN
.*
.*-------------------------------------------------------------------*.
.*                                                                   *.
.*           S S C S T A C K   M a c r o                             *.
.*                                                                   *.
.*  Function: The SSCSTACK macro manages a LIFO stack that can be    *.
.*            used to relieve the overhead of GETMAIN/FREEMAIN where *.
.*            appropriate.                                           *.
.*                                                                   *.
.*            There are 4 flavours of the SSCSTACK invocation:       *.
.*              SSCSTACK INIT,...     GETMAIN Stack storage          *.
.*              SSCSTACK PUSH,...     Reserve storage on the Stack   *.
.*              SSCSTACK POP,...      Release storage on the Stack   *.
.*              SSCSTACK TERM,...     FREEMAIN Stack storage         *.
.*                                                                   *.
.*            Stack storage *must* be PUSHed and POPped in LIFO      *.
.*            sequence - no checking is done within the macro to     *.
.*            ensure this is the case.                               *.
.*                                                                   *.
.*  Operation: The usage of the SSCSTACK macro is typically:         *.
.*              SSCSTACK INIT,...                                    *.
.*                                                                   *.
.*              SSCSTACK PUSH,...                                    *.
.*              SSCSTACK POP,...                                     *.
.*              SSCSTACK PUSH,...                                    *.
.*              SSCSTACK POP,...                                     *.
.*                .    .                                             *.
.*                .    .                                             *.
.*                                                                   *.
.*              SSCSTACK TERM,...                                    *.
.*                                                                   *.
.*             When the Stack is initially GETMAINed (SSCSTACK INIT),*.
.*             the length and Next Available Byte (NAB) are init-    *.
.*             ialized in the Stack Header. On subsequent SSCSTACK   *.
.*             PUSH requests, the NAB is incremented by the length   *.
.*             requested. SSCSTACK POP requests merely update the NAB*.
.*             with the address passed. SSCSTACK TERM FREEMAINs the  *.
.*             Stack.                                                *.
.*             If a SSCSTACK PUSH request would cause a stack over-  *.
.*             flow, the default processing GETMAINs an area and     *.
.*             returns the address of this area. The SSCSTACK POP    *.
.*             request for this area FREEMAINs the storage.          *.
.*             Default overflow processing can be overridden or      *.
.*             supplemented on the SSCSTACK PUSH: instead of GETMAIN-*.
.*             ing additional storage, the SSCSTACK PUSH request can *.
.*             return a return code, or Abend. Additionally, a WTO   *.
.*             can be issued with any of the overflow options.       *.
.*                                                                   *.
.*             SSCSTACK INIT,                                        *.
.*                   LEN=Length                                      *.
.*                   <,LOC=ANY|BELOW>                                *.
.*                   <,STACK=Stack-pointer>                          *.
.*                                                                   *.
.*             SSCSTACK PUSH,                                        *.
.*                   LEN=Length,                                     *.
.*                   STACK=Stack-pointer                             *.
.*                   <,ADDR=Address-pointer>                         *.
.*                   <,OVERFLOW=Action|WTO|(Action,WTO)>             *.
.*                   <,WTOMSG=WTO-message>                           *.
.*                                                                   *.
.*             SSCSTACK POP,                                         *.
.*                   ADDR=Address=pointer,                           *.
.*                   STACK=Stack-pointer                             *.
.*                                                                   *.
.*             SSCSTACK TERM,                                        *.
.*                   STACK=Stack-pointer                             *.
.*                                                                   *.
.*-------------------------------------------------------------------*.
.*
         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN
         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH010
         AIF   ('&TYPE(1)' EQ 'POP').POP010
         AIF   ('&TYPE(1)' EQ 'INIT').INIT010
         AIF   ('&TYPE(1)' EQ 'TERM').TERM010
         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'
         AGO   .MEND
.*
.INIT010 ANOP
         AIF   ('&LEN' EQ '').INITE01
         AIF   ('&LEN'(1,1) NE '(').INIT020
&LENREG  SETC  '&LEN(1)'
         AIF   ('&LENREG' NE  '1').INIT030
         MNOTE 8,'LEN= register must be 0 or 2-15'
         AGO   .MEND
         AGO   .INIT030
.INIT020 ANOP
&LENREG  SETC  'R0'
         LHI   &LENREG,&LEN Length of Stack
.INIT030 ANOP
&LOCTN   SETC  '&LOC'
         AIF   ('&LOC' NE '').INIT040
&LOCTN   SETC  '31'
.INIT040 ANOP
         LHI   R1,StackHdr_Length       Length of header
         AR    &LENREG,R1               Bump length
         BASR  R2,0
         USING (*,INI&SYSNDX.A-1),R2
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(&LENREG),         this long                     +
               LOC=&LOCTN                wherever we were told
INI&SYSNDX.A DS 0H
         DROP  R2
         XC    0(StackHdr_Length,R1),0(R1)  Clear header
         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length
         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)
         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)
         ST    R0,StackHdr_HWM-StackHdr(0,R1) Save High-Water Mark
         AIF   ('&STACK' EQ '').INIT060
         AIF   ('&STACK'(1,1) EQ '(').INIT050
         ST    R1,&STACK                Save Stack origin
         AGO   .INIT060
.INIT050 ANOP
         LR    &STACK(1),R1             Load return register
         AGO   .INIT060
.INIT060 ANOP
         AIF   (D'Stack).MEND
Stack               DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   This is a LIFO stack that can be used (where appropriate) to    *
*  avoid the overhead of repeated GETMAINs/FREEMAINs. Storage       *
*  within the Stack *must* be used in LIFO sequence.                *
*                                                                   *
*-------------------------------------------------------------------*

StackHdr            EQU   *           Start of Header
StackHdr_StackLen   DS    FL4          Length of Stack
StackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)
StackHdr_Reg_Save   DS    4FL4         Register save area
StackHdr_HWM        DS    AL4          Max NAB value (High-water mark)
StackHdr_Overflows  DS    FL4          Nbr SSCSTACK PUSH overflows
StackHdr_Overflow_HWM DS  FL4          Max Overflow amount
StackHdr_GETMAIN    DS    FL4          Nbr SSCSTACK PUSH ---> GETMAIN
                    DS    0D           Dblwd alignment
StackHdr_Length     EQU   *-StackHdr  Length of Header

&SYSECT  &SYSSTYP
         AGO   .MEND
.INITE01 ANOP
         MNOTE 8,'LEN must be specified for SSCSTACK INIT'
         AGO   .MEND
.*
.PUSH010 ANOP
         LCLA  &INDEX,&COUNT
         LCLB  &GETMAIN,&WTO,&ABEND,&RC
         LCLB  &EXCLOP
         LCLC  &TESTOVFL
         AIF   ('&OVERFLOW' EQ '').PUSH090
&INDEX   SETA  0
&COUNT   SETA  N'&OVERFLOW
         AIF   (&COUNT GT 0).PUSH020
&TESTOVFL SETC '&OVERFLOW'
         AGO   .PUSH030
.PUSH020 ANOP
&INDEX   SETA  &INDEX+1
         AIF   (&INDEX GT &COUNT).PUSH080
&TESTOVFL SETC '&OVERFLOW(&INDEX)'
.PUSH030 ANOP
         AIF   ('&TESTOVFL' NE 'GETMAIN').PUSH040
         AIF   (&EXCLOP).PUSHE03
&GETMAIN SETB  1
&EXCLOP  SETB  1
         AGO   .PUSH020
.PUSH040 ANOP
         AIF   ('&TESTOVFL' NE 'ABEND').PUSH050
         AIF   (&EXCLOP).PUSHE03
&ABEND   SETB  1
&EXCLOP  SETB  1
         AGO   .PUSH020
.PUSH050 ANOP
         AIF   ('&TESTOVFL' NE 'RC').PUSH060
         AIF   (&EXCLOP).PUSHE03
&RC      SETB  1
&EXCLOP  SETB  1
         AGO   .PUSH020
.PUSH060 ANOP
         AIF   ('&TESTOVFL' NE 'WTO').PUSH070
&WTO     SETB  1
         AGO   .PUSH020
.PUSH070 ANOP
         MNOTE 4,'Unrecognized OVERFLOW operand - &TESTOVFL - GETMAIN s+
               bstituted.'
&GETMAIN SETB  1
         AGO   .PUSH020
.PUSH080 ANOP
         AIF   (&EXCLOP).PUSH100
.PUSH090 ANOP
&GETMAIN SETB  1
         AGO   .PUSH100
.PUSH100 ANOP
         AIF   ('&STACK' EQ '').PUSHE02
         AIF   ('&STACK'(1,1) NE '(').PUSH110
&STKREG  SETC  '&STACK(1)'
         AGO   .PUSH120
.PUSH110 ANOP
&STKREG  SETC  'R15'
         L     &STKREG,&STACK           A(Stack Origin)
.PUSH120 ANOP
         AIF   ('&LEN' EQ '').PUSHE01
         AIF   ('&LEN'(1,1) NE '(').PUSH130
&LENREG  SETC  '&LEN(1)'
         AIF   ('&LENREG' EQ '0').PUSH150
         AIF   ('&LENREG' EQ 'R0').PUSH150
         AGO   .PUSH140
.PUSH130 ANOP
&LENREG  SETC  'R0'
.PUSH140 ANOP
         LHI   &LENREG,&LEN
.PUSH150 ANOP
         AHI   &LENREG,7                Ensure a
         SRL   &LENREG,3                 doubleword
         SLL   &LENREG,3                 multiple
         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)
         AR    R1,&LENREG               Bump by length requested
         SLR   R1,&STKREG               Get Stack used
         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?
         JNL   PSH&SYSNDX.E             Yes, Overflow
         ALR   R1,&STKREG               No, offset to address
         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)
         C     R1,StackHdr_HWM-StackHdr(0,&STKREG) Highest?
         JNH   PSH&SYSNDX.C             No, skip
         ST    R1,StackHdr_HWM-StackHdr(0,&STKREG) Yes, update HWM
PSH&SYSNDX.C DS 0H
         SLR   R1,&LENREG               A(Start of storage area)
         AIF   ('&LENREG' EQ '0').PUSH155
         AIF   ('&LENREG' EQ 'R0').PUSH155
         LR    R0,&LENREG               Length of storage
.PUSH155 ANOP
         J     PSH&SYSNDX.M             and skip
PSH&SYSNDX.E DS 0H
         ST    R0,StackHdr_Reg_Save-StackHdr(&STKREG)
         L     R0,StackHdr_Overflows-StackHdr(0,&STKREG) Get count
         AHI   R0,1                       Bump it
         ST    R0,StackHdr_Overflows-StackHdr(0,&STKREG) Save it
         L     R0,StackHdr_Reg_Save-StackHdr(&STKREG)
         AIF   (NOT &WTO).PUSH220
         LCLC  &WTOLIT
         AIF   (K'&WTOMSG LT 3).PUSH160
&WTOLIT  SETC  '&WTOMSG'(2,K'&WTOMSG-2)
         AGO   .PUSH170
.PUSH160 ANOP
&WTOLIT  SETC  'Stack001 - Stack Overflow'
.PUSH170 ANOP
         ST    R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Save R1
         ST    &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Save Len
         AIF   ('&STKREG' EQ '1').PUSH180,                             +
               ('&STKREG' EQ 'R1').PUSH180,                            +
               ('&STKREG' EQ '14').PUSH180,                            +
               ('&STKREG' EQ 'R14').PUSH180,                           +
               ('&STKREG' EQ '15').PUSH180,                            +
               ('&STKREG' EQ 'R15').PUSH180
         AGO   .PUSH190
.PUSH180 ANOP
         ST    R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Save R2
         LR    R2,&STKREG                 Save A(Stack)
.PUSH190 ANOP
         WTO   '&WTOLIT',ROUTCDE=11
         AIF   ('&STKREG' EQ '1').PUSH200,                             +
               ('&STKREG' EQ 'R1').PUSH200,                            +
               ('&STKREG' EQ '14').PUSH200,                            +
               ('&STKREG' EQ 'R14').PUSH200,                           +
               ('&STKREG' EQ '15').PUSH200,                            +
               ('&STKREG' EQ 'R15').PUSH200
         AGO   .PUSH210
.PUSH200 ANOP
         LR    &STKREG,R2                 Restore A(Stack)
         L     R2,StackHdr_Reg_Save+8-StackHdr(&STKREG)  Restore R2
.PUSH210 ANOP
         L     R1,StackHdr_Reg_Save-StackHdr(&STKREG)  Restore
         L     &LENREG,StackHdr_Reg_Save+4-StackHdr(&STKREG)  Rest Len
.PUSH220 ANOP
         AIF   (NOT &RC).PUSH230
         LA    R0,0                     Clear Length register
         LA    R1,0                     Clear pointer
         LA    R15,8                    Set return code
         J     PSH&SYSNDX.O             and skip
         AGO   .PUSH250
.PUSH230 ANOP
         AIF   (NOT &ABEND).PUSH240
         DC    H'0'                     ABEND
         AGO   .PUSH250
.PUSH240 ANOP
         C     R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Highest?
         JNH   PSH&SYSNDX.G             No, skip
         ST    R1,StackHdr_Overflow_HWM-StackHdr(0,&STKREG) Yes, update
PSH&SYSNDX.G DS 0H
         L     R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Get count
         AHI   R1,1                     Bump it
         ST    R1,StackHdr_GETMAIN-StackHdr(0,&STKREG) Save it
         AHI   &LENREG,8                Bump length by 8
         LR    R15,&STKREG              Get stack address
         SLL   R15,1                    Clear high-order bit
         SRL   R15,25                   Clear 24-bit address
         LTR   R15,R15                  Above-the-line?
         JZ    PSH&SYSNDX.I             No, skip
         BASR  R2,0
         USING (*,PSH&SYSNDX.H-1),R2
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(&LENREG),         this long                     +
               LOC=31                    above-the-line
PSH&SYSNDX.H DS 0H
         DROP  R2
         J     PSH&SYSNDX.K             and skip
PSH&SYSNDX.I DS 0H
         BASR  R2,0
         USING (*,PSH&SYSNDX.J-1),R2
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(&LENREG),         this long                     +
               LOC=24                    below-the-line
PSH&SYSNDX.J DS 0H
         DROP  R2
PSH&SYSNDX.K DS 0H
         ST    R0,0(0,R1)               Save length
         AHI   R1,8                     Bump over our header
         AHI   R0,-8                    Adjust length
.PUSH250 ANOP
PSH&SYSNDX.M DS 0H
         LA    R15,0                    Clear return register
         AIF   (NOT &RC).PUSH260
PSH&SYSNDX.O DS 0H
.PUSH260  ANOP
         AIF   ('&ADDR' EQ '').MEND
         AIF   ('&ADDR'(1,1) NE '(').PUSH270
         LR    &ADDR(1),R1             Load return register
         AGO   .MEND
.PUSH270 ANOP
         ST    R1,&ADDR                 Save Storage pointer
         AGO   .MEND
.PUSHE01 ANOP
         MNOTE 8,'LEN must be specified for SSCSTACK PUSH'
         AGO   .MEND
.PUSHE02 ANOP
         MNOTE 8,'STACK must be specified for SSCSTACK PUSH'
         AGO   .MEND
.PUSHE03 ANOP
         MNOTE 8,'Mutually exclusive OVERFLOW= operands.'
         AGO   .MEND
.*
.POP010  ANOP
         AIF   ('&ADDR' EQ '').POPE01
         AIF   ('&ADDR'(1,1) NE '(').POP020
&ADDREG  SETC  '&ADDR(1)'
         AGO   .POP030
.POP020  ANOP
&ADDREG  SETC  'R0'
         L     &ADDREG,&ADDR
.POP030  ANOP
         AIF   ('&STACK' EQ '').POPE02
         AIF   ('&STACK'(1,1) NE '(').POP040
&STKREG  SETC  '&STACK(1)'
         AGO   .POP050
.POP040  ANOP
&STKREG  SETC  'R15'
         L     &STKREG,&STACK           A(Stack Origin)
.POP050  ANOP
         CR    &ADDREG,&STKREG          Part of our stack?
         JL    POP&SYSNDX.C             No, skip
         C     &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)  Really?
         JNL   POP&SYSNDX.C             No, skip
         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)
         J     POP&SYSNDX.E             and exit
POP&SYSNDX.C DS 0H
         AHI   &ADDREG,-8               Back up to our header
         L     R0,0(0,&ADDREG)          Get length of GETMAINed stg
         BASR  R2,0
         USING (*,POP&SYSNDX.D-1),R2
         STORAGE RELEASE,               Free our storage               +
               ADDR=(&ADDREG),           starting here                 +
               LENGTH=(0)                for this long
POP&SYSNDX.D DS 0H
         DROP  R2
POP&SYSNDX.E DS 0H
         AGO   .MEND
.POPE01  ANOP
         MNOTE 8,'ADDR must be specified for SSCSTACK POP'
         AGO   .MEND
.POPE02  ANOP
         MNOTE 8,'STACK must be specified for SSCSTACK POP'
         AGO   .MEND
.*
.TERM010 ANOP
         AIF   ('&STACK' EQ '').TERME02
         AIF   ('&STACK'(1,1) NE '(').TERM020
         AIF   ('&STACK(1)' EQ '1').TERM030,                           +
               ('&STACK(1)' EQ 'R1').TERM030
         LR    R1,&STACK(1)             Stack origin
         AGO   .TERM030
.TERM020 ANOP
         L     R1,&STACK                A(Stack Origin)
.TERM030 ANOP
         L     R0,StackHdr_StackLen-StackHdr(0,R1) Length
         BASR  R2,0
         USING (*,TRM&SYSNDX.A-1),R2
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
TRM&SYSNDX.A DS 0H
         DROP  R2
         AGO   .MEND
.TERME02 ANOP
         MNOTE 8,'STACK must be specified for SSCSTACK TERM'
         AGO   .MEND
.*
.MEND    ANOP
         POP   PRINT
         MEND
         TITLE 'IBM Data Areas'
         PUSH  PRINT
         PRINT NOGEN
         IKJCPPL
CPPL_Length EQU *-CPPL

         IKJCSPL
CSPL_Length EQU *-CSPL

         IKJCSOA
CSOA_Length EQU *-CSOA

         IKJPPL
PPL_Length EQU *-PPL

         IKJIOPL
IOPL_Length EQU *-IOPL

         IKJUPT
         IKJTSVT
         IKJEFLWA
         IKJPSCB
         IEFJFCBN
         DCBD  DSORG=PS
         IHADCBE
         IHAPSA
         CVT   DSECT=YES
         IHAASVT
         IHAASCB
         IHAASXB
         IHAECVT
         IHAPCCA
         IOSDSHID
         IKJTCB
         IHARB
         IHACDE
         IEZJSCB
         IEFJSSIB
         IHASDWA
         IEFUCBOB PREFIX=YES
         IOSDPATH
         IECDDCE
         IECSDSL1 (4)
         IEFJESCT
         IEFJSSOB
         IEFSSSA
         IGDVLD
         IEFTIOT1
         IEFZB505 LOCEPAX=YES
         ASASYMBP
         CSRSIIDF

LSPACE_Parm LSPACE MF=D
LSPACE_Parm_Length EQU *-LSPACE_Parm

LSPACE_Data LSPACE MF=(D,DATA)
LSPACE_Data_Length EQU *-LSPACE_Data

         POP   PRINT
         TITLE 'Local DSECTs'
*-------------------------------------------------------------------*
*   This DSECT describes the table in which we maintain DASD        *
*  volume information. The table is OBTAINed in 31-bit storage      *
*  the first time it is required, and expands as required to        *
*  contain the entries required. Note that the table never shrinks. *
*                                                                   *
*   Each entry contains the volume information as it will be sent   *
*  to the user (as well as some internal info). in addition to      *
*  1 entry per volume, the Headings, Totals and Statistics lines,   *
*  if requested, occupy table entries.                              *
*-------------------------------------------------------------------*

VolTbl                    DSECT

VolTbl_Hdr                EQU   *     Info Table Header
VolTbl_Hdr_TbLen          DS    FL4    Length of table
VolTbl_Hdr_Count          DS    FL4    Number of used entries
VolTbl_Hdr_Vols_Eligible  DS    FL4    Nbr Volume entries eligible
VolTbl_Hdr_Vols_Total     DS    FL4    Nbr Volume entries in table
VolTbl_Hdr_Vols_Proc      DS    FL4    Nbr Volume entries complete
VolTbl_Hdr_Total_Off      DS    FL4    Offset of Totals Line
VolTbl_Hdr_SMS_Off        DS    FL4    Offset of SMS Anomaly line
VolTbl_Hdr_SubT_Off       DS    FL4    Offset of SubTask Stats Hdg(s)
VolTbl_Hdr_STIMERM_Adj    DS    FL4    Used by H00010 for STIMERM
                          DS    0D
VolTbl_Hdr_LSPACE_Avg     DS    DL8    Used by H00010 for STIMERM
                          DS    0F     Alignment
VolTbl_Hdr_ECB            DS    FL4    ECB POSTed when table complete
                          DS    X      Flag Byte
VolTbl_Hdr_OW48527        EQU   *-1,X'80' 1... .... APAR OW48527 on
VolTbl_Hdr_MaxLWait       DS    HL2    Max LSPACE Wait time (secs)
                          DS    0D     Alignment
VolTbl_Hdr_Length         EQU   *-VolTbl_Hdr  Length of header

VolTbl_Ent_Start          EQU   *     Info Table Entry
VolTbl_Ent_ECB            DS    FL4    ECB POSTed when entry complete
                          DS    X         Status Flag
VolTbl_Ent_Processed      EQU   *-1,X'80' 1... .... This entry done
VolTbl_Ent_LSPACE_Fail    EQU   *-1,X'40' .1.. .... LSPACE failed
VolTbl_Ent_U522           EQU   *-1,X'20' ..1. .... MAXLWAIT(our ESTAE)
                          DS    X         Entry Descriptor Flag
VolTbl_Ent_Heading_Line1  EQU   *-1,X'80' 1... .... 1st Heading Line
VolTbl_Ent_Heading_Line   EQU   *-1,X'40' .1.. .... Other Heading Line
VolTbl_Ent_Detail_Line    EQU   *-1,X'20' ..1. .... Detail Line
VolTbl_Ent_Total_Line     EQU   *-1,X'10' ...1 .... Total Line
VolTbl_Ent_Stats_Line     EQU   *-1,X'08' .... 1... Stats Line
VolTbl_Ent_SMS_Line       EQU   *-1,X'04' .... .1.. SMS Anomaly Msg
                          DS    X         Statistics Line Status
VolTbl_Ent_Stats_CPUTime  EQU   *-1,X'80' 1... .... CPU Time Stats Line
VolTbl_Ent_Stats_31Stack  EQU   *-1,X'40' .1.. .... 31Bit Stack Stats
VolTbl_Ent_Stats_24Stack  EQU   *-1,X'20' ..1. .... 24Bit Stack Stats
VolTbl_Ent_Stats_Done     EQU   *-1,X'01' .... ...1 Stats line filled

VolTbl_Ent_Sort_Start     DS    0D      Start of Sort fields
VolTbl_Ent_Sort_FreeTrk   DS    DL8      Free Tracks
VolTbl_Ent_Sort_FreeCyl   DS    DL8      Free Cylinders
VolTbl_Ent_Sort_FreeBytes DS    DL8      Free Bytes
VolTbl_Ent_Sort_FreePct   DS    DL8      Free Pct (xx.x)
VolTbl_Ent_Sort_FreeExt   DS    DL8      Free Extents
VolTbl_Ent_Sort_LargTrk   DS    DL8      Largest Free Tracks
VolTbl_Ent_Sort_LargCyl   DS    DL8      Largest Free Cylinders
VolTbl_Ent_Sort_VTOCTrk   DS    DL8      Tracks in the VTOC
VolTbl_Ent_Sort_FreeDSCB  DS    DL8      Free DSCBs
VolTbl_Ent_Sort_VTOCFree  DS    DL8      VTOC % Free
VolTbl_Ent_Sort_VolSize   DS    DL8      Bytes/Volume
VolTbl_Ent_Sort_DSCBs     DS    DL8      DSCBs
VolTbl_Ent_Sort_FragIndex DS    DL8      Frag Index
VolTbl_Ent_Sort_End       EQU   *       End of Sort fields
                          ORG   VolTbl_Ent_Sort_Start
VolTbl_Ent_Sort_Fields    DS    XL(VolTbl_Ent_Sort_End-VolTbl_Ent_Sort_+
               Start)

VolTbl_Ent_Totals         ORG   VolTbl_Ent_Sort_Start
VolTbl_Ent_Total_FreeTracks   DS    DL8   Free Tracks
VolTbl_Ent_Total_FreeCyls     DS    DL8   Free Cylinders
VolTbl_Ent_Total_FreeBytes    DS    DL8   Free Bytes
VolTbl_Ent_Total_FreePct      DS    DL8   Free % (xx.x)
VolTbl_Ent_Total_Extents      DS    DL8   Free Extents
VolTbl_Ent_Largest_FreeTracks DS    DL8   Largest Free Tracks
VolTbl_Ent_Largest_FreeCyls   DS    DL8   Largest Free Cyls
VolTbl_Ent_Total_VTOCTrk      DS    DL8   Total tracks in the VTOCs
VolTbl_Ent_Total_FreeDSCBs    DS    DL8   Total free DSCBs
VolTbl_Ent_Total_VTOCFree     DS    DL8   VTOC % Free
VolTbl_Ent_Total_VolSize      DS    DL8   Total Bytes
VolTbl_Ent_Total_DSCBs        DS    DL8   Total DSCBs
VolTbl_Ent_Total_FragIndex    DS    DL8   Total of Frag Indices
VolTbl_Ent_Total_Vols_OK      DS    FL4   Vols with valid LSPACE data
                              ORG   ,

                          DS    0F      Align
VolTbl_Ent_CB_Start       EQU   *        Start of Control Blocks
VolTbl_Ent_UCBCopy        DS    XL48      UCB Copy
VolTbl_Ent_DCECopy        DS    XL48        DCE Copy
VolTbl_Ent_LSPACE_Data    DS    CL(LSPACE_Data_Length) LSPACE
VolTbl_Ent_DSCB           DS    CL(DS4END-IECSDSL4) Area for F4 DSCB
VolTbl_Ent_CB_End         EQU   *          End of Control Blocks
                          ORG   VolTbl_Ent_CB_Start
VolTbl_Ent_CB_Fields      DS    XL(VolTbl_Ent_CB_End-VolTbl_Ent_CB_Star+
               t)
                          ORG   ,

VolTbl_Ent_Display_Start  EQU   *      Start of Display fields
VolTbl_Ent_Volser         DS    CL6     VOLSER
                          DS    C
VolTbl_Ent_DevAddr        DS    CL4     Device Address
                          DS    CL2
VolTbl_Ent_DevType        DS    CL8     Device Type
                          DS    C
VolTbl_Ent_Attrib         DS    CL3     Mount Status
VolTbl_Ent_VTOC_SMS       DS    CL1     '*' if VTOC=SMS, UCB¬=SMS
                          DS    C
VolTbl_Ent_ErrMsg         DS    0CL80   Error message
VolTbl_Ent_FreeSpace_Info EQU   *       --- Free Space Info Start
VolTbl_Ent_FreeTrk        DS    CL6         Nbr Free Tracks
                          DS    C
VolTbl_Ent_FreeCyl        DS    CL5         Nbr Free Cylinders
                          DS    CL2
VolTbl_Ent_FreePct        DS    CL4         % of volume free
                          DS    C
VolTbl_Ent_FreeBytes      DS    CL6         Bytes free on the volume
                          DS    C
VolTbl_Ent_FreeExt        DS    CL5         Nbr Free Extents
                          DS    CL2         Largest Free Extents
VolTbl_Ent_LargTrk        DS    CL6         Largest Free Tracks
                          DS    C
VolTbl_Ent_LargCyl        DS    CL5         Largest Free Cylinders
VolTbl_Ent_FreeSpace_Info_End EQU *     --- Free Space Info End
                          DS    C
VolTbl_Ent_Frag_Indx      DS    CL5         Fragmentation Index
                          DS    CL2
VolTbl_Ent_VTOC_Info      EQU   *       --- VTOC Info Start
VolTbl_Ent_VTOCTrk        DS    CL5         VTOC Tracks
                          DS    C
VolTbl_Ent_FreeDSCB       DS    CL5         Free DSCBs in VTOC
                          DS    C
VolTbl_Ent_VTOCFree       DS    CL4         % DSCBs free
                          DS    C
VolTbl_Ent_VTOCIX         DS    CL2         VTOC Index Status
VolTbl_Ent_VTOC_Info_End  EQU   *       --- VTOC Info End
                          DS    C           Volume Size
VolTbl_Ent_VolSize        DS    CL6         Device capacity (in bytes)
                          DS    C
VolTbl_Ent_SMS_Info       EQU   *       --- SMS Info Start
VolTbl_Ent_SMS_StorGrp    DS    CL8         SMS Storage Group
                          DS    C
VolTbl_Ent_SMS_Status     DS    CL12        SMS Volume Status
VolTbl_Ent_SMS_Info_End   EQU   *       --- SMS Info End
                          DS    C
VolTbl_Ent_CHPID_Info     EQU   *       --- CHPID Info Start
VolTbl_Ent_CHPIDs         DS    CL(8*4)     8 CHPIDs @ 4 bytes each
VolTbl_Ent_CHPID_Info_End EQU   *       --- CHPID Info End
VolTbl_Ent_Display_End    EQU   *       End of Display area
VolTbl_Ent_Display_Len    EQU   *-VolTbl_Ent_Display_Start
                          ORG   VolTbl_Ent_Display_Start
VolTbl_Ent_Display        DS    CL(VolTbl_Ent_Display_Len)
                          ORG   ,
                          DS    0D      Alignment
VolTbl_Ent_Len            EQU   *-VolTbl_Ent_Start Entry Length
                          ORG   VolTbl_Ent_Start
VolTbl_Ent                DS    CL(VolTbl_Ent_Len)
                          ORG   ,

*-------------------------------------------------------------------*
*   This DSECT describes the area of storage used to manage the     *
*  subtasks ATTACHed to retrieve the volume information.            *
*-------------------------------------------------------------------*
SubTask_Area              DSECT       Data for each subtask

SubTask_Area_Hdr          EQU   *
SubTask_Area_Hdr_Len      DS    FL4    SubPool, Length
SubTask_Area_Hdr_Count    DS    FL4    Nbr entries following
                          DS    0D
SubTask_Area_Hdr_Length   EQU   *-SubTask_Area  Length of Header

SubTask_Area_Ent          EQU   *      1 Entry per subtask
SubTask_Area_Ent_ECB      DS    FL4     ECB POSTed at Subtask end
SubTask_Area_Ent_TCB      DS    AL4     A(SubTask TCB - ATTACHX)
SubTask_Area_Ent_Parms    DS    5AL4    Parms for subtask
                          DS    0D      Alignment
SubTask_Area_Ent_Length   EQU   *-SubTask_Area_Ent

*-------------------------------------------------------------------*
*   This DSECT describes the area of storage used to save the lists *
*  of UCBs that should be included (UCB) or excluded (XUCB).        *
*   This storage, if required, is acquired by the routine that      *
*  PARSEs the parameters (C00010).                                  *
*-------------------------------------------------------------------*
UCB_List                  DSECT

UCB_List_Hdr              EQU   *     Start of header
UCB_List_Hdr_Len          DS    FL4    Length of table
UCB_List_Hdr_Count        DS    FL4    Number of entries
UCB_List_Hdr_Length       EQU   *-UCB_List_Hdr  Header length
UCB_List_Ent              EQU   *     Start of entry
UCB_List_Ent_UCB_Len      DS    XL1    Len of UCB entered
UCB_List_Ent_UCB          DS    CL4    UCB, with wildcards = X'FF'
UCB_List_Ent_Mask         DS    CL4    Wildcard mask, wildcards = X'FF'
*                                                         other = X'00'
UCB_List_Ent_Length       EQU   *-UCB_List_Ent   Length of an entry

*-------------------------------------------------------------------*
*   This DSECT describes the area of storage used to save the lists *
*  of Volsers that should be included (VOL) or excluded (XVOL).     *
*   This storage, if required, is acquired by the routine that      *
*  PARSEs the parameters (C00010).                                  *
*-------------------------------------------------------------------*
Vol_List                  DSECT

Vol_List_Hdr              EQU   *      Start of header
Vol_List_Hdr_Len          DS    FL4     Length of table
Vol_List_Hdr_Count        DS    FL4     Number of entries
Vol_List_Hdr_Length       EQU   *-Vol_List_Hdr  Header length
Vol_List_Ent              EQU   *      Start of entry
Vol_List_Ent_Vol          DS    CL6     Vol, with wildcards=X'FF'
Vol_List_Ent_Mask         DS    CL6     Wildcard mask, wildcards=X'FF'
*                                                          other=X'00'
Vol_List_Ent_Length       EQU   *-Vol_List_Ent   Length of an entry

*-------------------------------------------------------------------*
*   This DSECT describes the area of storage used to save the list  *
*  of SMS Storage Groups entered as a selection criterion.          *
*   This storage, if required, is acquired by the routine that      *
*  PARSEs the parameters (C00010).                                  *
*-------------------------------------------------------------------*
STORGRP_List              DSECT

STORGRP_List_Hdr          EQU   *      Start of header
STORGRP_List_Hdr_Len      DS    FL4     Length of table
STORGRP_List_Hdr_Count    DS  FL4       Number of entries
STORGRP_List_Hdr_Length   EQU *-STORGRP_List_Hdr Header length
STORGRP_List_Ent          EQU   *      Start of entry
STORGRP_List_Ent_STORGRP  DS    CL(L'VLDSTGRP) Name, wildcards=x'FF'
STORGRP_List_Ent_Mask     DS    CL(L'VLDSTGRP) Mask, wildcards=x'FF'
*                                                 other = X'00'
STORGRP_List_Ent_Length   EQU   *-STORGRP_List_Ent Length of an entry
         TITLE 'Global Dynamic Storage'

*-------------------------------------------------------------------*
*   This DSECT describes dynamic storage addressable by all rout-   *
*  ines in this program.                                            *
*-------------------------------------------------------------------*
@_Dynam                   DSECT

@_31Bit_Stack_Ptr         DS    AL4    A(General Stack)
@_31Bit_Stack_Length      EQU   16384-StackHdr_Length 16K Stack

@_24Bit_Stack_Ptr         DS    AL4    A(24-bit Stack)
@_24Bit_Stack_Length      EQU 2048-StackHdr_Length 2K Stack

@_VolTbl_Ptr              DS    AL4    A(Table of space info)

                          DS    X      Environment flag
@_Batch_Environ           EQU   *-1,X'80' 1... .... Batch run
@_TSO_Command             EQU   *-1,X'40' .1.. .... TSO command
@_OW48527                 EQU   *-1,X'20' ..1. .... OW48527 installed
@_IKJEFTSR                EQU   *-1,X'10' ...1 .... IKJEFTSR Invoked
@_CHAP_Done               EQU   *-1,X'08' .... 1... Prty lowered

                          DS    X      Output Options Flags
@_No_Headings             EQU   *-1,X'80' 1... .... No hdgs
@_No_Details              EQU   *-1,X'40' .1.. .... No detail
@_No_Totals               EQU   *-1,X'20' ..1. .... No totals
@_Statistics              EQU   *-1,X'10' ...1 .... Internal Stats
@_ISPF_SPACE              EQU   *-1,X'08' .... 1... ISPF tbl and pnl
@_ISPF_EDIF               EQU   *-1,X'04' .... .1.. ISPF EDIF
@_ISPF_BRIF               EQU   *-1,X'02' .... ..1. ISPF BRIF
@_ISPF_Explicit           EQU   *-1,X'01' .... ...1 ISPF Kwd specified

                          DS    X      More Output Options Flags
@_No_LSPACE               EQU   *-1,X'80' 1... .... Don't issue LSPACE
@_ReDisplay               EQU   *-1,X'40' .1.. .... Redisplay required
@_OutData_DISPLAY         EQU   *-1,X'04' .... .1.. OUTDATA(DISPLAY)
@_OutData_CB              EQU   *-1,X'02' .... ..1. OUTDATA(CB)
@_OutData_ALL             EQU   *-1,X'01' .... ...1 OUTDATA(ALL)

                          DS    X      Error Flags
@_VolTbl_GETMAIN_Err      EQU   *-1,X'80' 1... .... Not enough storage
@_No_APF                  EQU   *-1,X'20' ..1. .... No APF auth
@_IKJEFTSR_Err            EQU   *-1,X'10' ...1 .... Error in IKJEFTSR
@_SYSCLOCK_Err            EQU   *-1,X'08' .... 1... SYSCLOCK Mismatch
@_Incompatible_OS         EQU   *-1,X'04' .... .1.. Incompatible OS
@_Internal_Err            EQU   *-1,X'02' .... ..1. Unknown parm
@_LSPACE_Failed           EQU   *-1,X'01' .... ...1 VolTbl Incomplete

@_CPU_Time_Init           DS    DL8    CPU Time at start of pgm
@_CPU_Time_Used           DS    DL8    Accumulated CPU Time

@_IKJEFTSR_RC             DS    FL4    IKJEFTSR Return code area
@_IKJEFTSR_Reas           DS    FL4    IKJEFTSR Reason code area

@_IKJEFTSR_TimeStamp_Ptr  DS    AL4    A(TimeStamp for IKJEFTSR)
@_NSwap_Time              DS    DL8    Non-swappable time

@_Sort_Field              DS    CL8    Sort Field
@_Sort_Direction          DS    CL1    Sort Direction (A/D)

@_LineSize                DS    HL2    Line Size from command line

@_MaxLWait                DS    HL2    Max LSPACE Wait time (seconds)

@_MaxTasks                DS    HL2    Max LSPACE sub-tasks on cmdline
@_SubTask_Count           DS    FL4    Nbr subtasks to ATTACH
@_SubTask_Area_Ptr        DS    AL4    A(SubTask Area)
@_LP_Count                DS    FL4    Nbr active LPs

@_OutFile_DDname          DS    CL8    DDName of current OUTFILE
@_OutFile_24Bit_Stack_Ptr DS    AL4    A(24-bit Stack for OutFile DCBs)
@_OutFile_Chain_Ptr       DS    AL4    A(Start of Output DCB chain)
@_OutFile_PUT_Code        DS    AL4    A(24-bit PUT code)

*  ------  Selection Criteria  ------
@_Vol_List_Ptr            DS    AL4     A(List of VOLSER Masks)
@_XVol_List_Ptr           DS    AL4     A(List of XVOLSER Masks)
@_UCB_List_Ptr            DS    AL4     A(List of UCB Masks)
@_XUCB_List_Ptr           DS    AL4     A(List of XUCB Masks)
@_STORGRP_List_Ptr        DS    AL4     A(List of StorGrps)
@_UNITNM                  DS    CL8     Unit Name
                          DS    X       Mount Attribute
@_ATTRPvt                 EQU   *-1,X'80' 1... .... Private
@_ATTRPub                 EQU   *-1,X'40' .1.. .... Public
@_ATTRStg                 EQU   *-1,X'20' ..1. .... Storage
@_ATTRSMS                 EQU   *-1,X'10' ...1 .... SMS

*-----------------------------  Start of TSO Cmd specific data  -----*
                          DS    0D                                   *
@_CPPL_Ptr                DS    AL4     A(Cmd Proc Parm List)        *
                          DS    X       Flag byte                    *
@_TSO_Processed           EQU   *-1,X'80' 1... .... Cmd processed    *
@_ISPLINK                 DS    AL4     A(ISPLINK)                   *
*-----------------------------  End of TSO Cmd specific data  -------*

*-----------------------------  Start of Batch specific data  -------*
                          DS    0D                                   *
@_SYSIN_DCB_Ptr           DS    AL4     A(SYSIN DCB)                 *
@_Page_Count              DS    HL2     Page Count                   *
@_Line_Count              DS    HL2     Line Count                   *
@_Bat_CPPL_Ptr            DS    AL4     A(CPPL in Batch)             *
                          DS    0F      Alignment                    *
@_Bat_CPPL                DS    CL(CPPL_Length)  CPPL in Batch       *
                          DS    0F      Alignment                    *
@_SYSIN_DCBE              DS    CL(C_SYSIN_DCBE_Length) SYSIN DCBE   *
*-----------------------------  End of Batch specific data  ---------*
                          ORG   ,
*=====================================================================*
                          DS    0D
@_Dynam_Length            EQU   *-@_Dynam  Length of Global storage

         TITLE 'Main Program Block'

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : A00010                                                 *
*                                                                     *
*  Abstract  : Main program loop - invoke other routines to perform   *
*              real work                                              *
*                                                                     *
*  Inputs    : As received on invocation                              *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Reset Stack statistics for each   *
*                                   iteration.                        *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Added 24-bit Stack                *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Added check for re-invocation by  *
*                                   IKJEFTSR                          *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardized calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

*        PRINT NOGEN

&PGMNAME CSECT
&PGMNAME AMODE 31
&PGMNAME RMODE ANY

         SYSSTATE ARCHLVL=1

         J     A00010                   Skip eyecatcher
         DC    C'&PGMNAME &VERSION  &ASMDT &ASMTM'

A00010   DS    0H
         BAKR  R14,0                    Save callers registers
         LARL  R11,A_Literals           Point to our literals
         USING (A_Literals,A_Literals_End),R11 Tell the assembler

*-------------------------------------------------------------------*
*    Make sure we're in 31-bit mode                                 *
*-------------------------------------------------------------------*
         TAM   ,                        Check AMODE
         JM    A00020                   AMODE 31, OK
         SAM31 ,                        Get into 31-bit mode

A00020   DS    0H
*-------------------------------------------------------------------*
*    Get some storage for our LIFO stack ...                        *
*-------------------------------------------------------------------*
         LHI   R0,@_31Bit_Stack_Length  Length of storage we need
         SSCSTACK INIT,                 Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=31                    above-the-line

         LR    R3,R1                    Save its address

*-------------------------------------------------------------------*
*    ... and get some room on it for the globally addressable       *
*     variables ...                                                 *
*-------------------------------------------------------------------*
         SSCSTACK PUSH,                 Get Stack area                 +
               LEN=@_Dynam_Length,       this long                     +
               STACK=(R3)                using this stack

         LR    R12,R1                   Point to our storage

         USING @_Dynam,R12              Assign a base

         LA    R0,@_Dynam               A(Our storage)
         LHI   R1,@_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage

         ST    R3,@_31Bit_Stack_Ptr     Save A(Stack)

*-------------------------------------------------------------------*
*    ... and finally get an area on it for our local storage        *
*-------------------------------------------------------------------*
         SSCSTACK PUSH,                 Get Stack area                 +
               LEN=@A_Dynam_Length,      this long                     +
               STACK=@_31Bit_Stack_Ptr    using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@A_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Set up save area, and restore the important registers          *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         LR    R13,R1                   Load dynam base
         USING @A_Dynam,R13             Tell the assembler
         MVC   4(4,R13),=C'F1SA'        Init save area

         EREG  R0,R3                    Restore callers registers

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@A_Parms_Std         Save it
         LA    R15,@_31Bit_Stack_Ptr    A(31-bit Stack Pointer)
         ST    R15,@A_Parms_Std+4       Save it
         LA    R15,@_24Bit_Stack_Ptr    A(24-bit Stack Pointer)
         ST    R15,@A_Parms_Std+8       Save it

         ST    R1,@A_Original_R1        Save R1 on entry

*--------------------------------------------------------------------*
*   Initialize                                                       *
*--------------------------------------------------------------------*
         LA    R15,@A_Original_R1       A(Original R1)
         ST    R15,@A_Parms_B00010      Save it

         LA    R1,@A_Parms              A(Parmlist)
         BRAS  R14,B00010               Go do initialization

         ST    R15,@A_Max_RC            Save the return code
         LTR   R15,R15                  Did it work?
         JNZ   A00130                   No, skip

*--------------------------------------------------------------------*
*   If we are being re-invoked by IKJEFTSR ...                       *
*--------------------------------------------------------------------*
         TM    @_IKJEFTSR,L'@_IKJEFTSR  IKJEFTSR invocation?
         JNO   A00100

*--------------------------------------------------------------------*
*   ... we want to invoke E00010 with the original @_Dynam.          *
*  Therefore, we save the current @_Dynam address and load up the    *
*  one passed to us (the original) ...                               *
*--------------------------------------------------------------------*
         L     R12,@A_Original_R1       Point to the @_Dynam
         L     R12,2(0,R12)              to the one passed to us

*--------------------------------------------------------------------*
*   ... turn on the @_IKJEFTSR flag (since it is not on in this      *
*  version of @_Dynam) ...                                           *
*--------------------------------------------------------------------*
         OI    @_IKJEFTSR,L'@_IKJEFTSR  On the flag

*--------------------------------------------------------------------*
*   ... invoke E00010 to populate the table ...                      *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(Parm list)
         BRAS  R14,E00010               Go populate table

*--------------------------------------------------------------------*
*   ... turn off the @_IKJEFTSR flag, and re-point to our @_Dynam    *
*--------------------------------------------------------------------*
         NI    @_IKJEFTSR,X'FF'-L'@_IKJEFTSR  Off the flag
         LR    R12,R3                  Reset @_Dynam base

*--------------------------------------------------------------------*
*   ... and exit                                                     *
*--------------------------------------------------------------------*
         LA    R15,0                   Clear return code
         ST    R15,@A_Max_RC           Save it
         J     A90010                  and exit

A00100   DS    0H
*--------------------------------------------------------------------*
*   And now loop: Get Input                                          *
*                 Get Space Info                                     *
*                 Display Results                                    *
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
*   Reset the CPU Time used so far, in case we have to produce       *
*    stats ...                                                       *
*--------------------------------------------------------------------*
         TIMEUSED STORADR=@_CPU_Time_Init,  Reset CPU Time Used        +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               CPU=MIC                   get it in microseconds
         XC    @_CPU_Time_Used,@_CPU_Time_Used  Clear accum CPU Time

*--------------------------------------------------------------------*
*   ... and the Stack statistics ...                                 *
*--------------------------------------------------------------------*
         L     R15,@_31Bit_Stack_Ptr    Point to the stack
         LA    R0,0                     Clear work register
         ST    R0,StackHdr_HWM-StackHdr(R15) Clear high-water mark
         ST    R0,StackHdr_GETMAIN-StackHdr(R15) Clear converted PUSHs
         ST    R0,StackHdr_Overflow_HWM-StackHdr(R15) and GETMAIN HWM

*--------------------------------------------------------------------*
*   ... WAIT for our subtasks to complete ...                        *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(ParmList)
         BRAS  R14,S00010               WAIT for our subtasks

*--------------------------------------------------------------------*
*   ... and then go and get some input                               *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(ParmList)
         BRAS  R14,C00010               Go get processing parms
         LTR   R15,R15                  EOF?
         JNZ   A90010                   Yes, exit

*--------------------------------------------------------------------*
*   We have something, so go scan the UCBs ...                       *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(Parm list)
         BRAS  R14,D00010               Go get eligible UCBs

         LTR   R15,R15                  Any?
         JZ    A00120                   Yes, skip
         C     R15,@A_Max_RC            No, biggest RC so far?
         JNH   A00130                   No, skip
         ST    R15,@A_Max_RC            Yes, save it
         J     A00130                   and skip

A00120   DS    0H
*--------------------------------------------------------------------*
*   ... and get the info about them                                  *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(Parm list)
         BRAS  R14,E00010               Go populate table

A00130   DS    0H
*--------------------------------------------------------------------*
*   Output the info ...                                              *
*--------------------------------------------------------------------*
         LA    R1,@A_Parms              A(Parm list)
         BRAS  R14,F00010               Output the results
         C     R15,@A_Max_RC            Biggest RC so far?
         JNH   A00140                   No, skip
         ST    R15,@A_Max_RC            Yes, save it

A00140   DS    0H
*--------------------------------------------------------------------*
*   ... and do it all again                                          *
*--------------------------------------------------------------------*
         L     R15,@A_Max_RC            Get max return code
         CHI   R15,4                    Too big?
         JNH   A00100                   No, get more input

A90010   DS    0H
*-------------------------------------------------------------------*
*    Perform our Termination routines ...                           *
*-------------------------------------------------------------------*
         LA    R1,@A_Parms              A(Parm list)
         BRAS  R14,Z00010               Clean up

*-------------------------------------------------------------------*
*    ... delete our 24-bit stack ...                                *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@_24Bit_Stack_Ptr A(Stack below-the-line)
         JZ    A90020                   None, skip
         SSCSTACK TERM,                 Free the stack area            +
               STACK=(1)                 this one

A90020   DS    0H
*-------------------------------------------------------------------*
*    ... save our max return code, and free up our local data ...   *
*-------------------------------------------------------------------*
         L     R4,@A_Max_RC             Save return code

         LA    R1,@A_Dynam              A(Local storage)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*    ... then the global data area ...                              *
*-------------------------------------------------------------------*
         LA    R1,@_Dynam               A(Global storage)
         L     R3,@_31Bit_Stack_Ptr     Rescue Stack pointer

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R3)                on this stack

*-------------------------------------------------------------------*
*    ... and finally, the stack itself.                             *
*-------------------------------------------------------------------*
         SSCSTACK TERM,                 Free the stack                 +
               STACK=(R3)                starting here

*-------------------------------------------------------------------*
*    Restore the callers registers, and exit.                       *
*-------------------------------------------------------------------*
         LR    R15,R4                   Restore return code
         PR    ,                        and return to caller

A_Literals      DS    0H

         LTORG

A_Literals_End  DS    0H

@A_Dynam                  DSECT         Dynamic storage for A00010
                          DS    18F      Save area
@A_Original_R1            DS    FL4      R1 on entry
@A_Max_RC                 DS    FL4      Highest return code
@A_Parms                  DS    0F       Parms for Called modules
@A_Parms_Std              DS    3AL4      Standard 3 parms
@A_Parms_Extra            EQU   *         More parms
@A_Parms_B00010           DS    AL4         for B00010
                          ORG   ,
                          DS    0D       Alignment
@A_Dynam_Length           EQU   *-@A_Dynam  Length

&PGMNAME CSECT

         DROP  ,
         TITLE 'B00010: Initialization'

         PUSH  USING

B00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : B00010                                                 *
*                                                                     *
*  Abstract  : Perform one-time initialization functions based on     *
*              environment.                                           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(Original R1 on program invocation)         *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Copied STLINENO or SYSPRINT/SYSIN *
*                                   I/O routines to 24-bit storage.   *
*              1998/11/13 SDDA030 - V2.2                              *
*                                 - Set up TSO environment (IKJTSOEV) *
*                                   in batch.                         *
*              1999/01/14 SDDA030 - V2.4                              *
*                                 - Rationalized ISPF/TSO cmd/CALL    *
*                                   checks                            *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*                                 - Removed copy of SYSIN/SYSPRINT    *
*                                   routines to 24-bit storage.       *
*              1999/07/30 SDDA030 - V2.7                              *
*                                 - Moved SYSIN initialization to     *
*                                   C00010                            *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Removed ISPF initialization.      *
*                                 - Created @_Hdr0-3.                 *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - OPENed SYSPRINT if batch          *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Added check for parms passed for  *
*                                   IKJEFTSR invocation.              *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Moved heading initialization to   *
*                                   C00010.                           *
*              2002/08/08 SDDA030 - V2.19                             *
*                                 - Checked IGC0007H (LSPACE) for     *
*                                   APAR OW48527                      *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*              ____/__/__ xxxxxxx - Vx.xx                             *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,B_Literals           Point to our literals
         USING (B_Literals,B_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get Stack area                 +
               LEN=@B_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@B_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @B_Dynam,R13             Assign a base

         L     R15,@B_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@B_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@B_24Bit_Stack_Ptr_Ptr Save it

*---------------------------------------------------------------------*
*    Clear our various flags, and save the original R1                *
*---------------------------------------------------------------------*
         NI    @_TSO_Command,X'FF'-L'@_TSO_Command Off TSO flag
         NI    @_Batch_Environ,X'FF'-L'@_Batch_Environ Off Batch flag
         L     R15,12(0,R1)             A(Original R1)
         L     R15,0(0,R15)             Get it
         ST    R15,@B_Original_R1       Save it

*---------------------------------------------------------------------*
*   Determine the environment under which we were invoked:            *
*     TSO Command: R1 --> CPPL                                        *
*     IKJEFTSR Reinvocation:                                          *
*        R1 ---> A(Parm1): HL2'4',A(Original @_Dynam)                 *
*                A(Parm2): HL2'?',CL?(Copy of start of @_Dynam)       *
*     Batch: Anything else                                            *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@B_Original_R1 Restore original R1
         JZ    B03000                   Nothing, not a TSO cmd
         L     R14,PSATNEW-PSA(0)       Yes, get A(our TCB)
         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)
         SLL   R14,8                    Clean
         SRL   R14,8                      it
         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)
         JZ    B03000                   None, not TSO
         C     R14,CPPLPSCB-CPPL(R1)    Are we passed a CPPL?
         JE    B02000                   Yes, go process

*---------------------------------------------------------------------*
*   We were passed a parm, but it is not the CPPL; check out the      *
*  parms to see if we are being re-invoked by IKJEFTSR:               *
*                                                                     *
*     R1 ---> ---> H'4',A(@_Dynam)                                    *
*             ---> H'16',1st 16 bytes of @_Dynam                      *
*---------------------------------------------------------------------*
         TM    0(R1),X'80'              Only 1 parm?
         JO    B03000                   Yes, not IKJEFTSR, assume batch
         TM    4(R1),X'80'              No, 2nd parm the last?
         JNO   B80010                   No, error

         L     R15,0(0,R1)              Get A(1st parm)
         LH    R14,0(0,R15)             Get its length
         CHI   R14,4                    Is it the right length?
         JNE   B80010                   No, not IKJEFTSR
         L     R0,2(0,R15)              Maybe, load A(Original @_Dynam)

         L     R14,4(0,R1)              Get A(2nd Parm)
         LH    R15,0(0,R14)             Get its length
         LA    R14,2(0,R14)             Point to it
         LR    R1,R15                   Length to check
         CLCL  R0,R14                   Is this really @_Dynam?
         JNE   B80010                   No, error

         OI    @_IKJEFTSR,L'@_IKJEFTSR  Yes, set our flag
         LA    R15,0                    Clear the return code
         J     B90010                   and exit

B02000   DS    0H
*---------------------------------------------------------------------*
*   TSO Command Initialization - save A(CPPL) ...                     *
*---------------------------------------------------------------------*
         OI    @_TSO_Command,L'@_TSO_Command    Set TSO flag

         L     R1,@B_Original_R1        Get original R1 - A(CPPL)
         ST    R1,@_CPPL_Ptr            Save A(CPPL)

*---------------------------------------------------------------------*
*   ... clear our flag ...                                            *
*---------------------------------------------------------------------*
         NI    @_TSO_Processed,X'FF'-L'@_TSO_Processed

*---------------------------------------------------------------------*
*   ... and go check the status of OW48527                            *
*---------------------------------------------------------------------*
         J     B04000                   go do it

B03000   DS    0H
*---------------------------------------------------------------------*
*   Batch Job Initialization - initialize page and line counts ...    *
*---------------------------------------------------------------------*
         OI    @_Batch_Environ,L'@_Batch_Environ Set Batch flag

         LA    R15,0                    Clear work register
         STH   R15,@_Page_Count         Clear page count

*---------------------------------------------------------------------*
*   ... and set up the TSO environment by invoking IKJTSOEV, saving   *
*  the address of the CPPL we get back.                               *
*---------------------------------------------------------------------*
         LA    R1,@B_Link_Parms         A(Parameter list)
         LA    R15,@B_Link_Parms+20     Point past them
         LHI   R14,4                    4 parameters

B03010   DS    0H
         ST    R15,0(0,R1)              Save Parm ptr
         AHI   R15,4                    Bump pointer
         AHI   R1,4                     Bump parm pointer
         BRCT  R14,B03010               and do it again
         LA    R15,@_Bat_CPPL_Ptr       A(Command Buffer pointer)
         ST    R15,@B_Link_Parms+16     Save it
         OI    @B_Link_Parms+16,X'80'   Flag as last

         MVC   @B_LINKX,B_LINKX         Move Link L-Form
         LARL  R2,B03020                Error return here
         LINKX EP=IKJTSOEV,             Establish TSO environment      +
               ERRET=(2),                go here if LINK error         +
               MF=(E,@B_Link_Parms),     using these parms             +
               SF=(E,@B_LINKX)           keep ourselves re-entrant
         ICM   R14,B'1111',@_Bat_CPPL_Ptr Get A(CPPL returned)
         JNZ   B04000                   OK, check OW48527

B03020   DS    0H
*---------------------------------------------------------------------*
*   If we didn't get a CPPL address back from IKJTSOEV, but we are    *
*  running in a TSO address space, build our own copy of a CPPL that  *
*  we can use to build the PPL                                        *
*---------------------------------------------------------------------*
         CHI   R15,24                   No, TSO env present?
         JH    B03810                   No, something else, error

         L     R14,PSATOLD-PSA(0)       Get A(our TCB)
         L     R14,TCBJSCB-TCB(R14)     Get A(Our JSCB)
         SLL   R14,8                    Clean
         SRL   R14,8                      it
         ICM   R14,B'1111',JSCBPSCB-IEZJSCB(R14) Get A(PSCB)
         JZ    B03810                   None, can't use TSO
         ST    R14,@_Bat_CPPL+CPPLPSCB-CPPL Save A(PSCB)

         L     R15,PSCBUPT-PSCB(R14)    A(UPT)
         ST    R15,@_Bat_CPPL+CPPLUPT-CPPL Save A(UPT)

         L     R14,PSAAOLD-PSA(0)       Get A(our ASCB)
         L     R14,ASCBASXB-ASCB(R14)   A(Our ASXB)
         L     R14,ASXBLWA-ASXB(R14)    A(LWA)
         L     R15,LWAPECT-LWA(R14)     A(ECT)
         ST    R15,@_Bat_CPPL+CPPLECT-CPPL Save A(ECT)
         LA    R15,@_Bat_CPPL           A(Our pseudo CPPL)
         ST    R15,@_Bat_CPPL_Ptr       Save it

         J     B04000                   Check status of OW48527

B03810   DS    0H
         LA    R15,4                    Error creating TSO environment
         J     B90010                   exit

B04000   DS    0H
*-------------------------------------------------------------------*
*    Everything is OK so far, so we want to check the status of     *
*   APAR OW48527, which added a time-out to the LSPACE SVC (we will *
*   do things differently if the APAR is installed). We check the   *
*   module IGC0007H (LSPACE) for the literal 'I/O TIMEOUT', part    *
*   of a new error message that came in with OW48527.               *
*-------------------------------------------------------------------*
         MVC   @B_CSVQUERY,B_CSVQUERY   Move L-Form
         CSVQUERY INEPNAME=B_IGC0007H,  EP Name                        +
               OUTLOADPT=@B_IGC0007H_Ptr,  return load point           +
               OUTLENGTH=@B_IGC0007H_Len,  and length                  +
               PLISTVER=MAX,               max parm list               +
               MF=(E,@B_CSVQUERY)          staying reentrant
         LTR   R15,R15                  How did we do?
         JZ    B04010C                  OK, skip
         CHI   R15,20                   Incompatible OS?
         JE    B80020                   Yes, skip
         J     B04910                   No, assume no OW48527
B04010C  DS    0H

         ICM   R14,B'1111',@B_IGC0007H_Len OK, get the length
         JZ    B04910                   Nothing, skip
         ICM   R15,B'1111',@B_IGC0007H_Ptr Get the address
         JZ    B04910                   None, exit

         LHI   R1,L'B_OW48527_Lit-1     EX length of literal
         SLR   R14,R1                   Adjust the length to check

B04020   DS    0H
         EX    R1,B_Check_OW48527       Check for literal
         JE    B04030                   Found it, skip
         AHI   R15,1                    Not it, bump pointer
         BRCT  R14,B04020               and check again
         J     B04910                   Not found, exit

B04030   DS    0H
         OI    @_OW48527,L'@_OW48527    Indicate OW48527 present

B04910   DS    0H
         LA    R15,0                    Clear return code
         J     B90010                   and exit

B80010   DS    0H
*-------------------------------------------------------------------*
*    Unknown Parm, exit with error                                  *
*-------------------------------------------------------------------*

         OI    @_Internal_Err,L'@_Internal_Err Set our flag
         LA    R15,8                    Set error return code
         J     B90010                   and exit

B80020   DS    0H
*-------------------------------------------------------------------*
*    Incompatible OS, set flag and return code                      *
*-------------------------------------------------------------------*
         OI    @_Incompatible_OS,L'@_Incompatible_OS Set our flag
         LA    R15,8                    and return code
         J     B90010                   and exit

B90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@B_Dynam              A(Local storage)
         L     R2,@B_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)

         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(2)                 on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

B_Literals            DS    0H

B_Check_OW48527 CLC  B_OW48527_Lit,0(R15)  Check for OW48527 literal

         PUSH  PRINT
         PRINT NOGEN

B_IGC0007H      DC    CL8'IGC0007H'   LSPACE SVC name
B_OW48527_Lit   DC    C'I/O TIMEOUT'  Literal indicating OW48527

B_LINKX  LINKX EP=IKJTSOEV,                                            +
               SF=L
B_LINKX_Length EQU *-B_LINKX

         CSVQUERY PLISTVER=MAX,                                        +
               MF=(L,B_CSVQUERY)
B_CSVQUERY_Length EQU *-B_CSVQUERY


         POP   PRINT


         LTORG
B_Literals_End            DS    0H

@B_Dynam                  DSECT         Dynamic area for B00000
                          DS    18F      O/S Style save area
@B_31Bit_Stack_Ptr_Ptr    DS    AL4      A(31-bit Stack Ptr)
@B_24Bit_Stack_Ptr_Ptr    DS    AL4      A(24-bit Stack Ptr)
@B_Original_R1            DS    AL4      Value of R1 at program entry
@B_Macros                 DS    0F       Macro area
@B_LINKX                  DS    CL(B_LINKX_Length)  L-Form of LINKX
@B_Link_Parms             DS    5AL4     Parms for Link
                          DS    4AL4     Dummy parms
                          ORG   @B_Macros
@B_CSVQUERY               DS    CL(B_CSVQUERY_Length) L-Form CSVQUERY
@B_IGC0007H_Ptr           DS    AL4      A(IGC0007H)
@B_IGC0007H_Len           DS    AL4      Length of IGC0007H
                          ORG   ,
                          DS    0D       Alignment
@B_Dynam_Length           EQU   *-@B_Dynam  Length of storage required

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'C00010: Get Input Data'

         PUSH  USING

C00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : C00010                                                 *
*                                                                     *
*  Abstract  : Get selection criteria for extracting UCB info         *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - EOF, 'END' etc.                               *
*                                                                     *
*  Operation : For a batch job,                                       *
*               Read SYSIN                                            *
*               Build a pseudo command buffer                         *
*              Parse command buffer                                   *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Calculated default number of      *
*                                   subtasks as the number of CPUs    *
*                                   plus 1.                           *
*                                 - Added U, UCB as aliaii for UNIT   *
*                                   and V as an alias for VOL in      *
*                                   Batch processing.                 *
*                                 - Added STATS and MAXTASK keyword   *
*                                   support.                          *
*              1998/11/13 SDDA030 - V2.2                              *
*                                 - Used IKJPARS to parse batch ctl   *
*                                   cards.                            *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*                                 - Get SYSIN DCB storage and OPEN as *
*                                   required.                         *
*                                 - CLOSE and free SYSIN DCB at EOF.  *
*              1999/07/30 SDDA030 - V2.7                              *
*                                 - Use 24-bit EOD routine when 31-bit*
*                                   SAM not supported for SYSIN.      *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Removed ISPF stuff.               *
*                                 - Set @_Line_Count to generate Hdr0 *
*                                   only before echo of cmd line.     *
*                                 - Display keyword descriptions in   *
*                                   batch when invalid input found.   *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - PARSE keywords OUTFILE, OUTDATA.  *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Added ISPF subfields S, E, and B. *
*                                 - Allowed 'SPACE' as the 1st word   *
*                                   in batch control cards.           *
*                                 - Moved heading initialization from *
*                                   B00010.                           *
*                                 - Added SORT Subfields for VIX,     *
*                                   FRAG, STORGRP, CHPIDS.            *
*              2001/11/12 SDDA030 - V2.15                             *
*                                   Added lists of UCBs, Volsers.     *
*                                   Added XUCB, XVOL.                 *
*              2002/03/11 SDDA030 - V2.17                             *
*                                   Added STORGRP as a selection      *
*                                   criterion.                        *
*              2003/10/07 SDDA030 - V2.21                             *
*                                   Used ASASYMBM to resolve symbols  *
*                                   within VOL and XVOL.              *
*                                   Stripped leading spaces from SYSIN*
*                                   before checking for command name. *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Calculated default number of      *
*                                   subtasks as 2 * number of CPUs    *
*                                   plus 1.                           *
*                                   Used standardised calling sequence*
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,C_Literals           Point to our literals
         USING (C_Literals,C_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get Stack area                 +
               LEN=@C_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@C_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @C_Dynam,R13             Assign a base
         L     R15,@C_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@C_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@C_24Bit_Stack_Ptr_Ptr Save it

*---------------------------------------------------------------------*
*   Free any selection lists we may have ...                          *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)
         JZ    C00020                   None, skip
         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,C00010_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00010_End DS  0H
         DROP  R2
         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)

C00020   DS    0H
         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)
         JZ    C00030                   None, skip
         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,C00020_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00020_End DS  0H
         DROP  R2
         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)

C00030   DS    0H
         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)
         JZ    C00040                   None, skip
         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,C00030_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00030_End DS  0H
         DROP  R2
         XC    @_Vol_List_Ptr,@_Vol_List_Ptr Clear A(Vol List)

C00040   DS    0H
         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)
         JZ    C00050                   None, skip
         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,C00040_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00040_End DS  0H
         DROP  R2
         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)

C00050   DS    0H
         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)
         JZ    C00060                   None, skip
         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,C00050_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00050_End DS  0H
         DROP  R2
         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)

C00060   DS    0H
*---------------------------------------------------------------------*
*   ... and set all our selection criteria so that all volumes will   *
*  be selected.                                                       *
*---------------------------------------------------------------------*
         MVI   @_UNITNM,C' '            Assume all
         MVC   @_UNITNM+1(L'@_UNITNM-1),@_UNITNM Unitnames
         NI    @_ATTRPvt,X'FF'-L'@_ATTRPvt Off Mnt Attr flag
         NI    @_ATTRPub,X'FF'-L'@_ATTRPub Off Mnt Attr flag
         NI    @_ATTRStg,X'FF'-L'@_ATTRStg Off Mnt Attr flag
         NI    @_ATTRSMS,X'FF'-L'@_ATTRSMS Off Mnt Attr flag

*---------------------------------------------------------------------*
*   Set all our output-related flags to their default (off) state     *
*---------------------------------------------------------------------*
         NI    @_No_Headings,X'FF'-L'@_No_Headings Off flag
         NI    @_No_Details,X'FF'-L'@_No_Details   Off flag
         NI    @_No_Totals,X'FF'-L'@_No_Totals     Off flag
         NI    @_Statistics,X'FF'-L'@_Statistics   Off flag
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Off flag
         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     Off flag
         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     Off flag
         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit Off flag
         NI    @_No_LSPACE,X'FF'-L'@_No_LSPACE     Off flag

*---------------------------------------------------------------------*
*   Set MaxTasks to default                                           *
*---------------------------------------------------------------------*
         AIF   (&Default_SubTask_Count LT 1).Def_SubTask_Count_010
         LHI   R15,&Default_SubTask_Count Default nbr subtasks
         AGO   .Def_SubTask_Count_020
.Def_SubTask_Count_010 ANOP
         SLR   R15,R15                   Use dynamic subtask count
.Def_SubTask_Count_020 ANOP
         STH   R15,@_MaxTasks            Set it

*---------------------------------------------------------------------*
*   Clear out Sort field name, and default to Ascending sort          *
*---------------------------------------------------------------------*
         MVC   @_Sort_Field,=CL8' '
         MVI   @_Sort_Direction,C'A'

*---------------------------------------------------------------------*
*   Reset our internal flags                                          *
*---------------------------------------------------------------------*
         NI    @C_UNIT_Flag,X'FF'-L'@C_UNIT_Flag
         NI    @C_XUNIT_Flag,X'FF'-L'@C_XUNIT_Flag
         NI    @C_VOL_Flag,X'FF'-L'@C_VOL_Flag
         NI    @C_XVOL_Flag,X'FF'-L'@C_XVOL_Flag

*---------------------------------------------------------------------*
*   Reset OUTFILE and OUTDATA fields                                  *
*---------------------------------------------------------------------*
         MVC   @_OutFile_DDName,=CL8' '
         NI    @_OutData_DISPLAY,X'FF'-L'@_OutData_DISPLAY
         NI    @_OutData_CB,X'FF'-L'@_OutData_CB
         NI    @_OutData_ALL,X'FF'-L'@_OutData_ALL

*-------------------------------------------------------------------*
*    Initialize @_MaxLWait to the maximum number of seconds to      *
*   wait for each LSPACE; we determine whether or not we are a      *
*   foreground user (TSO) to decide on the initialization value.    *
*-------------------------------------------------------------------*
         L     R15,PSAAOLD-PSA          A(Our ASCB)
         ICM   R0,B'1111',ASCBTSB-ASCB(R15) Get A(TSB)
         JZ    C00060C                  Not a foreground user, skip
         LHI   R15,&Fore_LSPACE_Wait    Foreground WAIT time
         J     C00060E                  and skip
C00060C  DS    0H
         LHI   R15,&Back_LSPACE_Wait    Background WAIT time
         J     C00060E                  and skip
C00060E  DS    0H
         STH   R15,@_MaxLWait           Update MaxLWait

*---------------------------------------------------------------------*
*   Free the VolTbl, if it exists                                     *
*---------------------------------------------------------------------*
         NI    @_VolTbl_GETMAIN_Err,X'FF'-L'@_VolTbl_GETMAIN_Err

         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)
         JZ    C00070                  None, skip
         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length
         BASR  R2,0
         USING (*,C00060_End-1),R2
         STORAGE RELEASE,               Free the table                 +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
C00060_End DS  0H
         DROP  R2
         LA    R15,0                    Clear work register
         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer

C00070   DS    0H
*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@C_Parms_Std         Save it
         L     R15,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@C_Parms_Std+4       Save it
         L     R15,@C_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@C_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*      Check what kind of processing we have to do                    *
*---------------------------------------------------------------------*
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JNO   C00080                   No, skip
         TM    @_TSO_Processed,L'@_TSO_Processed Yes, already done?
         JO    C00780                   Yes, EOF
         OI    @_TSO_Processed,L'@_TSO_Processed No, end next time
         L     R1,@_CPPL_Ptr            Get A(CPPL)
         J     C00160                   and skip

C00080   DS    0H
*---------------------------------------------------------------------*
*   This is batch - go read a record from SYSIN, and build a          *
*   pseudo command buffer that we can pass to IKJPARS                 *
*---------------------------------------------------------------------*
         LHI   R15,4095                 Key count to produce
         STH   R15,@_Line_Count          Hdg0

         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)
         JNZ   C00100                   Already here, skip

*---------------------------------------------------------------------*
*   SYSIN has not been OPENed - get some storage, and OPEN it         *
*---------------------------------------------------------------------*
         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD
         SRL   R0,3                     DBLWD
         SLL   R0,3                      multiple

         BASR  R2,0
         USING (*,C00080_End-1),R2
         STORAGE OBTAIN,                Get some storage               +
               LENGTH=(0),               this long                     +
               LOC=24                    below the line
C00080_End DS  0H
         DROP  R2

         SLL   R1,8                     Clean the
         SRL   R1,8                      address
         ST    R1,@_SYSIN_DCB_Ptr       Save A(SYSIN DCB)

         L     R3,@_SYSIN_DCB_Ptr       A(DCB)
         MVC   0(C_SYSIN_DCB_Length,R3),C_SYSIN_DCB
         MVC   @_SYSIN_DCBE,C_SYSIN_DCBE Move SYSIN DCBE
         LA    R15,@_SYSIN_DCBE       Point to it
         ST    R15,DCBDCBE-IHADCB(R3) Update address in DCB
         MVC   @C_OPEN,C_OPEN           Move OPEN parms
         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN)

         TM    @_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?
         JO    C00090                 Yes, skip

*---------------------------------------------------------------------*
*   31-bit SAM is not supported for SYSIN. This typically happens     *
*  when it is allocated to the terminal in a TSO session (the I/O     *
*  seems to be OK, but the EOD handling gets in trouble). So ...      *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
*  ... close the current DCB ...                                      *
*---------------------------------------------------------------------*
         MVC   @C_CLOSE,C_CLOSE       Move close parms
         L     R3,@_SYSIN_DCB_Ptr     Point to the DCB
         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it

*---------------------------------------------------------------------*
*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *
*---------------------------------------------------------------------*
         MVC   0(C_SYSIN24_DCB_Length,R3),C_SYSIN24_DCB Move 24-bit DCB

*---------------------------------------------------------------------*
*  ... move the 24-bit EOD after it ...                               *
*---------------------------------------------------------------------*
         LA    R15,C_SYSIN24_DCB_Length(0,R3) Point past DCB
         LARL  R14,C00760_24_Start        A(24-bit EOD Routine)
         MVC   0(C00760_24_Length,R15),0(R14) Move 24-bit EOD

*---------------------------------------------------------------------*
*  ... and update DCBEODAD to point to the 24-bit EOD routine.        *
*---------------------------------------------------------------------*
         O     R15,DCBEODAD-IHADCB(R3)    Set up
         ST    R15,DCBEODAD-IHADCB(R3)     EODAD

*---------------------------------------------------------------------*
*  Finally, re-OPEN SYSIN.                                            *
*---------------------------------------------------------------------*
         MVC   @C_OPEN,C_OPEN           Move OPEN parms
         L     R3,@_SYSIN_DCB_Ptr       POINT TO THE DCB
         OPEN  ((3),INPUT),MODE=31,MF=(E,@C_OPEN) AND OPEN IT

C00090   DS    0H
         L     R1,@_SYSIN_DCB_Ptr       Restore A(DCB)

C00100   DS    0H
*---------------------------------------------------------------------*
*  Read SYSIN, if we can ...                                          *
*---------------------------------------------------------------------*
         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?
         JNO   C00760                   No, EOF

         GET   (1)                      Go get it

         ST    R1,@C_SYSIN_Rec_Ptr      and save record address

*---------------------------------------------------------------------*
*  ... ignoring comments and blank lines ...                          *
*---------------------------------------------------------------------*
         L     R15,@C_SYSIN_Rec_Ptr     A(SYSIN record)
         CLI   0(R15),C'*'              Comment?
         JE    C00080                   Yes, ignore it
         CLI   0(R15),C' '              No, blank record?
         JNE   C00110
         CLC   1(71,R15),0(R15)
         JE    C00080                   Blank record, ignore it

C00110   DS    0H
*---------------------------------------------------------------------*
*  ... and trim leading and trailing spaces.                          *
*---------------------------------------------------------------------*
         AHI   R15,71                   A(Last char)
C00120   DS    0H
         CLI   0(R15),C' '              Trailing blank?
         JNE   C00130                   No, skip
         BRCT  R15,C00120               Yes, check previous

C00130   DS    0H
         L     R14,@C_SYSIN_Rec_Ptr     A(Start of input)
         SLR   R15,R14                  Length of record - 1
         AHI   R15,1                    Actual length

C00130C  DS    0H
         CLI   0(R14),C' '              Leading space?
         JNE   C00130E                  No, OK
         AHI   R14,1                    Yup, point past it
         BRCT  R15,C00130C              and check again
         J     C00080                   Blank record(?), ignore it

C00130E  DS    0H
*---------------------------------------------------------------------*
*   If the control card starts with our name (the name that a TSO     *
*  user would use), skip over it.                                     *
*---------------------------------------------------------------------*
         LHI   R0,L'C_PgmName           Length of our name
         CR    R15,R0                   Should we check for our name?
         JL    C00150                   No, skip
         CLC   C_PgmName,0(R14)         Yes, our name first?
         JNE   C00150                   No, OK
         CR    R15,R0                   Is that all there is?
         JE    C00140                   Yes, skip
         CLI   L'C_PgmName(R14),C' '    Yes, ending with a space?
         JNE   C00150                   No, skip
         LHI   R0,L'C_PgmName+1         Length of our name and a space
C00140   DS    0H
         AR    R14,R0                   Point past our name
         SR    R15,R0                   and adjust length
C00150   DS    0H
         LA    R0,@C_CBUF_Data+L'C_PgmName+1 A(Target area)
         LR    R1,R15                   Length
         MVCL  R0,R14                   Move data to cmd buffer
         LA    R15,@C_CBUF              A(Start of command buffer
         SR    R0,R15                   Get the length
         STH   R0,@C_CBUF_Len           Save it

         MVC   @C_CBUF_Data(L'C_PgmName),C_PgmName  Simulate command
         MVI   @C_CBUF_Data+L'C_PgmName,C' ' Separator
         LHI   R15,L'C_PgmName+1         Offset to parms
         STH   R15,@C_CBUF_Off          Update it

         L     R1,@_Bat_CPPL_Ptr        A(Our CPPL)
         LA    R15,@C_CBUF              A(our command buffer)
         ST    R15,CPPLCBUF-CPPL(R1)    Update A(Command buffer)

C00160   DS    0H
*---------------------------------------------------------------------*
*   Resolve any symbolic variables in the command buffer. Note that   *
*   we do this before invoking IKJPARS because IKJPARS will get upset *
*   with substring'ed symbolic variables (which it thinks are lists). *
*---------------------------------------------------------------------*
         L     R15,CPPLCBUF-CPPL(R1)    A(Command Buffer)
         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get length
         AR    R14,R15                  Point past end
         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start of cmd
         LA    R0,C'&&'                 Char to search for
C00160E  DS    0H
         SRST  R14,R15                  Do we have an amper?
         JH    C00160Z                  No amper, skip
         JO    C00160E                  Keep checking

         ST    R1,@C_CPPL_Ptr           Save A(CPPL)

         XC    @C_SYMBP,@C_SYMBP        Clear ASASUMBP area
         L     R15,CPPLCBUF-CPPL(R1)    A(Command buffer)
         LH    R14,@C_CBUF_Len-@C_CBUF(R15) Get Cmd buff length
         AHI   R14,-L'@C_CBUF_Len-L'@C_CBUF_Off minus CBUF fields
         ST    R14,@C_SYMBP+SYMBPPATTERNLENGTH-SYMBP Save length
         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Point to start
         ST    R15,@C_SYMBP+SYMBPPATTERN@-SYMBP Save A(Command Buff)
         LA    R15,@C_CBUF1_Data        A(Target Area)
         ST    R15,@C_SYMBP+SYMBPTARGET@-SYMBP Save A(Target)
         LA    R15,L'@C_CBUF1_Data      Target Length)
         ST    R15,@C_SYMBP_Target_Len  Initialize it
         LA    R15,@C_SYMBP_Target_Len  A(Target Len field)
         ST    R15,@C_SYMBP+SYMBPTARGETLENGTH@-SYMBP Save A(Length)
         LA    R15,@C_SYMBP_RC          A(Return code area)
         ST    R15,@C_SYMBP+SYMBPRETURNCODE@-SYMBP Save A(Return code)

         MVC   @C_LINKX,C_LINKX         Move LINKX Macro
         LARL  R2,C00160Z               LINK error return address
         LINKX EP=ASASYMBM,             LINK to ASASYMBM               +
               ERRET=(2),                go here if LINK error         +
               MF=(E,@C_SYMBP),          using these parms             +
               SF=(E,@C_LINKX)           staying re-entrant

         L     R1,@C_CPPL_Ptr           Restore A(CPPL)
         ICM   R15,B'1111',@C_SYMBP_RC  Get return code
         JNZ   C00160Z                  Use original Cmd Buffer
         L     R15,@C_SYMBP_Target_Len  Get new length
         AHI   R15,L'@C_CBUF_Len+L'@C_CBUF_Off Adjust it
         STH   R15,@C_CBUF1_Len         Update new cmd buff len
         L     R15,CPPLCBUF-CPPL(R1)    A(original CBUF)
         LH    R15,@C_CBUF_Off-@C_CBUF(R15) Original offset
         STH   R15,@C_CBUF1_Off         Update it
         LA    R15,@C_CBUF1             Point to our new CBUF
         ST    R15,CPPLCBUF-CPPL(R1)    and update CPPL

C00160Z  DS    0H
*---------------------------------------------------------------------*
*   Invoke IKJPARS to parse our Command Buffer (either the real one   *
*   or the one we built). Note that if we not running as a TSO        *
*   command, we turn off prompting during IKJPARS (otherwise, a user  *
*   at a TSO terminal who CALLed us could get prompted for unknown    *
*   parms, which is inconsistent).                                    *
*---------------------------------------------------------------------*
         MVC   @C_PPL+PPLUPT-PPL(L'PPLUPT),CPPLUPT-CPPL(R1)
         MVC   @C_PPL+PPLECT-PPL(L'PPLECT),CPPLECT-CPPL(R1)
         LA    R15,@C_PECB              A(Parse ECB)
         ST    R15,@C_PPL+PPLECB-PPL    Save it
         LA    R15,@C_PANS              A(Parse Answer area)
         ST    R15,@C_PPL+PPLANS-PPL    Save it
         MVC   @C_PPL+PPLCBUF-PPL(L'PPLCBUF),CPPLCBUF-CPPL(R1)
         L     R15,=AL4(C_PCL)          A(Parse Control List)
         ST    R15,@C_PPL+PPLPCL-PPL    Save it
         LA    R15,0                    Clear work register
         ST    R15,@C_PPL+PPLUWA-PPL    No User Work Area
         ST    R15,@C_PECB              Clear ECB
         ST    R15,@C_PANS               and Answer area

         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JO    C00170                   Yes, skip
         L     R15,@C_PPL+PPLUPT-PPL    Get A(UPT)
         MVC   @C_UPTSWS,UPTSWS-UPT(R15) Save current SWS
         NI    UPTSWS-UPT(R15),X'FF'-UPTNPRM Off Prompt flag

C00170   DS    0H
         LA    R1,@C_PPL                A(PPL)
         CALLTSSR EP=IKJPARS            Parse the command line

         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JO    C00180                   Yes, skip
         L     R14,@C_PPL+PPLUPT-PPL    Get A(UPT)
         OC    UPTSWS-UPT(L'UPTSWS,R14),@C_UPTSWS Restore UPTSWS
C00180   DS    0H
         LTR   R15,R15                  Did PARSE work?
         JNZ   C00730                   No, skip
         L     R1,@C_PANS               Yes, get A(PDL)

*---------------------------------------------------------------------*
*   Process UNIT/XUNIT keyword                                        *
*---------------------------------------------------------------------*
         TM    @C_UNIT_Flag,L'@C_UNIT_Flag Have we processed UNIT?
         JO    C00180E                  Yes, skip
         OI    @C_UNIT_Flag,L'@C_UNIT_Flag No, we have now

         TM    C_01SFP+6-IKJPARMD(R1),X'80' Was UNIT entered?
         JZ    C00180E                  No, skip
         AHI   R1,C_01SFP-IKJPARMD      Yes, point to PDE
         J     C00180I                  start processing
C00180E  DS    0H
         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Have we processed XUNIT?
         JO    C00240                   Yes, skip
         OI    @C_XUNIT_Flag,L'@C_XUNIT_Flag No, we have now

         TM    C_02SFP+6-IKJPARMD(R1),X'80' Was XUNIT entered?
         JZ    C00240                   No, skip
         AHI   R1,C_02SFP-IKJPARMD      Yes, point to PDE
C00180I  DS    0H
         LA    R0,0                     Clear unit count
C00190   DS    0H
         AHI   R0,1                     Bump unit count
         ICM   R1,B'0111',9(R1)         A(Next PDE)
         JNZ   C00190                   Found one, keep checking

         LR    R4,R0                    Save count
         MHI   R0,UCB_List_Ent_Length   Times len of 1 entry
         AHI   R0,UCB_List_Hdr_Length     + length of header
         BASR  R2,0
         USING (*,C00190_End-1),R2
         STORAGE OBTAIN,                Go get some storage            +
               LENGTH=(0),               this long,                    +
               LOC=31                    above-the-line
C00190_End DS  0H
         DROP  R2
         ST    R0,UCB_List_Hdr_Len-UCB_List(R1) Save Subpool, length
         ST    R4,UCB_List_Hdr_Count-UCB_List(R1) Save nbr entries
         LA    R4,UCB_List_Ent-UCB_List(R1) A(1st entry)
         TM    @C_XUNIT_Flag,L'@C_XUNIT_Flag Is this XUNIT?
         JO    C00190E                  Yes, skip
         ST    R1,@_UCB_List_Ptr        Save it
         L     R1,@C_PANS               Restore A(PDL)
         LA    R3,C_01SFP-IKJPARMD(R1)  Point to 1st UNIT PDE
         J     C00200                   and skip
C00190E  DS    0H
         ST    R1,@_XUCB_List_Ptr       Save it
         L     R1,@C_PANS               Restore A(PDL)
         LA    R3,C_02SFP-IKJPARMD(R1) Point to 1st XUNIT PDE
         J     C00200                   and skip
C00200   DS    0H
         MVC   UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),=(L+
               'UCB_List_Ent_UCB)C'*'   Initialize field
         L     R15,0(0,R3)              A(UNIT field)
         LH    R14,4(0,R3)              Get its length
         STC   R14,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Save it
         AHI   R4,UCB_List_Ent_UCB-UCB_List_Ent  Point to UCB Area
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX1                Move UCB
         AHI   R4,-(UCB_List_Ent_UCB-UCB_List_Ent) Back to entry
         MVC   UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),U+
               CB_List_Ent_UCB-UCB_List_Ent(R4)
         TR    UCB_List_Ent_UCB-UCB_List_Ent(L'UCB_List_Ent_UCB,R4),C_T+
               rTbl                     Xlate (Wildcards = X'FF'
         TR    UCB_List_Ent_Mask-UCB_List_Ent(L'UCB_List_Ent_Mask,R4),C+
               _TrTbl1                  Xlate (Wildcards = X'FF')
*                                              Non-Wildcards = X'00')
         AHI   R4,UCB_List_Ent_Length   A(Next entry)
         ICM   R3,B'0111',9(R3)         A(Next PDE)
         JNZ   C00200                   Got one, save it
         J     C00180E                  Process next UNIT-type keywd

C00240   DS    0H
*---------------------------------------------------------------------*
*   Process VOLUME/XVOLUME keyword                                    *
*---------------------------------------------------------------------*
         TM    @C_VOL_Flag,L'@C_VOL_Flag Have we processed VOL?
         JO    C00240E                  Yes, skip
         OI    @C_VOL_Flag,L'@C_Vol_Flag No, we have now

         TM    C_03SFP+6-IKJPARMD(R1),X'80' Was VOL entered?
         JZ    C00240E                  No, skip
         AHI   R1,C_03SFP-IKJPARMD      Yes, point to PDE
         J     C00240I                  start processing
C00240E  DS    0H
         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Have we processed XVOL?
         JO    C00300                   Yes, skip
         OI    @C_XVOL_Flag,L'@C_XVol_Flag No, we have now

         TM    C_04SFP+6-IKJPARMD(R1),X'80' Was XVOL entered?
         JZ    C00300                   No, skip
         AHI   R1,C_04SFP-IKJPARMD      Yes, point to PDE
C00240I  DS    0H
         LA    R0,0                     Clear unit count
C00250   DS    0H
         AHI   R0,1                     Bump vol count
         ICM   R1,B'0111',9(R1)         A(Next PDE)
         JNZ   C00250                   Found one, keep checking

         LR    R4,R0                    Save count
         MHI   R0,Vol_List_Ent_Length   Times length of 1 entry
         AHI   R0,Vol_List_Hdr_Length     + length of header
         BASR  R2,0
         USING (*,C00250_End-1),R2
         STORAGE OBTAIN,                Go get some storage            +
               LENGTH=(0),               this long,                    +
               LOC=31                    above-the-line
C00250_End DS  0H
         DROP  R2
         ST    R0,Vol_List_Hdr_Len-Vol_List(R1) Save Subpool, length
         ST    R4,Vol_List_Hdr_Count-Vol_List(R1) Save nbr entries
         LA    R4,Vol_List_Ent-Vol_List(R1) A(1st entry)
         TM    @C_XVOL_Flag,L'@C_XVOL_Flag Are we doing XVOL?
         JO    C00250E                  Yes, skip
         ST    R1,@_VOL_List_Ptr        Save it
         L     R1,@C_PANS               Restore A(PDL)
         LA    R3,C_03SFP-IKJPARMD(R1)  Point to 1st VOL PDE
         J     C00260                   and skip
C00250E  DS    0H
         ST    R1,@_XVOL_List_Ptr       Save it
         L     R1,@C_PANS               Restore A(PDL)
         LA    R3,C_04SFP-IKJPARMD(R1)  Point to 1st XVOL PDE
         J     C00260                   and skip
C00260   DS    0H
         MVC   Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),=(L+
               'Vol_List_Ent_Vol)C'*'   Initialize field
         L     R15,0(0,R3)              A(Vol field)
         LH    R14,4(0,R3)              Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX1                Move Vol
         MVC   Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),V+
               ol_List_Ent_Vol-Vol_List_Ent(R4)
         TR    Vol_List_Ent_Vol-Vol_List_Ent(L'Vol_List_Ent_Vol,R4),C_T+
               rTbl                     Xlate (Wildcards = X'FF'
         TR    Vol_List_Ent_Mask-Vol_List_Ent(L'Vol_List_Ent_Mask,R4),C+
               _TrTbl1                  Xlate (Wildcards = X'FF')
*                                              Non-Wildcards = X'00')
         AHI   R4,Vol_List_Ent_Length   A(Next entry)
         ICM   R3,B'0111',9(R3)         A(Next PDE)
         JNZ   C00260                   Got one, save it
         J     C00240                   Process next VOL-type keyword

C00300   DS    0H
*---------------------------------------------------------------------*
*   Process NAME keyword                                              *
*---------------------------------------------------------------------*
         TM    C_05SFP+6-IKJPARMD(R1),X'80' Was Name entered?
         JZ    C00310                   No, skip
         L     R15,C_05SFP-IKJPARMD(R1)  Yes, point to it
         LH    R14,C_05SFP+4-IKJPARMD(R1) Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX3                Move Unitname

C00310   DS    0H
*---------------------------------------------------------------------*
*   Process ATTRIBUTE keyword                                         *
*---------------------------------------------------------------------*
         LH    R15,C_06SFP-IKJPARMD(R1) Get Kwd nbr for ATTR
         LTR   R15,R15                  Anything?
         JZ    C00380                   None, skip
         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)
         AH    R14,C_06SF-C_PCL(R14)    A(IKJSUBF entry)
         AH    R14,2(0,R14)             A(1st IKJNAME entry)
C00320   DS    0H
         TM    0(R14),X'60'             Is this an IKJNAME PCE?
         JNO   C00380                   No, must have reached the end
         CHI   R15,1                    Is this our entry?
         JE    C00330                   Yes, check it out
         AH    R14,2(0,R14)             No, bump to next PCE
         BRCT  R15,C00320               and check it out
         J     C00380                   Unknown, ignore it
C00330   DS    0H
         CLC   =C'STORAGE',5(R14)       STG?
         JE    C00340                   Yes, skip
         CLC   =C'PRIVATE',5(R14)       No, PRIVATE?
         JE    C00350                   Yes, skip
         CLC   =C'PUBLIC',5(R14)        No, PUBLIC?
         JE    C00360                   Yes, skip
         CLC   =C'SMS',5(R14)           No, SMS?
         JE    C00370                   Yes, skip
         J     C00380                   Unknown, ignore it
C00340   DS    0H
         OI    @_ATTRStg,L'@_ATTRStg    Set flag
         J     C00380
C00350   DS    0H
         OI    @_ATTRPvt,L'@_ATTRPvt    Set flag
         J     C00380
C00360   DS    0H
         OI    @_ATTRPub,L'@_ATTRPub    Set flag
         J     C00380
C00370   DS    0H
         OI    @_ATTRSMS,L'@_ATTRSMS    Set flag
         J     C00380

C00380   DS    0H
*---------------------------------------------------------------------*
*   Process STORGRP keyword                                           *
*---------------------------------------------------------------------*
         TM    C_07SFP+6-IKJPARMD(R1),X'80' Was STORGRP entered?
         JZ    C00430                   No, skip
         LA    R0,0                     Yes, clear STORGRP count
         AHI   R1,C_07SFP-IKJPARMD      and point to PDE
C00390   DS    0H
         AHI   R0,1                     Bump STORGRP count
         ICM   R1,B'0111',9(R1)         A(Next PDE)
         JNZ   C00390                   Found one, keep checking

         LR    R4,R0                    Save count
         MHI   R0,STORGRP_List_Ent_Length Times length of 1 entry
         AHI   R0,STORGRP_List_Hdr_Length  + length of header
         BASR  R2,0
         USING (*,C00390_End-1),R2
         STORAGE OBTAIN,                Go get some storage            +
               LENGTH=(0),               this long,                    +
               LOC=31                    above-the-line
C00390_End DS  0H
         DROP  R2
         ST    R1,@_STORGRP_List_Ptr    Save it
         ST    R0,STORGRP_List_Hdr_Len-STORGRP_List(R1) Save Subp, len
         ST    R4,STORGRP_List_Hdr_Count-STORGRP_List(R1) Save nbr ents
         LA    R4,STORGRP_List_Ent-STORGRP_List(R1) A(1st entry)
         L     R1,@C_PANS               Restore A(PDL)
         LA    R3,C_07SFP-IKJPARMD(R1) and point to 1st STORGRP PDE
C00400   DS    0H
         L     R15,0(0,R3)              A(StorGrp)
         AH    R15,4(0,R3)              A(Byte past end)
         AHI   R15,-1                   Point to last byte
         CLI   0(R15),C'*'              Trailing asterisk?
         JNE   C00410                   No, skip
         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),C'*'
         J     C00420
C00410   DS    0H
         MVI   STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4),X'00'
         J     C00420
C00420   DS    0H
         MVC   STORGRP_List_Ent_STORGRP+1-STORGRP_List_Ent(L'STORGRP_Li+
               st_Ent_STORGRP-1,R4),STORGRP_List_Ent_STORGRP-STORGRP_Li+
               st_Ent(R4)
         L     R15,0(0,R3)              A(StorGrp)
         LH    R14,4(0,R3)              Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX1                Move StorGrp
         MVC   STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+
               t_Mask,R4),STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(R4)
         TR    STORGRP_List_Ent_STORGRP-STORGRP_List_Ent(L'STORGRP_List+
               _Ent_STORGRP,R4),C_TrTbl Xlate Wildcards = X'FF'
         TR    STORGRP_List_Ent_Mask-STORGRP_List_Ent(L'STORGRP_List_En+
               t_Mask,R4),C_TrTbl1      Xlate (Wildcards = X'FF'
*                                              Non-Wildcards = X'00')
         AHI   R4,STORGRP_List_Ent_Length A(Next entry)
         ICM   R3,B'0111',9(R3)         A(Next PDE)
         JNZ   C00400                   Got one, save it

C00430   DS    0H
*---------------------------------------------------------------------*
*   Process SORT keyword                                              *
*---------------------------------------------------------------------*
         LH    R15,C_09SFP-IKJPARMD(R1) Get Kwd nbr for Sort Field
         LTR   R15,R15                  Anything?
         JZ    C00480                   None, skip
         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)
         AH    R14,C_09SF-C_PCL(R14)    A(IKJSUBF entry)
         AH    R14,2(0,R14)             A(1st IKJNAME entry)
C00440   DS    0H
         TM    0(R14),X'60'             Is this an IKJNAME PCE?
         JNO   C00480                   No, must have reached the end
         CHI   R15,1                    Is this our entry?
         JE    C00450                   Yes, check it out
         AH    R14,2(0,R14)             No, bump to next PCE
         BRCT  R15,C00440               and check it out
         J     C00480                   Unknown, ignore it
C00450   DS    0H
         IC    R15,4(0,R14)             Get EX length of Keyword
         EX    R15,C_Save_Sort_Field    Save sort field name

*---------------------------------------------------------------------*
*   Process DESCENDING keyword                                        *
*---------------------------------------------------------------------*
         CLI   C_10K+1-IKJPARMD(R1),2 DESCENDING entered?
         JNE   C00480                   No, skip
         MVI   @_Sort_Direction,C'D'    Yes, say so

C00480   DS    0H
*---------------------------------------------------------------------*
*   Process MAXTASKS keyword                                          *
*---------------------------------------------------------------------*
         TM    C_11SFP+6-IKJPARMD(R1),X'80' Was Maxtasks entered?
         JZ    C00490                   No, skip
         L     R15,C_11SFP-IKJPARMD(R1) Yes, point to it
         L     R15,0(0,R15)             Get the value
         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_010
         CHI   R15,&Max_SubTask_Count   Is it > max?
         JNH   C00480C                  No, OK
         LHI   R15,&Max_SubTask_Count   Yes, use max
C00480C  DS    0H
.Max_SubTask_Count_010 ANOP
         LTR   R15,R15                  Is it too small?
         JNP   C00490                   Yes, ignore it
         STH   R15,@_MaxTasks           Save it

C00490   DS    0H
*---------------------------------------------------------------------*
*   Process OUTFILE keyword                                           *
*---------------------------------------------------------------------*
         TM    C_20SFP+6-IKJPARMD(R1),X'80' Was OUTFILE entered?
         JZ    C00550                   No, skip
         L     R15,C_20SFP-IKJPARMD(R1) Yes, point to it
         LH    R14,C_20SFP+4-IKJPARMD(R1) Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX4                Move DDName

*---------------------------------------------------------------------*
*   Process OUTDATA keyword                                           *
*---------------------------------------------------------------------*
         LH    R15,C_21SFP-IKJPARMD(R1) Get Kwd nbr for OUTDATA
         LTR   R15,R15                  Anything?
         JZ    C00550                   None, skip
         L     R14,=AL4(C_PCL)          Yes, A(Parse Control List)
         AH    R14,C_21SF-C_PCL(R14)    A(IKJSUBF entry)
         AH    R14,2(0,R14)             A(1st IKJNAME entry)
C00500   DS    0H
         TM    0(R14),X'60'             Is this an IKJNAME PCE?
         JNO   C00550                   No, must have reached the end
         CHI   R15,1                    Is this our entry?
         JE    C00510                   Yes, check it out
         AH    R14,2(0,R14)             No, bump to next PCE
         BRCT  R15,C00500               and check it out
         J     C00550                   Unknown, ignore it
C00510   DS    0H
         CLC   =C'DISPLAY',5(R14)       DISPLAY?
         JE    C00520                   Yes, skip
         CLC   =C'CB',5(R14)            No, CB?
         JE    C00530                   Yes, skip
         CLC   =C'ALL',5(R14)           No, ALL?
         JE    C00540                   Yes, skip
         J     C00550                   Unknown, ignore it
C00520   DS    0H
         OI    @_OutData_DISPLAY,L'@_OutData_DISPLAY   Set flag
         J     C00550
C00530   DS    0H
         OI    @_OutData_CB,L'@_OutData_CB   Set flag
         J     C00550
C00540   DS    0H
         OI    @_OutData_ALL,L'@_OutData_ALL   Set flag
         J     C00550

C00550   DS    0H
*---------------------------------------------------------------------*
*   Process NOHEADINGS keyword                                        *
*---------------------------------------------------------------------*
         CLI   C_13K+1-IKJPARMD(R1),0   Was NOHEADINGS entered?
         JE    C00560                   No, skip
         OI    @_No_Headings,L'@_No_Headings Yes, set flag

C00560   DS    0H
*---------------------------------------------------------------------*
*   Process NODETAILS keyword                                         *
*---------------------------------------------------------------------*
         CLI   C_14K+1-IKJPARMD(R1),0   Was NODETAILS entered?
         JE    C00570                   No, skip
         OI    @_No_Details,L'@_No_Details Yes, set our flag

C00570   DS    0H
*---------------------------------------------------------------------*
*   Process NOTOTALS keyword                                          *
*---------------------------------------------------------------------*
         CLI   C_15K+1-IKJPARMD(R1),0   Was NOTOTALS entered?
         JE    C00580                   No, skip
         OI    @_No_Totals,L'@_No_Totals Yes, set our flag

C00580   DS    0H
*---------------------------------------------------------------------*
*   Process STATISTICS keyword                                        *
*---------------------------------------------------------------------*
         CLI   C_17K+1-IKJPARMD(R1),0     Was STATISTICS entered?
         JE    C00590                   No, skip
         OI    @_Statistics,L'@_Statistics Yes, set our flag

C00590   DS    0H
*---------------------------------------------------------------------*
*   Process ISPF keyword                                              *
*---------------------------------------------------------------------*
         LH    R15,C_12SFP-IKJPARMD(R1) Get Kwd nbr for ISPF
         LTR   R15,R15                  Anything?
         JZ    C00650                   No, skip
         OI    @_ISPF_Explicit,L'@_ISPF_Explicit Yes, set our flag
         L     R14,=AL4(C_PCL)          A(Parse Control List)
         AH    R14,C_12SF-C_PCL(R14)    A(IKJSUBF entry)
         AH    R14,2(0,R14)             A(1st IKJNAME entry)
C00600   DS    0H
         TM    0(R14),X'60'             Is this an IKJNAME PCE?
         JNO   C00650                   No, must have reached the end
         CHI   R15,1                    Is this our entry?
         JE    C00610                   Yes, check it out
         AH    R14,2(0,R14)             No, bump to next PCE
         BRCT  R15,C00600               and check it out
         J     C00650                   Unknown, ignore it
C00610   DS    0H
         CLC   =C'EDIF',5(R14)          No, EDIF?
         JE    C00630                   Yes, skip
         CLC   =C'BRIF',5(R14)          No, BRIF?
         JE    C00640                   Yes, skip
         CLC   =C'SPACE',5(R14)         Table display?
         JE    C00620                   Yes, skip
         CLC   =C'NONE',5(R14)          No ISPF?
         JNE   C00650                   No, ignore it
         J     C00650                   Unknown, ignore it
C00620   DS    0H
         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag
         J     C00650
C00630   DS    0H
         OI    @_ISPF_EDIF,L'@_ISPF_EDIF EDIF output
         J     C00650
C00640   DS    0H
         OI    @_ISPF_BRIF,L'@_ISPF_BRIF BRIF output
         J     C00650

C00650   DS    0H
*---------------------------------------------------------------------*
*   Check the NOECHO keyword                                          *
*---------------------------------------------------------------------*
         CLI   C_16K+1-IKJPARMD(R1),0   Was NOECHO entered?
         JE    C00660                   No, skip
         OI    @C_NoEcho,L'@C_NoEcho    Yes, set our flag

C00660   DS    0H
*---------------------------------------------------------------------*
*   Process NOLSPACE keyword                                          *
*---------------------------------------------------------------------*
         CLI   C_18K+1-IKJPARMD(R1),0   Was NOLSPACE entered?
         JE    C00665                   No, skip
         OI    @_No_LSPACE,L'@_No_LSPACE Yes, set flag

C00665   DS    0H
*---------------------------------------------------------------------*
*   Process LINESIZE Keyword                                          *
*---------------------------------------------------------------------*
         TM    C_22SFP+6-IKJPARMD(R1),X'80' Was LINESIZE entered?
         JZ    C00665I                  No, skip
         L     R15,C_22SFP-IKJPARMD(R1) Yes, point to it
         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length
         CHI   R14,3                    Could it be max?
         JNE   C00665E                  No, skip
         CLC   =C'MAX',0(R15)           Yes, is it?
         JNE   C00665E                  No, skip
         LHI   R0,-1                    Yes, flag it
         J     C00665G                  and skip
C00665E  DS    0H
         CLI   0(R15),C'0'              Numeric?
         JL    C00665I                  No, ignore it
         CLI   0(R15),C'9'              Maybe, check again
         JH    C00665I                  Not numeric, ignore it
         AHI   R15,1                    Bump pointer
         BRCT  R14,C00665E              and continue

         L     R15,C_22SFP-IKJPARMD(R1) Point to number
         LH    R14,C_22SFP+4-IKJPARMD(R1) Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX5                Pack line length
         CVB   R0,@C_DBLWD              Binarize it
C00665G  DS    0H
         STH   R0,@_LineSize            Save it
C00665I  DS    0H

C00667   DS    0H
*---------------------------------------------------------------------*
*   Process MAXLWAIT Keyword                                          *
*---------------------------------------------------------------------*
         TM    C_23SFP+6-IKJPARMD(R1),X'80' Was MAXLWAIT entered?
         JZ    C00667I                  No, skip
         L     R15,C_23SFP-IKJPARMD(R1) Yes, point to it
         LH    R14,C_23SFP+4-IKJPARMD(R1) Get its length
         AHI   R14,-1                   Get EX length
         EX    R14,C2EX5                Pack line length
         CVB   R0,@C_DBLWD              Binarize it
         STH   R0,@_MaxLWait            Save it
C00667I  DS    0H

C00670   DS    0H
*---------------------------------------------------------------------*
*   We have finished with the command buffer, so free up the          *
*  storage used by IKJPARS                                            *
*---------------------------------------------------------------------*
         IKJRLSA @C_PANS                Free IKJPARS storage

         AIF   (NOT &ISPF_by_Default).ISPF_by_Default_010
*---------------------------------------------------------------------*
*   We want ISPF displays by default; if the ISPF keyword was         *
*  not specified, set up our flags as if it were.                     *
*---------------------------------------------------------------------*
         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF Keyword there?
         JO    C00700                   Yes, don't do anything

         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_005
         CLC   =C'SPACE',=C'&ISPF_Default_Type' Default of SPACE?
         JNE   C00680                   No, skip
         OI    @_ISPF_SPACE,L'@_ISPF_SPACE Yes, set our flag
         J     C00700                   and skip
C00680   DS    0H
         CLC   =C'EDIF',=C'&ISPF_Default_Type' Default of EDIF?
         JNE   C00690                   No, skip
         OI    @_ISPF_EDIF,L'@_ISPF_EDIF Yes, set our flag
         J     C00700                   and skip
C00690   DS    0H
         CLC   =C'BRIF',=C'&ISPF_Default_Type' Default of BRIF?
         JNE   C00700                   No, unknown
         OI    @_ISPF_BRIF,L'@_ISPF_BRIF Yes, set our flag
         J     C00700                   and skip
.ISPF_Default_Type_005 ANOP

C00700   DS    0H
.ISPF_by_Default_010 ANOP
*---------------------------------------------------------------------*
*   If we are producing headings, put them in the table               *
*---------------------------------------------------------------------*
         TM    @_No_Headings,L'@_No_Headings Do we want headings?
         JO    C00710                   No, skip

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,W00010               Get A(Free entry in VolTbl)
         LTR   R15,R15                  Did it work?
         JNZ   C00710                   No, skip headings

         LR    R9,R1                    Get A(Free entry)
         USING VolTbl_Ent,R9

         OI    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1
         LA    R14,C_Hdg0               A(Heading line)
         LHI   R15,C_Hdg0_Len           Length of heading
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move heading
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done
         OI    VolTbl_Ent_ECB,X'40'     POST as complete

         MVC   @C_Time,C_Time           Move L-Form of macro
         TIME  DEC,                     Get time                       +
               @C_TIMEArea,              and return it here            +
               LINKAGE=SYSTEM,           don't use the SVC             +
               DATETYPE=YYYYMMDD,        format of returned data       +
               MF=(E,@C_TIME)            addr of macro list
         L     R0,@C_TIMEArea           Get the time
         SRL   R0,4                     Shift out hundredths
         ST    R0,@C_TimeArea           Save it
         OI    @C_TimeArea+3,X'0F'      OR in a sign
         MVC   VolTbl_Ent_Display+11(10),=X'402120207A20207A2020'
         ED    VolTbl_Ent_Display+11(10),@C_TimeArea Edit time
         L     R15,@C_TimeArea+8        Get Date (yyyymmdd)
         LA    R14,0                    Clear work register
         SLDL  R14,4                    Make room for sign
         STM   R14,R15,@C_TimeArea      Save it
         OI    @C_TimeArea+7,X'0F'      OR in a sign
         MVC   VolTbl_Ent_Display(12),=X'402120202020612020612020'
         ED    VolTbl_Ent_Display(12),@C_TimeArea+3 Edit date

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,W00010               Get A(Free entry in VolTbl)
         LTR   R15,R15                  Did it work?
         JNZ   C00710                   No, skip headings

         LR    R9,R1                    Get A(Free entry)

         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag
         LA    R14,C_Hdg1               A(Heading line)
         LHI   R15,C_Hdg1_Len           Length of heading
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move heading
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done
         OI    VolTbl_Ent_ECB,X'40'     POST as complete

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,W00010               Get A(Free entry in VolTbl)
         LTR   R15,R15                  Did it work?
         JNZ   C00710                   No, skip headings

         LR    R9,R1                    Get A(Free entry)

         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag
         LA    R14,C_Hdg2               A(Heading line)
         LHI   R15,C_Hdg2_Len           Length of heading
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move heading
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done
         OI    VolTbl_Ent_ECB,X'40'     POST as complete

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,W00010               Get A(Free entry in VolTbl)
         LTR   R15,R15                  Did it work?
         JNZ   C00710                   No, skip headings

         LR    R9,R1                    Get A(Free entry)

         OI    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Flag
         LA    R14,C_Hdg3               A(Heading line)
         LHI   R15,C_Hdg3_Len           Length of heading
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move heading
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done
         OI    VolTbl_Ent_ECB,X'40'     POST as complete

C00710   DS    0H
*---------------------------------------------------------------------*
*   If we are running in Batch, and NOECHO was not specified, go      *
*  print an image of the input record                                 *
*---------------------------------------------------------------------*
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JO    C00720                   Yes, skip

         TM    @C_NoEcho,L'@C_NoEcho    Was NOECHO specified?
         JNE   C00720                   Yes, skip

         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)
         ST    R15,@C_Parms_Y00010      Save it
         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB
         LH    R15,DCBLRECL-IHADCB(R15) Get length
         ST    R15,@C_Parms_Y00010+4    Save it

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,Y00010               Output it to SYSPRINT

C00720   DS    0H
         LA    R15,0                    Clear return code
         J     C90010                   and exit

C00730   DS    0H
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    C00740                   No, skip
         LA    R15,4                    PARSE failure
         J     C90010                    and exit

C00740   DS    0H
         L     R15,@C_SYSIN_Rec_Ptr     A(Our data area)
         ST    R15,@C_Parms_Y00010      Save it
         L     R15,@_SYSIN_DCB_Ptr      Point to the DCB
         LH    R15,DCBLRECL-IHADCB(R15) Get length
         ST    R15,@C_Parms_Y00010+4    Save it

         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,Y00010               Output to SYSPRINT

         LHI   R15,L'VolTbl_Ent_ErrMsg  Length of 1 message
         ST    R15,@C_Parms_Y00010+4    Save it for Y00010
         LA    R4,C_ErrMsgs             Point to 1st err msg
         LHI   R3,C_ErrMsg_Count        Get the number of messages
C00750   DS    0H
         ST    R4,@C_Parms_Y00010       Save A(Error message)
         LA    R1,@C_Parms              A(Parm list)
         BRAS  R14,Y00010               Output to SYSPRINT
         AHI   R4,L'VolTbl_Ent_ErrMsg   A(Next message)
         BRCT  R3,C00750                and issue it

         J     C00080                   Get another input record


*-------------------------------------------------------------------*
*    The following is the EOD exit when 31-bit SAM is not supported *
*   for SYSIN. This code is moved to 24-bit storage, and is invoked *
*   by SYSIN EOD. All it does is branch to our 'real' EOD routine,  *
*   in 31-bit mode.                                                 *
*-------------------------------------------------------------------*
         PUSH  USING                  Save current USINGs
         DROP  ,                      No USINGs now

C00760_24_Start DS 0H                Start of 24-bit EOD Routine
         BASR  R15,0                  Load up our base
         USING *,R15                  Tell the Assembler
         L     R15,C00760_24_EOD      Get real EODAD
         BSM   0,R15                  and go do it (in 31-bit mode)
C00760_24_EOD DC AL4(X'80000000'+C00760) Real EODAD
C00760_24_Length EQU *-C00760_24_Start Length of 24-bit EOD Routine

         DROP  R15                    Free up our base reg
         POP   USING                  Restore USING environment


C00760   DS    0H
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JO    C00780                   Yes, skip
         ICM   R1,B'1111',@_SYSIN_DCB_Ptr A(SYSIN DCB)
         JZ    C00780                   None, skip
         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN Is it open?
         JNO   C00770                   No, skip
         MVC   @C_CLOSE,C_CLOSE         Yes, move CLOSE parms
         LR    R3,R1                    Set up DCB pointer
         CLOSE ((3)),MODE=31,MF=(E,@C_CLOSE)  and close it
C00770   DS    0H
         LHI   R0,C_SYSIN_DCB_Length+C00760_24_Length+7 DCB, 24-bit EOD
         SRL   R0,3                     DBLWD
         SLL   R0,3                      multiple

         L     R1,@_SYSIN_DCB_Ptr       A(SYSIN DCB area)

         BASR  R2,0
         USING (*,C00770_End-1),R2
         STORAGE RELEASE,               Free the DCB storage           +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                this long
C00770_End DS  0H
         DROP  R2

         LA    R15,0                    Clear work register
         ST    R15,@_SYSIN_DCB_Ptr      No more DCB area
C00780   DS    0H
         LA    R15,4                    Set return code
         J     C90010                    and exit


C90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@C_Dynam              A(Local storage)
         L     R2,@C_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

C_Literals  DS  0H

C2EX1    MVC   0(0,R4),0(R15)           Move UCB/Volser
C2EX3    MVC   @_UNITNM(0),0(R15)       Move Unit Name
C2EX4    MVC   @_OutFile_DDName(0),0(R15) Move OUTFILE DDName
C2EX5    PACK  @C_DBLWD,0(0,R15)        Pack a number
C_Save_Sort_Field  MVC   @_Sort_Field(0),5(R14)

C_PgmName  DC  C'&PGMNAME'      Simulated command name

         PUSH  PRINT
         PRINT NOGEN

C_Time   TIME  LINKAGE=SYSTEM,MF=L
C_Time_Length EQU *-C_Time

C_OPEN    OPEN  (0,INPUT),MODE=31,MF=L
C_OPEN_Length EQU *-C_OPEN

C_CLOSE   CLOSE (0),MODE=31,MF=L
C_CLOSE_Length EQU *-C_CLOSE

C_LINKX   LINKX SF=L
C_LINKX_Length EQU *-C_LINKX
         POP   PRINT

C_TrTbl  DC    256AL1(*-C_TrTbl)
         ORG   C_TrTbl+C'?'
         DC    X'FF'
         ORG   C_TrTbl+C'%'
         DC    X'FF'
         ORG   C_TrTbl+C'*'
         DC    X'FF'
         ORG

C_TrTbl1 DC    256X'00'
         ORG   C_TrTbl1+C'?'
         DC    X'FF'
         ORG   C_TrTbl1+C'%'
         DC    X'FF'
         ORG   C_TrTbl1+C'*'
         DC    X'FF'
         ORG

         LTORG

         PUSH  PRINT
         PRINT NOGEN
C_SYSIN_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,             +
               DCBE=C_SYSIN_DCBE
         DS    0D
C_SYSIN_DCB_Length EQU *-C_SYSIN_DCB

C_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=C00760
         DS    0D
C_SYSIN_DCBE_Length EQU *-C_SYSIN_DCBE

C_SYSIN24_DCB DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,           +
               EODAD=0
         DS    0D
C_SYSIN24_DCB_Length EQU *-C_SYSIN24_DCB
         POP   PRINT

C_Hdg0   EQU   *
         DC    C' yyyy/mm/dd hh:mm:ss   &PGMNAME &VERSION DASD Free Spa+
               ce Report'
C_Hdg0_Len EQU *-C_Hdg0

C_Hdg1   EQU   *
         DC    CL(VolTbl_Ent_FreeSpace_Info-VolTbl_Ent_Display_Start)' +
               '
C_Hdg1_1 DC    (VolTbl_Ent_FreeSpace_Info_End-VolTbl_Ent_FreeSpace_Info+
               )C'-'
         ORG   C_Hdg1_1+((*-C_Hdg1_1-13)/2)
         DC    C' Volume Free '
         ORG   ,
         DC    CL(VolTbl_Ent_VTOC_Info-VolTbl_Ent_FreeSpace_Info_End)' +
               '
C_Hdg1_2 DC    (VolTbl_Ent_VTOC_Info_End-VolTbl_Ent_VTOC_Info)C'-'
         ORG   C_Hdg1_2+((*-C_Hdg1_2-6)/2)
         DC    C' VTOC '
         ORG   ,
         DC    CL(VolTbl_Ent_SMS_Info-VolTbl_Ent_VTOC_Info_End)' '
C_Hdg1_3 DC    (VolTbl_Ent_SMS_Info_End-VolTbl_Ent_SMS_Info)C'-'
         ORG   C_Hdg1_3+((*-C_Hdg1_3-5)/2)
         DC    C' SMS '
         ORG   ,
         DC    CL(VolTbl_Ent_CHPID_Info-VolTbl_Ent_SMS_Info_End)' '
C_Hdg1_4 DC    (VolTbl_Ent_CHPID_Info_End-VolTbl_Ent_CHPID_Info)C'-'
         ORG   C_Hdg1_4+((*-C_Hdg1_4-8)/2)
         DC    C' CHPIDs '
         ORG   ,
C_Hdg1_Len EQU *-C_Hdg1

C_Hdg2   EQU   *
         DC    C'                                                    '
         DC    C'   Nbr   - Largest -  Frag         Free    % IX'
         DC    C'   Vol  Storage                                     '
         DC    C'                '
C_Hdg2_Len EQU *-C_Hdg2

C_Hdg3   EQU   *
         DC    C'VOLSER  UCB  DevType   St    Trks  Cyls     %  Bytes'
         DC    C' Xtnts    Trks  Cyls Index   Trks DSCBs Free St'
         DC    C'  Size  Group    Status                             '
         DC    C'                '
C_Hdg3_Len EQU *-C_Hdg3

C_ErrMsgs EQU  *

         DC    CL(L'VolTbl_Ent_ErrMsg)'*** Unrecognized input - ignored+
                ***'
         DC    CL(L'VolTbl_Ent_ErrMsg)' '
         DC    CL(L'VolTbl_Ent_ErrMsg)'Valid Keywords:'
         DC    CL(L'VolTbl_Ent_ErrMsg)' UCB(Unit-mask)     specifies th+
               e selection criterion based on UCB Address.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' XUCB(Unit-mask)    specifies th+
               e exclusion criterion based on UCB Address.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' VOLUME(Volser)     specifies th+
               e selection criterion based on volser.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' XVOLUME(Volser)    specifies th+
               e exclusion criterion based on volser.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NAME(Unit-Name)    specifies th+
               e selection criterion based on generic'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  or esoteric Un+
               it name.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' ATTRIBUTE(STORAGE/STG/PRIVATE/P+
               VT/PUBLIC/SMS)'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +
               selection criterion based on mount'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  attribute. Onl+
               y one of the keywords can be specified.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' STORGRP(SMS-Storage_Group_Name)+
               '
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  specifies the +
               selection criterion based on SMS'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Storage Group.+
               '
         DC    CL(L'VolTbl_Ent_ErrMsg)' SORT(id)         specifies the +
               order in which the selected DASD volumes'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  are displayed:+
               '
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   id: VOL     -+
                Volser'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       UCB     -+
                UCB Name (Device Address)'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       DEVT    -+
                Device Type'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       ATTR    -+
                Mount Attribute'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREET   -+
                Total Free Tracks'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEC   -+
                Total Free Cylinders'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEP   -+
                % Volume Free'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEB   -+
                Total Free Bytes'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FREEE   -+
                # Free Extents'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGET  -+
                Largest Free Tracks'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       LARGEC  -+
                Largest Free Cylinders'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREED  -+
                Free DSCBs in VTOC'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VFREEP  -+
                % VTOC Free'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VTRK    -+
                Tracks allocated to the VTOC'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VIX     -+
                VTOC Index Status'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       FRAG    -+
                Fragmentation Index'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       VOLSIZE -+
                Volume Capacity'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       STORGRP -+
                SMS Storage Group'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       SMSSTAT -+
                SMS Volume Status'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                       CHIPDS  -+
                1st CHPID'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  By default, th+
               e display is unsorted, and will'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  normally appea+
               r in ascending order of UCB.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' ASCENDING/DESCENDING specifies +
               the SORT order. Significant only if'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  SORT() is spec+
               ified. Default is ASCENDING'
         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXTASKS(#)        specifies th+
               e maximum number of sub-tasks (1-16) to'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  be ATTACHed to+
                retrieve volume information.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTFILE(ddname)  specifies the +
               DDNAME of an output file to which'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  volume informa+
               tion will be written, in addition'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  to SYSPRINT.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' OUTDATA(DISPLAY/CB/ALL) specifi+
               es the type of data to be written to'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  the OUTFILE DD+
               NAME:'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   DISPLAY write+
               s SYSPRINT data to OUTFILE'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   CB      wtite+
               s copies of the UCB, DCE, LSPACE,'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                           and F+
               4DSCB to OUTFILE'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   ALL     write+
               s both CB and DISPLAY (default).'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NOHEADINGS/NOHDG suppresses hea+
               dings (and page breaks).'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NODETAILS        suppresses det+
               ail (DASD volume) lines.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NOTOTALS         suppresses tot+
               als line.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NOECHO           suppresses the+
                display of the input command.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' STATISTICS/STATS displays inter+
               nal processing statistics.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' ISPF(S/E/B/N)    displays resul+
               ts using ISPF DM services, if available.'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   S(pace) uses +
               customized &PGMNAME displays'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   E(dif) uses I+
               SPF Edit services'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   B(rif) uses I+
               SPF Browse services.'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                   N(one) uses T+
               SO line-by-line (PUTLINE) output.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' NOLSPACE         specifies that+
                no volume space information is required.'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  Fields display+
               ed are: UCB, Volser, DevType, Attr, SMS'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  data, and CHPI+
               Ds.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' LINESIZE(nnn)    specifies the +
               maximum line length to be displayed'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  in TSO line-by+
               line output.'
         DC    CL(L'VolTbl_Ent_ErrMsg)' MAXLWAIT(nnnn)   specifies the +
               maximum number of seconds in which'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  each LSPACE in+
               vocation must complete. 0 signifies'
         DC    CL(L'VolTbl_Ent_ErrMsg)'                  no limit.'

C_ErrMsg_Count EQU   (*-C_ErrMsgs)/L'VolTbl_Ent_ErrMsg

         PUSH  PRINT
         PRINT NOGEN

C_PCL    RMODE ANY
C_PCL    AMODE 31
C_PCL    IKJPARM

C_01K    IKJKEYWD
         IKJNAME 'UNIT',                                               +
               ALIAS='UCB',                                            +
               SUBFLD=C_01SF

C_02K    IKJKEYWD
         IKJNAME 'XUNIT',                                              +
               ALIAS='XUCB',                                           +
               SUBFLD=C_02SF

C_03K    IKJKEYWD
         IKJNAME 'VOLUME',                                             +
               SUBFLD=C_03SF

C_04K    IKJKEYWD
         IKJNAME 'XVOLUME',                                            +
               SUBFLD=C_04SF

C_05K    IKJKEYWD
         IKJNAME 'NAME',                                               +
               SUBFLD=C_05SF

C_06K    IKJKEYWD
         IKJNAME 'ATTRIBUTE',                                          +
               SUBFLD=C_06SF

C_07K    IKJKEYWD
         IKJNAME 'STORGRP',                                            +
               ALIAS='SG',                                             +
               SUBFLD=C_07SF

C_09K    IKJKEYWD
         IKJNAME 'SORT',                                               +
               SUBFLD=C_09SF

C_10K    IKJKEYWD
         IKJNAME 'ASCENDING'
         IKJNAME 'DESCENDING'

C_11K    IKJKEYWD
         IKJNAME 'MAXTASKS',                                           +
               SUBFLD=C_11SF

C_12K    IKJKEYWD
         IKJNAME 'ISPF',                                               +
               SUBFLD=C_12SF

C_13K    IKJKEYWD
         IKJNAME 'NOHEADINGS',                                         +
               ALIAS='NOHDG'

C_14K    IKJKEYWD
         IKJNAME 'NODETAILS'

C_15K    IKJKEYWD
         IKJNAME 'NOTOTALS'

C_16K    IKJKEYWD
         IKJNAME 'NOECHO'

C_17K    IKJKEYWD
         IKJNAME 'STATISTICS',                                         +
               ALIAS='STATS'

C_18K    IKJKEYWD
         IKJNAME 'NOLSPACE'

C_20K    IKJKEYWD
         IKJNAME 'OUTFILE',                                            +
               ALIAS=('OFILE','OUTDDNAME'),                            +
               SUBFLD=C_20SF

C_21K    IKJKEYWD
         IKJNAME 'OUTDATA',                                            +
               SUBFLD=C_21SF

C_22K    IKJKEYWD
         IKJNAME 'LINESIZE',                                           +
               SUBFLD=C_22SF

C_23K    IKJKEYWD
         IKJNAME 'MAXLWAIT',                                           +
               SUBFLD=C_23SF



C_01SF   IKJSUBF
C_01SFP  IKJIDENT 'UCB Mask(s) to be selected',                        +
               LIST,                                                   +
               MAXLNTH=4,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_02SF IKJSUBF
C_02SFP   IKJIDENT 'UCB Mask(s) to be excluded',                       +
               LIST,                                                   +
               MAXLNTH=4,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_03SF   IKJSUBF
C_03SFP  IKJIDENT 'Volser mask(s) to be selected',                     +
               LIST,                                                   +
               MAXLNTH=6,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_04SF    IKJSUBF
C_04SFP   IKJIDENT 'Volser mask(s) to be excluded',                    +
               LIST,                                                   +
               MAXLNTH=6,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_05SF   IKJSUBF
C_05SFP  IKJIDENT 'Unit Name to be selected',                          +
               MAXLNTH=8,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_06SF   IKJSUBF
C_06SFP  IKJKEYWD
         IKJNAME 'STORAGE',                                            +
               ALIAS='STG'
         IKJNAME 'PRIVATE',                                            +
               ALIAS='PVT'
         IKJNAME 'PUBLIC'
         IKJNAME 'SMS'

C_07SF    IKJSUBF
C_07SFP   IKJIDENT 'SMS Storage Group Name(s)',                        +
               LIST,                                                   +
               MAXLNTH=30,                                             +
               FIRST=ANY,                                              +
               OTHER=ANY

C_09SF   IKJSUBF
C_09SFP  IKJKEYWD
         IKJNAME 'VOL'
         IKJNAME 'UCB'
         IKJNAME 'DEVT'
         IKJNAME 'ATTR'
         IKJNAME 'FREET'
         IKJNAME 'FREEC'
         IKJNAME 'FREEP'
         IKJNAME 'FREEB'
         IKJNAME 'FREEE'
         IKJNAME 'LARGET'
         IKJNAME 'LARGEC'
         IKJNAME 'VFREED'
         IKJNAME 'VFREEP'
         IKJNAME 'VTRK'
         IKJNAME 'VIX'
         IKJNAME 'FRAG'
         IKJNAME 'VOLSIZE'
         IKJNAME 'STORGRP'
         IKJNAME 'SMSSTAT'
         IKJNAME 'CHPIDS'

C_11SF   IKJSUBF
C_11SFP  IKJIDENT 'Maximum number of Sub-Tasks',                       +
               MAXLNTH=2,                                              +
               INTEG

C_12SF IKJSUBF
         AIF   ('&ISPF_Default_Type' EQ '').ISPF_Default_Type_010
C_12SFP  IKJKEYWD DEFAULT='&ISPF_Default_Type'
         AGO   .ISPF_Default_Type_020
.ISPF_Default_Type_010 ANOP
C_12SFP  IKJKEYWD
.ISPF_Default_Type_020 ANOP
         IKJNAME 'EDIF'
         IKJNAME 'BRIF'
         IKJNAME 'SPACE'
         IKJNAME 'NONE'


C_20SF   IKJSUBF
C_20SFP  IKJIDENT 'DDNAME of output file',                             +
               MAXLNTH=8,                                              +
               FIRST=ALPHA,                                            +
               OTHER=ANY

C_21SF IKJSUBF
C_21SFP  IKJKEYWD DEFAULT='ALL'
         IKJNAME 'DISPLAY'
         IKJNAME 'CB'
         IKJNAME 'ALL'

C_22SF   IKJSUBF
C_22SFP  IKJIDENT 'Max length of data to be displayed',                +
               MAXLNTH=3,                                              +
               FIRST=ANY,                                              +
               OTHER=ANY

C_23SF   IKJSUBF
C_23SFP  IKJIDENT 'Nbr seconds for LSPACE completion',                 +
               MAXLNTH=4,                                              +
               FIRST=NUMERIC,                                          +
               OTHER=NUMERIC

         IKJENDP

         POP   PRINT

C_Literals_End  DS  0H


@C_Dynam                  DSECT       Dynamic area for C00000
                          DS    18F    O/S Style save area
@C_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@C_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)
@C_DBLWD                  DS    D      Workarea
@C_PPL                    DS    CL(PPL_Length) PPL area
@C_PECB                   DS    F      ECB for PARSE
@C_PANS                   DS    A      PARSE answer area
@C_SYSIN_Rec_Ptr          DS    AL4    SYSIN Record Pointer
@C_CPPL_Ptr               DS    AL4    A(CPPL)
@C_CBUF                   EQU   *      Batch Command buffer
@C_CBUF_Len               DS    HL2     Length
@C_CBUF_Off               DS    HL2     Offset to operands
@C_CBUF_Data              DS    CL255   Data
@C_CBUF1                  EQU   *      Cbuf after ASASYMBM
@C_CBUF1_Len              DS    HL2     Length
@C_CBUF1_Off              DS    HL2     Offset to operands
@C_CBUF1_Data             DS    CL255   Data
                          DS    X      Flag byte
@C_NoEcho                 EQU   *-1,X'80' 1... .... NOECHO specified
@C_UNIT_Flag              EQU   *-1,X'40' .1.. .... UNIT processed
@C_XUNIT_Flag             EQU   *-1,X'20' ..1. .... XUNIT processed
@C_VOL_Flag               EQU   *-1,X'10' ...1 .... VOL processed
@C_XVOL_Flag              EQU   *-1,X'08' .... 1... XVOL processed
@C_UPTSWS                 DS    XL(L'UPTSWS) UPTSWS Save

                          DS    0F
@C_Macros                 EQU   *
@C_OPEN                   DS    CL(C_OPEN_Length)  OPEN parms
                          ORG   @C_Macros
@C_CLOSE                  DS    CL(C_CLOSE_Length) Close Parms
                          ORG   @C_Macros
@C_Time                   DS    CL(C_Time_Length)  L-Form of Time
                          DS    0D                 Alignment
@C_TimeArea               DS    CL16               Return area for Time
                          ORG   @C_Macros
@C_LINKX                  DS    CL(C_LINKX_Length) LINKX Macro
@C_SYMBP                  DS    CL(SYMBP_LEN)      ASASYMBM Parm area
@C_SYMBP_Target_Len       DS    FL4             ASASYMBM Target Length
@C_SYMBP_RC               DS    FL4             ASASYMBM Return code
                          ORG   ,
@C_Parms                  DS    0F     Parms for called rtns
@C_Parms_Std              DS    3AL4    Standard 3 parms
@C_Parms_Extra            EQU   *       Extra parms
@C_Parms_Y00010           DS    2AL4       for Y00010
                          ORG   ,
                          DS    0D     Alignment
@C_Dynam_Length           EQU   *-@C_Dynam  Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING

         TITLE 'D00010: Get Eligible UCBs'

         PUSH  USING

D00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : D00010                                                 *
*                                                                     *
*  Abstract  : Populate Volume Table with eligible UCBs.              *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0 - OK, @_VolTbl_Ptr contains A(Volume Table)     *
*                   4 - No UCBs found/Insufficient Storage            *
*                                                                     *
*  Notes     : @_VOL_List_Ptr contains A(Volume masks)                *
*              @_XVOL_List_Ptr contains A(Xolume masks)               *
*              @_UCB_List_Ptr contains A(UCB masks)                   *
*              @_XUCB_List_Ptr contains A(XUCB masks)                 *
*              @_UNITNM contains the Esoteric Unit Name               *
*              @_ATTR??? contains the Mount Attribute flags           *
*              @_STORGRP_List_Ptr contains A(StorGrp masks)           *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1994/05/24 SDDA030 - Used SSCUCBS to get list of UCBs  *
*                                 - Added creation of dummy total line*
*              1996/03/13 SDDA030 - Used UCBCHAN rather than UCBNAME  *
*                                   to get readable device address    *
*                                   (VolTbl_Ent_DevAddr)              *
*                                 - Use our own UCB look-up routines  *
*                                   rather than SSCUCBS               *
*              1998/09/17 SDDA030 - V2.0                              *
*                                 - Removed APF checks, and undoc-    *
*                                   umented UCB search method.        *
*                                 - Use UCBSCAN with DCEAREA to get   *
*                                   DCE info.                         *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Made sure there was always room   *
*                                   in the Volume Table for the Totals*
*                                   Line, if required.                *
*                                 - Added '%' as a single-character   *
*                                   wild-card match (like '?') in     *
*                                   UCB and Volser.                   *
*                                 - Added repetitive search if select-*
*                                   ing by UCB address when the user  *
*                                   entered a potential 3-byte UCB    *
*                                   address mask, and we found no UCBs*
*                                   because we were using it as a     *
*                                   4-byte UCB address mask.          *
*                                 - Added DEVN to UCBSCAN             *
*                                 - Invoke UCBSCAN with VOLSER= if    *
*                                   we are checking for a specific    *
*                                   Volser                            *
*                                 - Broke out Subtask Management code *
*                                   into a separate routine (E00010). *
*              1999/08/20 SDDA030 - V2.8                              *
*                                 - Used Routine W00010 to manage     *
*                                   VolTbl entries.                   *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Added SMS Storage Group and CHPID *
*                                   info.                             *
*                                 - Used only DCEOBRDT to determine   *
*                                   Device Type.                      *
*                                 - Added 'N/A' in SMS fields for     *
*                                   non-SMS volumes.                  *
*              2001/11/12 SDDA030 - V2.15                             *
*                                 - Added XUCB, XVOL processing       *
*                                 - Added RANGE=ALL, DYNAMIC=YES,     *
*                                   LOC=ANY to EDTINFO                *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - Added STORGRP selection logic     *
*                                 - Moved SMS IEFSSREQ stuff to T00010*
*                                 - Added indicators for CHPIDs not   *
*                                   phys or log available.            *
*              2002/06/11 SDDA030 - V2.18                             *
*                                 - Formatted as much of total line as*
*                                   possible.                         *
*                                 - 'POST' entries as complete if we  *
*                                   will not be LSPACEing.            *
*              2002/08/08 SDDA030 - V2.19                             *
*                                 - Merged code from U0010 into this  *
*                                   section                           *
*                                 - Corrected increment when stepping *
*                                   through @_STORGRP_List            *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Fixed S0C4 when adjusting UCB pat-*
*                                   terns when no UCBs found when sel-*
*                                   ecting by UCB.                    *
*                                 - Limited re-searching based on len *
*                                   of entered UCB mask(s)            *
*              2005/01/20 SDDA030 - V2.23                             *
*                                 - Used CSRSI, if possible, to get   *
*                                   CPU info.                         *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Added .e display                  *
*                                 - Init CHPIDs to '--'               *
*                                 - Used standardised calling sequence*
*                                 - Coped with insufficient storage   *
*                                   for the volume table.             *
*                                 - Used UCBTBYT4 to find device type *
*                                   for emulated devices.             *
*              ____/__/__ _______ -                                   *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,D_Literals           Point to our literals
         USING (D_Literals,D_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@D_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@D_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @D_Dynam,R13             Assign a base
         L     R15,@D_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack)
         ST    R15,@D_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack)
         ST    R15,@D_24Bit_Stack_Ptr_Ptr Save it

D00020   DS    0H
*-------------------------------------------------------------------*
*    Reset our flags and counters                                   *
*-------------------------------------------------------------------*
         NI    @D_Eligible_UCB_Found,X'FF'-L'@D_Eligible_UCB_Found
         NI    @D_CHPID_Unavail,X'FF'-L'@D_CHPID_Unavail CHPIDs OK
         LA    R15,0                    Clear
         ST    R15,@D_Volume_Count       nbr vols found

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@D_Parms_Std         Save it
         L     R15,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@D_Parms_Std+4       Save it
         L     R15,@D_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@D_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*     If we are selecting by name, go get UCBs associated with the    *
*    name                                                             *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear
         ST    R15,@D_UNITA              A(Unit Table)

         CLI   @_UNITNM,C' '            Selecting by unit name?
         JE    D00030                   No, skip
         LHI   R0,128                   Yes, get table
         SLL   R0,8                      size of 32K
         BASR  R2,0
         USING (*,D00020_End-1),R2
         STORAGE OBTAIN,                Go get storage                 +
               LENGTH=(0),               this long                     +
               LOC=31                    above-the-line
D00020_End DS  0H
         DROP  R2
         ST    R1,@D_UNITA              Save it
         ST    R0,0(0,R1)               Save table length
         LA    R15,0                    Clear nbr entries
         ST    R15,4(0,R1)              Update table
         MVI   @D_IOCT,0                Clear IOCP Token field
         MVC   @D_IOCT+1(L'@D_IOCT-1),@D_IOCT
         EDTINFO RTNDEVN,               Get UCB numbers                +
               UNITNAME=@_UNITNM,        for this esoteric             +
               DEVNLIST=@D_UNITA,        save them here                +
               DYNAMIC=YES,              get dynamic devices           +
               RANGE=ALL,                3- and 4-digit UCBs           +
               LOC=ANY,                  no matter where they live     +
               IOCTOKEN=@D_IOCT,         use dummy IOC Token           +
               MF=(E,@D_EDTINFO)         staying reentrant
         LTR   R15,R15                  Did it work?
         JNZ   D00490                   No, exit

D00030   DS    0H
*---------------------------------------------------------------------*
*   We now go and get UCBs (in fact, we get UCB copys), and the       *
*  associated Device Class Extensions (DCEs) using UCBSCAN.           *
*  First, however, we have to get the I/O Config token.               *
*---------------------------------------------------------------------*
         IOCINFO IOCTOKEN=@D_IOCT,      Get I/O Config token           +
               MF=(E,@D_IOCINFO)

D00040   DS    0H
*---------------------------------------------------------------------*
*   Initialize the UCBSCAN workarea ...                               *
*---------------------------------------------------------------------*
         XC    @D_UCBSCAN_WorkArea,@D_UCBSCAN_WorkArea Clear workarea

*---------------------------------------------------------------------*
*   If we have been invoked for a single Volser (ie, one with no      *
*  wildcards), we invoke UCBSCAN with the VOLSER parameter, and set   *
*  a flag indicating that we want to be invoked once only             *
*---------------------------------------------------------------------*
         NI    @D_Single_Volser,X'FF'-L'@D_Single_Volser Off our flag
         ICM   R1,B'1111',@_Vol_List_Ptr A(Volser list)
         JZ    D00050                   None, skip
         L     R0,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get count
         CHI   R0,1                     A single volser?
         JNE   D00050                   No, skip
         CLI   Vol_List_Ent_Mask-Vol_List_Hdr(R1),X'00' With
         JNE   D00050                    no wildcards?
         CLC   Vol_List_Ent_Mask+1-Vol_List_Hdr(L'Vol_List_Ent_Mask-1,R+
               1),Vol_List_Ent_Mask-Vol_List_Hdr(R1)
         JNE   D00050                   Wildcards, skip

         OI    @D_Single_Volser,L'@D_Single_Volser Only 1 Volser
         LA    R3,Vol_List_Ent_Vol-Vol_List_Hdr(R1) Point to it

         LHI   R15,L'@D_DCE             Length of DCE area
         STH   R15,@D_DCE_Length        Save it

         UCBSCAN COPY,                  Get a copy of a UCB            +
               UCBAREA=@D_UCB,           here                          +
               DCEAREA=@D_DCE,           copy DCE as well              +
               DCELEN=@D_DCE_Length,     copy this much                +
               DYNAMIC=YES,              include HCD devices           +
               NONBASE=NO,               only 1 UCB per device         +
               DEVCLASS=DASD,            this device type only         +
               RANGE=ALL,                3- and 4-byte UCB addresses   +
               VOLSER=(3),               find this volume              +
               IOCTOKEN=@D_IOCT,         This I/O Config               +
               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +
               MF=(E,@D_UCBSCAN)         and stay re-entrant

         LTR   R15,R15                  Did we get one?
         JZ    D00060                   Yes, skip
         CHI   R15,12                   No, I/O config changed?
         JE    D00020                   Yes, start again
         J     D00490                   End of UCBs, skip

D00050   DS    0H
*---------------------------------------------------------------------*
*     Get the next UCB                                                *
*---------------------------------------------------------------------*
         LHI   R15,L'@D_DCE             Length of DCE area
         STH   R15,@D_DCE_Length        Save it

         UCBSCAN COPY,                  Get a copy of a UCB            +
               UCBAREA=@D_UCB,           here                          +
               DCEAREA=@D_DCE,           copy DCE as well              +
               DCELEN=@D_DCE_Length,     copy this much                +
               DYNAMIC=YES,              include HCD devices           +
               NONBASE=NO,               only 1 UCB per device         +
               DEVCLASS=DASD,            this device type only         +
               RANGE=ALL,                3- and 4-byte UCB addresses   +
               IOCTOKEN=@D_IOCT,         This I/O Config               +
               WORKAREA=@D_UCBSCAN_WorkArea, use this workarea         +
               MF=(E,@D_UCBSCAN)         and stay re-entrant

         LTR   R15,R15                  Did we get one?
         JZ    D00060                   Yes, skip
         LA    R0,12                    No, RC if I/O config changed
         CR    R0,R15                   Is that what happened?
         JE    D00020                   Yes, start again
         J     D00490                   No, end of UCBs, skip

D00060   DS    0H
         NI    @D_SMS_Ptrs_OK,X'FF'-L'@D_SMS_Ptrs_OK No SMS data yet

*---------------------------------------------------------------------*
*     We have a UCB address, so check it out. First, it must be       *
*    ONLINE ...                                                       *
*---------------------------------------------------------------------*
         TM    @D_UCB+UCBSTAT-UCBOB,UCBONLI Online?
         JNO   D00480                   No, go get next UCB

*---------------------------------------------------------------------*
*     ... and then match our UNIT address, if applicable ...          *
*---------------------------------------------------------------------*
         MVO   @D_DBLWD+5(3),@D_UCB+UCBCHAN-UCBOB(L'UCBCHAN)
         OI    @D_DBLWD+7,X'0F'         Add a sign
         UNPK  @D_DBLWD(5),@D_DBLWD+5(3) Unpack it
         TR    @D_DBLWD+1(4),D_TRTAB     Make it readable
         MVC   @D_UCBNAME,@D_DBLWD+1    Save it

         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB List)
         JZ    D00080                   None, skip
         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries
         AHI   R1,UCB_List_Ent-UCB_List   and point to 1st
D00070   DS    0H
         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area
         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+
               )                        Wildcard positions = x'FF'
         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)
         JE    D00080                   We want it, skip
         AHI   R1,UCB_List_Ent_Length   Bump to next entry
         BRCT  R3,D00070                and try again
         J     D00480                   Not here, skip this UCB
D00080   DS    0H
         OI    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found
         ICM   R1,B'1111',@_XUCB_List_Ptr A(XUCB List)
         JZ    D00100                   None, skip
         L     R3,UCB_List_Hdr_Count-UCB_List_Hdr(R1) Get nbr entries
         AHI   R1,UCB_List_Ent-UCB_List     and point to 1st
D00090   DS    0H
         MVC   @D_DBLWD(L'@D_UCBName),@D_UCBName Move UCB to temp area
         OC    @D_DBLWD(L'@D_UCBName),UCB_List_Ent_Mask-UCB_List_Ent(R1+
               )                        Wildcard positions = x'FF'
         CLC   @D_DBLWD(L'@D_UCBName),UCB_List_Ent_UCB-UCB_List_Ent(R1)
         JE    D00480                   Exclude it, skip
         AHI   R1,UCB_List_Ent_Length   Bump to next entry
         BRCT  R3,D00090                and try again

D00100   DS    0H
*---------------------------------------------------------------------*
*     ... and our VOLSER criteria, if applicable ...                  *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_VOL_List_Ptr A(VOL List)
         JZ    D00130                   None, skip
         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries
         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st
D00120   DS    0H
         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser
         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)
         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)
         JE    D00130                   We want it, skip
         AHI   R1,Vol_List_Ent_Length   Bump to next entry
         BRCT  R3,D00120                and try again
         J     D00480                   Not here, skip this UCB
D00130   DS    0H
         ICM   R1,B'1111',@_XVOL_List_Ptr A(XVOL List)
         JZ    D00150                   None, skip
         L     R3,Vol_List_Hdr_Count-Vol_List_Hdr(R1) Get nbr entries
         AHI   R1,Vol_List_Ent-Vol_List     and point to 1st
D00140   DS    0H
         MVC   @D_DBLWD(L'UCBVOLI),@D_UCB+UCBVOLI-UCBOB Move Volser
         OC    @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Mask-Vol_List_Ent(R1)
         CLC   @D_DBLWD(L'UCBVOLI),Vol_List_Ent_Vol-Vol_List_Ent(R1)
         JE    D00480                   Exclude it, skip
         AHI   R1,Vol_List_Ent_Length   Bump to next entry
         BRCT  R3,D00140                and try again

D00150   DS    0H
*---------------------------------------------------------------------*
*     ... our esoteric name criteria, if applicable ...               *
*---------------------------------------------------------------------*
         ICM   R14,B'1111',@D_UNITA     Get A(Unit Table)
         JZ    D00170                   None, skip
         ICM   R15,B'1111',4(R14)       Get nbr devices
         JZ    D00480                   None, skip this UCB
         AHI   R14,8                    Yes, point to first

D00160   DS    0H
         CLC   @D_DBLWD+1(4),0(R14)     Is this us?
         JE    D00170                   Yes, use it
         AHI   R14,4                    No, point to next in Unit Tbl
         BRCT  R15,D00160               and check it
         J     D00480                   Skip this UCB

D00170   DS    0H
*---------------------------------------------------------------------*
*     ... and our Mount Attributes, if applicable ...                 *
*---------------------------------------------------------------------*
         TM    @_ATTRSMS,L'@_ATTRSMS    Selecting SMS vols?
         JZ    D00180                   No, skip
         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?
         JZ    D00480                   No, skip
         J     D00210                   OK, use this vol
D00180   DS    0H
         TM    @_ATTRPvt,L'@_ATTRPvt    Selecting PRIVATE vols?
         JZ    D00190                   No, skip
         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPRV PRIVATE?
         JZ    D00480                   No, skip
         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?
         JO    D00480                   Yes, skip
         J     D00210                   OK, use this vol
D00190   DS    0H
         TM    @_ATTRPub,L'@_ATTRPub    Selecting PUBLIC vols?
         JZ    D00200                   No, skip
         TM    @D_UCB+UCBSTAB-UCBOB,UCBBPUB PUBLIC?
         JZ    D00480                   No, skip
         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?
         JO    D00480                   Yes, skip
         J     D00210                   OK, use this vol
D00200   DS    0H
         TM    @_ATTRStg,L'@_ATTRStg    Selecting STORAGE vols?
         JZ    D00210                   No, use this vol
         TM    @D_UCB+UCBSTAB-UCBOB,UCBBSTR Storage?
         JZ    D00480                   No, skip this vol
         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?
         JO    D00480                   Yes, skip

D00210   DS    0H
*---------------------------------------------------------------------*
*     ... and our STORGRP criteria, if applicable.                    *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_STORGRP_List_Ptr A(STORGRP List)
         JZ    D00240                   None, STORGRP not a criterion

         TM    @D_UCB+UCBFL5-UCBOB,UCBSMS SMS?
         JZ    D00480                   No, skip this volume

         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?
         JO    D00480                  No, skip

         LA    R15,@D_UCB+UCBVOLI-UCBOB A(Volser)
         ST    R15,@D_Parms_T00010     Save it
         LA    R15,@D_VLD_Anchor       A(VLD Anchor)
         ST    R15,@D_Parms_T00010+4   Save it

         LA    R1,@D_Parms             A(Parm list)
         BRAS  R14,T00010              Go get Storgrp, status

         STM   R0,R1,@D_SMS_Ptrs       Save the results
         CHI   R15,4                   How did it go?
         JL    D00220                  OK, skip
         JE    D00480                  STORGRP not found, skip this vol
         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag
         J     D00480                  and skip this vol

D00220   DS    0H
         OI    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK  We have SMS data

         L     R15,@D_SMS_Ptrs+4        A(STORGRP Len, STORGRP)
         L     R1,@_STORGRP_List_Ptr    A(STORGRP criterion)
         L     R3,STORGRP_List_Hdr_Count-STORGRP_List_Hdr(R1) Get nbr
         AHI   R1,STORGRP_List_Ent-STORGRP_List     and point to 1st
D00230   DS    0H
         MVC   @D_SMS_Temp_StorGrp,2(R15) Move STORGRP
         OC    @D_SMS_Temp_StorGrp,STORGRP_List_Ent_Mask-STORGRP_List_E+
               nt(R1)                   Reset wildcards
         CLC   @D_SMS_Temp_StorGrp,STORGRP_List_Ent_STORGRP-STORGRP_Lis+
               t_Ent(R1)                Our Storage group?
         JE    D00240                   We want it, skip
         AHI   R1,STORGRP_List_Ent_Length Bump to next entry
         BRCT  R3,D00230                and try again
         J     D00480                   Not here, skip this UCB

D00240   DS    0H
*---------------------------------------------------------------------*
*     This seems to be a volume in which we are interested. Bump the  *
*    count of volumes eligible to be included in the table ...        *
*---------------------------------------------------------------------*
         L     R15,@D_Volume_Count      Get current count
         AHI   R15,1                    Bump it
         ST    R15,@D_Volume_Count      Save it

*---------------------------------------------------------------------*
*     ... get a pointer to the next free entry in our table, ...      *
*---------------------------------------------------------------------*
         LA    R1,@D_Parms              A(Parm list)
         BRAS  R14,W00010               Get A(Next entry in VolTbl)
         LTR   R15,R15                  Did we get one?
         JNZ   D00480                   No, don't update it then

*---------------------------------------------------------------------*
*     ... bump the count of vol entries in the table ...              *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    D00480                   Nothing, skip
         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Get curr count
         AHI   R0,1                     Bump it
         ST    R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Save it

*---------------------------------------------------------------------*
*     ... add this UCB to our table, and format some info about it.   *
*---------------------------------------------------------------------*
         LR    R9,R1                    Get A(Free entry)
         USING VolTbl_Ent,R9

         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line
         MVC   VolTbl_Ent_UCBCopy,@D_UCB Move UCB Copy
         MVC   VolTbl_Ent_DCECopy,@D_DCE Move DCE Copy

*---------------------------------------------------------------------*
*     If we will be displaying detail lines, format what we           *
*    currently have available                                         *
*---------------------------------------------------------------------*
         TM    @_No_Details,L'@_No_Details Producing detail lines?
         JO    D00470                    No, skip the formatting stuff

         MVC   VolTbl_Ent_DevAddr,@D_UCBNAME Readable device address
         MVC   VolTbl_Ent_DevType,=CL8' ' Clear device type

*---------------------------------------------------------------------*
*   Format the device type and model, using SYS1.$UCLEUS(IECDI$IT@, *
*    CSECT IECDDE)T.                                                  *
*     This is an undocumented CSECT, but its format seems to be:      *
*      DS    XL1        DCEOBRDT/UCBTBYT4                             *
*        DS    XL1        ??                                          *
*        DS    CL8        Device Type in EBCDIC                       *
*                                                                     *
*    There are generic device entries (i.e 3380, 3390@, where the 1st *
*    byte matches UCBTBYT4, and specific entries (i.e. 3380K. 33909@  *
*    where the 1st byte matches DCEOBRDT. We try to identify emulated *
*    devices by finding entries matching both UCBTBYT4 and DCEOBRDT;  *
*    if the non-blank portion of the UCBTBYT4 entry does not match the*
*    DCEOBRDT entry, we assume we have an emulated device, and use    *
*    the UCBTBYT4 device type, suffixed with "*E*".                   *
*                                                                     *
*     If we use the DCEOBRDT entry, we format it, if required, by     *
*    inserting, if required, a dash(-@ after the 4th character if     *
*    there is at least 1 trailing blank.                              * *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@D_IECDDEVT_Ptr A(IECDDEVT)?
         JZ    D00240C                   Not yet, skip

*---------------------------------------------------------------------*
*    If this device is the same as the previous one in the table,     *
*    merely copy the device type                                      *
*---------------------------------------------------------------------*
         LA    R15,VolTbl_Ent            A(Our entry)
         AHI   R15,-VolTbl_Ent_Len       A(Previous entry)
         CLC   VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB(L'UCBTBYT4),VolTbl_Ent+
               _UCBCopy+UCBTBYT4-UCBOB-VolTbl_Ent(R15)
         JNE   D00250                    Not same, check IECDDEVT
         CLC   VolTbl_Ent_DCECopy+DCEOBRDT-DCE(L'DCEOBRDT),VolTbl_Ent_D+
               CECopy+DCEOBRDT-DCE-VolTbl_Ent(R15)
         JNE   D00250                    Not same, check IECDDEVT
         MVC   VolTbl_Ent_DevType,VolTbl_Ent_DevType-VolTbl_Ent(R15)
         J     D00280                    and skip
D00240C  DS    0H
         NUCLKUP BYNAME,                 Not yet, look it up           +
               NAME='IECDDEVT',           this CSECT                   +
               ADDR=(0)                   return address here
         LTR   R15,R15                   Did we get it?
         JZ    D00240E                   Yes, OK
         LA    R0,1                      No, set invalid address
D00240E  DS    0H
         ST    R0,@D_IECDDEVT_Ptr        Yes, save the address
         LR    R1,R0                     and load up
D00250   DS    0H
         TM    @D_IECDDEVT_Ptr+3,X'01'   Is it a valid address?
         JO    D00280                    No, skip device type
         SLR   R14,R14                   Clear A(UCBTBYT4 entry)
         SLR   R15,R15                   Clear A(DCEOBRDT entry)
D00250A  DS    0H
         CLI   0(R1),X'00'               End of table?
         JE    D00280                    Yes, no device type
         LTR   R14,R14                   Found UCBTBYT4 already?
         JNZ   D00250C                   Yes, skip
         CLC   0(L'UCBTBYT4,R1),VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Us?
         JNE   D00250C                   No, skip
         LA    R14,2(0,R1)               Yes, save the address
         J     D00250E                   and skip
D00250C  DS    0H
         LTR   R15,R15                   Found DCEOBRDT entry?
         JNZ   D00250E                   Yes, skip
         CLC   0(L'DCEOBRDT,R1),VolTbl_Ent_DCECopy+DCEOBRDT-DCE Us?
         JNE   D00250E                   No, skip
         LA    R15,2(0,R1)               Yes, save the address
D00250E  DS    0H
         LTR   R14,R14                   Found UCBTBYT4 entry?
         JZ    D00250G                   No, keep checking
         LTR   R15,R15                   Yes, got DCEOBRDT entry too?
         JNZ   D00260                    Yes, all done
D00250G  DS    0H
         AHI   R1,10                     A(Next entry)
         J     D00250A                   and check it out
D00260   DS    0H
         LA    R1,7(0,R14)               A(End of UCBTBYT4 entry
D00260C  DS    0H
         CLI   0(R1),C' '                End of device type?
         JNE   D00260E                   Yes, skip
         AHI   R1,-1                     No, back up a byte
         J     D00260C                   and keep checking
D00260E  DS    0H
         SR    R1,R14                    EX length of compare
         EX    R1,D_CLC                  Compare entries
         JE    D00260G                   Equal, use DCEOBRDT
         MVC   VolTbl_Ent_DevType,0(R14) Move UCBTBYT4 device type
         CLC   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-3(3),=CL8' '
         JNE   D00280                    No room for flag, skip
         LA    R1,VolTbl_Ent_DevType(R1) Point to last char
         MVC   1(3,R1),=C'*E*'           Say it's emulated
         J     D00280                    and skip

D00260G  DS    0H
         MVC   VolTbl_Ent_DevType,0(R15) Move DCEOBRDT device type
         CLI   VolTbl_Ent_DevType+4,C' ' 4-char dev type?
         JE    D00280                    Yes, all done
         CLI   VolTbl_Ent_DevType+4,C'-' Already formatted?
         JE    D00280                    Yes, all done
         CLI   VolTbl_Ent_DevType+L'VolTbl_Ent_DevType-1,C' ' Trail sp?
         JNE   D00280                    No, skip formatting
         MVC   VolTbl_Ent_DevType+5(L'VolTbl_Ent_DevType-5),4(R15)
*                                        Make room for a dash
         MVI   VolTbl_Ent_DevType+4,C'-' and insert it


D00280   DS    0H
*---------------------------------------------------------------------*
*     Format the Volser, and the Mount attribute ...                  *
*---------------------------------------------------------------------*
         MVC   VolTbl_Ent_Volser,VolTbl_Ent_UCBCOPY+UCBVOLI-UCBOB

         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS SMS?
         JZ    D00290                    Not SMS, skip
         MVC   VolTbl_Ent_Attrib,=C'SMS' Say so
         J     D00320                    and skip

D00290   DS    0H
         TM    VolTbl_Ent_UCBCOPY+UCBSTAB-UCBOB,UCBBPRV Private?
         JZ    D00300                    No, skip
         MVC   VolTbl_Ent_Attrib,=C'Pvt' Yes, say so
         J     D00320                    and skip
D00300   DS    0H
         TM    VolTbl_Ent_UCBCopy+UCBSTAB-UCBOB,UCBBPUB Public?
         JZ    D00310                    No, skip
         MVC   VolTbl_Ent_Attrib,=C'Pub' Yes, say so
         J     D00320                    and skip
D00310   DS    0H
         MVC   VolTbl_Ent_Attrib,=C'Stg' Indicate Storage
D00320   DS    0H
*---------------------------------------------------------------------*
*     Get the CHPIDs for this device using UCBINFO PATHINFO ...       *
*---------------------------------------------------------------------*
         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)
         LHI   R15,8                    Max nbr we can use
D00320C  DS    0H
         MVC   0(2,R1),=C'--'           Init CHPID value
         AHI   R1,4                     Bump pointer
         BRCT  R15,D00320C              and do them all

         UCBINFO PATHINFO,              Get path info                  +
               DEVN=VolTbl_Ent_UCBCOPY+UCBCHAN-UCBOB, for this device  +
               PATHAREA=@D_UCBINFO_Data, in here                       +
               MF=(E,@D_UCBINFO)        staying re-entrant

         LTR   R15,R15                  Anything good happen?
         JNZ   D00370                   No, skip

*---------------------------------------------------------------------*
*     ... and format them, flagging those that are unavailable        *
*---------------------------------------------------------------------*
         LA    R15,@D_UCBINFO_Data      Address of PATHINFO data
         L     R14,@D_UCBINFO_Data+PATH#CHPIDS-PATH Nbr CHPIDS
         CHI   R14,8                    Too many?
         JNH   D00330                   No, OK
         LHI   R14,8                    Yes, only use 1st 8
D00330   DS    0H
         LA    R15,@D_UCBINFO_Data+PATHCHPIDARRAY-PATH A(1st CHP entry)
         LA    R1,VolTbl_Ent_CHPIDs     A(Output area)
D00340   DS    0H
         LH    R0,PATHCHPID-PATHCHPIDARRAY(R15) Get CHPID
         SLL   R0,4                     Make room for sign
         ST    R0,@D_DBLWD+4            Save it
         OI    @D_DBLWD+7,X'0F'         Add a sign
         UNPK  @D_DBLWD(3),@D_DBLWD+6(2) Unpack it
         TR    @D_DBLWD+1(2),D_TRTAB     Make it readable
         MVC   0(2,R1),@D_DBLWD+1       Move CHPID
         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHPAM  Physically avail?
         JO    D00350                   Yes, skip
         MVI   2(R1),C'$'               No, mark it
         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag
         J     D00360                   Skip
D00350   DS    0H
         TM    PATHBITS-PATHCHPIDARRAY(R15),PATHLPM  Logically avail?
         JO    D00360                   Yes, skip
         MVI   2(R1),C'-'               No, mark it
         OI    @D_CHPID_Unavail,L'@D_CHPID_Unavail and set our flag
         J     D00360                   Skip
D00360   DS    0H
         AHI   R1,4                     Bump pointer
         AHI   R15,L'PATHCHPIDARRAY     Point to next CHPID
         BRCT  R14,D00340               and try again

D00370   DS    0H
*---------------------------------------------------------------------*
*     If this is an SMS UCB, set up the Storage Group Name and SMS    *
*    status.                                                          *
*---------------------------------------------------------------------*
         TM    VolTbl_Ent_UCBCopy+UCBFL5-UCBOB,UCBSMS SMS?
         JNO   D00460                  No, skip

         TM    @D_SMS_Ptrs_OK,L'@D_SMS_Ptrs_OK Do we already have it?
         JO    D00380                  Yes, skip

         TM    @D_SMS_Unavail,L'@D_SMS_Unavail Is SMS there?
         JO    D00460                  No, skip

         LA    R15,VolTbl_Ent_Volser   A(Volser)
         ST    R15,@D_Parms_T00010     Save it
         LA    R15,@D_VLD_Anchor       A(VLD Anchor)
         ST    R15,@D_Parms_T00010+4   Save it

         LA    R1,@D_Parms              A(Parm list)
         BRAS  R14,T00010              Go get Storgrp, status

         STM   R0,R1,@D_SMS_Ptrs       Save the results
         CHI   R15,4                   How did it go?
         JL    D00380                  OK, skip
         JE    D00460                  STORGRP not found, skip this vol
         OI    @D_SMS_Unavail,L'@D_SMS_Unavail No SMS, set flag
         J     D00460                  and skip this vol

D00380   DS    0H
         L     R15,@D_SMS_Ptrs+4             A(STORGRP Len, name)
         LH    R14,0(0,R15)                  Get len of STORGRP
         LHI   R0,L'VolTbl_Ent_SMS_StorGrp   Len of output field
         CR    R14,R0                        Too big?
         JNH   D00390                        No, OK
         LR    R14,R0                        Yes, reset it
D00390   DS    0H
         AHI   R14,-1                        EX Length
         AHI   R15,2                         A(STORGRP)
         LA    R1,VolTbl_Ent_SMS_StorGrp     A(Target field)
         EX    R14,D_MVC

         ICM   R15,B'1111',@D_SMS_Ptrs       A(SMS Status)
         JZ    D00450                        None, we don't know

         CLI   0(R15),VLD0                   Any status?
         JNE   D00400                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'None'
         J     D00470                        and skip
D00400   DS    0H
         CLI   0(R15),VLDENBL                Enabled?
         JNE   D00410                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Enabl+
               ed'
         J     D00470                        and skip
D00410   DS    0H
         CLI   0(R15),VLDQUI                 Quiesced/All?
         JNE   D00420                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+
               ced/All'
         J     D00470                        and skip
D00420   DS    0H
         CLI   0(R15),VLDQUIN                Quiesced/New?
         JNE   D00430                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Quies+
               ced/New'
         J     D00470                        and skip
D00430   DS    0H
         CLI   0(R15),VLDDIS                 Disabled/All?
         JNE   D00440                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+
               led/All'
         J     D00470                        and skip
D00440   DS    0H
         CLI   0(R15),VLDDISN                Disabled/New?
         JNE   D00450                        No, skip
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Disab+
               led/New'
         J     D00470                        and skip
D00450   DS    0H
         MVC   VolTbl_Ent_SMS_Status,=CL(L'VolTbl_Ent_SMS_Status)'Unkno+
               wn'
         J     D00470                        and skip
D00460   DS    0H
         MVC   VolTbl_Ent_SMS_StorGrp(3),=C'N/A' Move literal
         MVC   VolTbl_Ent_SMS_Status(3),=C'N/A' and again
         J     D00470                        and skip

D00470   DS    0H
*---------------------------------------------------------------------*
*     If we are not going to be doing LSPACEs, mark this entry as     *
*    complete ...                                                     *
*---------------------------------------------------------------------*
         TM    @_No_LSPACE,L'@_No_LSPACE     Doing LSPACE?
         JNO   D00480                        Yes, skip
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed
         OI    VolTbl_Ent_ECB,X'40'          'POST' as complete

D00480   DS    0H
*---------------------------------------------------------------------*
*     ... and go get the next UCB, unless we are doing a single       *
*    volser                                                           *
*---------------------------------------------------------------------*
         TM    @D_Single_Volser,L'@D_Single_Volser  Specific volser?
         JO    D00490                   Yes, no need to keep checking
         J     D00050                   No, do next UCB

D00490   DS    0H
*---------------------------------------------------------------------*
*     Check to see if we found any UCBs                               *
*---------------------------------------------------------------------*
         ICM   R0,B'1111',@D_Volume_Count Any UCBs?
         JNZ   D00540                   Yes, skip

*---------------------------------------------------------------------*
*   We couldn't find any UCBs - if we are selecting by UCB number,    *
*  the user may have assumed a 3-byte UCB address, and we have been   *
*  looking for 4-byte addresses. If this is the case, we add a '0'    *
*  in front of the UCB address, and do all this again. We limit the   *
*  re-iterations based on the entered UCB mask(s) - for example, we   *
*  will reiterate for UCB(x??), but not for UCB(x???).                *
*                                                                     *
*   We assume (big mistake!) that the user has been consistent in     *
*  specifying 3-digit UCBs in both UCB and XUCB - when we adjust an   *
*  entry in UCB_List, if there is a subset of it in XUCB_List, we     *
*  adjust it too.                                                     *
*---------------------------------------------------------------------*
         TM    @D_Eligible_UCB_Found,L'@D_Eligible_UCB_Found Any UCBs?
         JO    D00540                   Yes, skip
         ICM   R1,B'1111',@_UCB_List_Ptr A(UCB selection list)
         JZ    D00540                   None, skip
         NI    @D_UCB_Addr_Updated,X'FF'-L'@D_UCB_Addr_Updated

         ICM   R3,B'1111',UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Nbr UCBs
         JZ    D00540                   None, skip
         AHI   R1,UCB_List_Ent-UCB_List  Point to 1st
D00500   DS    0H
         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R1),X+
               'FF'                     Trailing wildcard?
         JNE   D00530                   No, skip
         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R1),L'@D_UCBNAME Adj?
         JNL   D00530                   No, skip
         LA    R0,0                     Yes, clear work reg
         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len
         AHI   R0,1                     Bump it
         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R1) Entered len
         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Get the UCB
         ST    R0,@D_DBLWD              Save it
         SRL   R0,8                     Shift over 1 byte
         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R1) Save it
         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R1),C'0'  Leading 0
         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Get wildcard mask
         SRL   R0,8                     Shift it right too
         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R1) Save it as well
         OI    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated UCB changed
         ICM   R4,B'1111',@_XUCB_List_Ptr A(Excluded UCBs)
         JZ    D00530                   None, skip

         L     R5,UCB_List_Hdr_Count-UCB_List_Hdr(R4)  Count of UCBs
         AHI   R4,UCB_List_Ent-UCB_List  Point to 1st
D00510   DS    0H
         CLI   UCB_List_Ent_UCB+L'UCB_List_Ent_UCB-1-UCB_List_Ent(R4),X+
               'FF'                     Trailing wildcard?
         JNE   D00520                   No, skip
         CLI   UCB_List_Ent_UCB_Len-UCB_List_Ent(R4),L'@D_UCBNAME Adj?
         JNL   D00520                   No, skip
         LA    R0,0                     Yes, clear work reg
         IC    R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len
         AHI   R0,1                     Bump it
         STC   R0,UCB_List_Ent_UCB_Len-UCB_List_Ent(R4) Entered len
         L     R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Yes, get UCB
         ST    R0,@D_DBLWD+4            Save it
         OC    @D_DBLWD+4(L'UCB_List_Ent_UCB),UCB_List_Ent_Mask-UCB_Lis+
               t_Ent(R1)                Reset wildcard characters
         CLC   @D_DBLWD(L'UCB_List_Ent_UCB),@D_DBLWD+4  Subset of Incl?
         JNE   D00520                   No, skip
         SRL   R0,8                     Shift over 1 byte
         ST    R0,UCB_List_Ent_UCB-UCB_List_Ent(R4) Save it
         MVI   UCB_List_Ent_UCB-UCB_List_Ent(R4),C'0'  Leading 0
         L     R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Get wildcard mask
         SRL   R0,8                     Shift it right too
         ST    R0,UCB_List_Ent_Mask-UCB_List_Ent(R4) Save it as well

D00520   DS    0H
         AHI   R4,UCB_List_Ent_Length   Bump to next entry
         BRCT  R5,D00510                and process it

D00530   DS    0H
         AHI   R1,UCB_List_Ent_Length   Bump to next entry
         BRCT  R3,D00500                and process it

         TM    @D_UCB_Addr_Updated,L'@D_UCB_Addr_Updated Any changes?
         JO    D00040                   Yes, try again

D00540   DS    0H
*---------------------------------------------------------------------*
*     We have finished all our UCBs; update the total eligible vol    *
*    count, and, if no entries, flag it as complete ...               *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    D00800                   Nothing, skip
         L     R0,@D_Volume_Count       Total eligible volumes
         ST    R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)

         ICM   R0,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Any?
         JZ    D00790                   No, POST table as complete

*---------------------------------------------------------------------*
*     ... and, if we are doing totals, create and populate (as much   *
*    as we can) the Totals line ...                                   *
*---------------------------------------------------------------------*
         TM    @_No_Totals,L'@_No_Totals Doing Totals?
         JO    D00590                   No, skip

         LA    R1,@D_Parms              A(Parm list)
         BRAS  R14,W00010               A(Next free entry)
         LTR   R15,R15                  Did we get one?
         JNZ   D00590                   No, skip
         LR    R9,R1                    Yes, point to it

         L     R15,@_VolTbl_Ptr          A(VolTbl)
         SR    R1,R15                    Offset of Totals Line
         ST    R1,VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Save it

         OI    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line
         L     R15,@_VolTbl_Ptr          A(VolTbl)
         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Nbr vols
         CVD   R0,@D_DBLWD               Pack it
         MVC   VolTbl_Ent_DevType(7),=X'4020206B202120' Move mask
         ED    VolTbl_Ent_DevType(7),@D_DBLWD+5 Edit in count

         ICM   R1,B'1111',@_XVol_List_Ptr Excluding by vol?
         JNZ   D00550                   Yes, leave volser blank
         ICM   R1,B'1111',@_Vol_List_Ptr No, selecting by vol?
         JZ    D00550                   No, set vol to asterisks
         CLC   =FL4'1',4(R1)            Yes, a single volser?
         JNE   D00550                   No, leave volser blank
         MVC   VolTbl_Ent_Volser,8(R1)  Yes, move volser mask
         TR    VolTbl_Ent_Volser,D_TrTbl and Xlate X'FF' to '*'
         J     D00550                   and skip

D00550   DS    0H
         ICM   R1,B'1111',@_XUCB_List_Ptr Excluding by UCB?
         JNZ   D00560                   Yes, leave UCB blank
         ICM   R1,B'1111',@_UCB_List_Ptr No, selecting by UCB?
         JZ    D00560                   No, set UCB to asterisks
         L     R0,UCB_List_Hdr_Count-UCB_List_Hdr(R1)  Get Nbr masks
         C     R0,=FL4'1'               A single UCB?
         JNE   D00560                   No, leave UCB blank
         AHI   R1,UCB_List_Ent-UCB_List Yes, point to it
         MVC   VolTbl_Ent_DevAddr,UCB_List_Ent_UCB-UCB_List_Ent(R1)
         TR    VolTbl_Ent_DevAddr,D_TrTbl and Xlate X'FF' to '*'
         J     D00560                   and skip

D00560   DS    0H
         MVC   VolTbl_Ent_Attrib,=CL8' ' No attributes

         ICM   R1,B'1111',@_STORGRP_List_Ptr Selecting by StorGrp?
         JZ    D00570                   No, skip
         CLC   =FL4'1',4(R1)            Yes, a single STORGRP?
         JNE   D00570                   No, leave blank
         MVC   VolTbl_Ent_SMS_StorGrp,8(R1) Yes, move mask
         TR    VolTbl_Ent_SMS_StorGrp,D_TrTbl and Xlate X'FF' to '*'
         J     D00570                   and skip

D00570   DS    0H
*---------------------------------------------------------------------*
*     If a CHPID was not physically or logically available, put out   *
*    a message in the CHPID area of the totals line.                  *
*---------------------------------------------------------------------*
         TM    @D_CHPID_Unavail,L'@D_CHPID_Unavail  CHPIDs OK?
         JNO   D00580                   Yes, OK
         MVC   VolTbl_Ent_CHPIDs(L'D_CHPID_Msg),D_CHPID_Msg No, msg

D00580   DS    0H
*---------------------------------------------------------------------*
*     If we will not be doing LSPACEs, mark the Totals line as        *
*    complete                                                         *
*---------------------------------------------------------------------*
         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?
         JNO   D00590                   Yes, OK
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed
         OI    VolTbl_Ent_ECB,X'40'     and POST as complete

D00590   DS    0H
*---------------------------------------------------------------------*
*     If we will be doing LSPACEs, get a line for the SMS Anomaly     *
*    message                                                          *
*---------------------------------------------------------------------*
         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?
         JO    D00600                   No, skip

         LA    R1,@D_Parms              A(Parm list)
         BRAS  R14,W00010               A(Next entry in VolTbl)
         LTR   R15,R15                  Did we get one?
         JNZ   D00600                   No, skip
         LR    R9,R1                    Yes, point to it

         L     R15,@_VolTbl_Ptr          A(VolTbl)
         SR    R1,R15                    Offset of SMS Anomaly Line
         ST    R1,VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) Clear offset

         OI    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line
         OI    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly

D00600   DS    0H
*---------------------------------------------------------------------*
*     Get processor-related data                                      *
*---------------------------------------------------------------------*
         XC    @_LP_Count,@_LP_Count    Make sure LP Count is 0
         MVI   @D_CSRSI_Manuf,C' '      Clear Manufacturer ID
         MVC   @D_CSRSI_Manuf+1(L'@D_CSRSI_Manuf-1),@D_CSRSI_Manuf
         MVC   @D_CSRSI_Type,@D_CSRSI_Manuf Clear Type
         MVC   @D_CSRSI_Model,@D_CSRSI_Manuf Clear Model
         MVC   @D_CSRSI_Serial,@D_CSRSI_Manuf Clear Serial

         L     R15,CVTPTR               A(CVT)
         TM    CVTDCB-CVT(R15),CVTOSEXT Is OSLVL OK?
         JZ    D00600Z                  No, crawl through control blks
         TM    CVTOSLV4-CVT(R15),CVTCSRSI Yes, can we use CSRSI?
         JZ    D00600Z                  No, use control blocks

*---------------------------------------------------------------------*
*     We will be using CSRSI to get the processor-related data - go   *
*    build the parm list ...                                          *
*---------------------------------------------------------------------*
         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data

         BASR  R2,0
         USING (*,D00600_End-1),R2
         STORAGE OBTAIN,                Go get some storage            +
               LENGTH=(0)                this long
D00600_End DS  0H
         ST    R1,@D_CSRSI_Parm+8       Save A(Info area)
         LA    R15,=AL4(CSRSI_REQUEST_V1CPC_MACHINE+CSRSI_REQUEST_V2CPC+
               _LPAR+CSRSI_REQUEST_V3CPC_VM) All data requested
         ST    R15,@D_CSRSI_Parm        Save request code
         LA    R15,=AL4(SIV1V2V3_Len)   A(Length of Info area)
         ST    R15,@D_CSRSI_Parm+4      Save length in parm list
         LA    R15,@D_DBLWD             A(Return code area)
         ST    R15,@D_DBLWD+4           Save it
         LA    R15,@D_DBLWD+4           A(Return code area pointer)
         ST    R15,@D_CSRSI_Parm+12     Save in parm list

*---------------------------------------------------------------------*
*     ... and issue CSRSI                                             *
*---------------------------------------------------------------------*
         BASR  R2,0
         USING (*,D00600A_End-1),R2
         LOAD  EP=CSRSI                 Go get machine info module
D00600A_End DS  0H
         LTR   R15,R15                  Did it work
         JNZ   D00600X                  No, skip
         LR    R15,R0                   Yes, save EP
         LA    R1,@D_CSRSI_Parm         A(Parmlist)
         BASR  R14,R15                  Go do it
         DELETE EP=CSRSI                Don't need CSRSI anymore
         L     R15,@D_DBLWD             Get CSRSI return code
         CHI   R15,CSRSI_STSINOTAVAILABLE Did we get anything?
         JH    D00600X                  No, skip

*---------------------------------------------------------------------*
*     We seem to have some valid data back from CSRSI, so save the    *
*    bits we need.                                                    *
*---------------------------------------------------------------------*
         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)
         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI11V1 V1 valid?
         JZ    D00600C                  No, skip
         A     R15,=AL4(SI00_LEN)       Yes, bump to V1 Data area
         MVC   @D_CSRSI_Manuf,SI11V1CPCMANUFACTURER-SI11V1(R15)
         MVC   @D_CSRSI_Type,SI11V1CPCTYPE-SI11V1(R15)
         MVC   @D_CSRSI_Model,SI11V1CPCMODEL-SI11V1(R15)
         MVC   @D_CSRSI_Serial,SI11V1CPCSEQUENCECODE+L'SI11V1CPCSEQUENC+
               ECODE-L'@D_CSRSI_Serial-SI11V1(R15)
D00600C  DS    0H
         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)
         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V3 VM valid?
         JZ    D00600E                  No, skip
         A     R15,=AL4(SIV1V2_LEN)     Yes, bump to VM Data area
         LA    R0,0                     Clear work reg
         IC    R0,SI22V3DBCOUNTFIELD-SI22V3(0,R15) Nbr V3 Desc Blks
         SLL   R0,28                    Clean
         SRL   R0,28                     it
         AHI   R0,-1                    Relative to 0
         MH    R0,=AL2(SI22V3DB_LEN)    Offset of last
         LA    R15,SI22V3DBS-SI22V3(0,R15) Point to first
         ALR   R15,R0                   and then to last
         LH    R0,SI22V3DBCONFIGUREDLCPUCOUNT-SI22V3DB(R15) LCPUs
         ST    R0,@_LP_Count            Save it
         J     D00600X                  and skip
D00600E  DS    0H
         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)
         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V2 LPAR valid?
         JZ    D00600G                  No, skip
         A     R15,=AL4(SIV1_LEN)       Yes, bump to LPAR Data area
         LH    R0,SI22V2CONFIGUREDLCPUCOUNT-SI22V2(R15) LCPUs
         ST    R0,@_LP_Count            Save it
         J     D00600X                  and skip
D00600G  DS    0H
         L     R15,@D_CSRSI_Parm+8      A(CSRSI Data)
         TM    SI00VALIDITYFLAGS-SI00(R15),SI00VALIDSI22V1 Mach OK?
         JZ    D00600X                  No, skip
         A     R15,=AL4(SI00_LEN+SI11V1_LEN) Bump to CPC Data area
         LH    R0,SI22V1CONFIGUREDCPUCOUNT-SI22V1(R15) CPUs
         ST    R0,@_LP_Count            Save it
         J     D00600X                  and skip

D00600X  DS    0H
         L     R0,=AL4(SIV1V2V3_LEN)    Length of return data
         L     R1,@D_CSRSI_Parm+8       A(Start)

         BASR  R2,0
         USING (*,D00600X_End-1),R2
         STORAGE RELEASE,               Free CSRSI storage             +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
D00600X_End DS  0H

         LA    R15,0                    Clear work reg
         ST    R15,@D_CSRSI_Parm+4      Clear storage length
         ST    R15,@D_CSRSI_Parm+8         and address

D00600Z  DS    0H
*---------------------------------------------------------------------*
*     We will be crawling through control blocks to get the processor *
*    related info. Get the CPU-type data (Type, model, etc.)          *
*---------------------------------------------------------------------*
         CLI   @D_CSRSI_Manuf,C' '       Do we have CPU Data?
         JNE   D00608                    Yes, skip
         L     R15,CVTPTR                No, A(CVT)
         L     R15,CVTHID-CVT(R15)       A(Host ID Table)
         TM    CPCND_FLAGS-SHID(R15),CPCND_INVAL OK?
         JO    D00602                    No, skip type info
         MVC   @D_CSRSI_Manuf(L'CPCND_MAN),CPCND_MAN-SHID(R15)
         MVC   @D_CSRSI_Type(L'CPCND_TYPE),CPCND_TYPE-SHID(R15)
         MVC   @D_CSRSI_Model(L'CPCND_MODEL),CPCND_MODEL-SHID(R15)
D00602   DS    0H
         L     R15,CVTPTR                A(CVT)
         L     R15,CVTPCCAT-CVT(R15)     A(PCCA Table)
         LHI   R14,16                    Max of 16 CPUs
D00604   DS    0H
         ICM   R0,B'1111',0(R15)         Get A(PCCA) for this CPU
         JNZ   D00606                    CPU Active, skip
         AHI   R15,4                     No, point to next
         BRCT  R14,D00604                and check again
         J     D00608                    None(?), ignore it
D00606   DS    0H
         LR    R15,R0                    Point to PCCA
         MVC   @D_CSRSI_Serial,PCCACPID+4-PCCA(R15)  Serial number

D00608   DS    0H
*---------------------------------------------------------------------*
*     Go get the number of CPUs, if required                          *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_LP_Count    Do we have an LP count?
         JNZ   D00625                   Yes, skip
         L     R15,CVTPTR               A(CVT)
         L     R15,CVTLCCAT-CVT(R15)    A(LCCAVT)
         LHI   R14,16                   Max number of CPUs
         LA    R1,0                     Count of CPUs
D00610   DS    0H
         ICM   R0,B'1111',0(R15)        Get A(LCCA) for this CPU
         JZ    D00620                   None, skip
         AHI   R1,1                     OK, bump CPU count
D00620   DS    0H
         AHI   R15,4                    Bump to next LCCA pointer
         BRCT  R14,D00610               and check it out
         ST    R1,@_LP_Count            Save it

D00625   DS    0H
*---------------------------------------------------------------------*
*     ... and initialize @_SubTask_Count to either MAXTASKS or        *
*      MIN(Volumes, (2*#_Logical_Processors)+1)                       *
*---------------------------------------------------------------------*
         LH    R0,@_MaxTasks            Get MaxTasks specification
         LTR   R0,R0                    Any?
         JP    D00630                   Yes, skip
         LR    R0,R1                    No, use #LPs
         SLL   R0,1                      doubled
         AHI   R0,1                      + 1
D00630   DS    0H
         AIF   (&Max_SubTask_Count LT 1).Max_SubTask_Count_020
         CHI   R0,&Max_SubTask_Count    Is it > max?
         JNH   D00630C                  No, OK
         LHI   R0,&Max_SubTask_Count    Yes, use max
D00630C  DS    0H
.Max_SubTask_Count_020 ANOP
         ST    R0,@_SubTask_Count       and update it

         LA    R0,0                     Clear UCB count
         ICM   R9,B'1111',@_VolTbl_Ptr A(Table of Volumes)
         JZ    D00650                   None, skip
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count
         JZ    D00650                   None, skip
         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry
D00640   DS    0H
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line UCB?
         JNO   D00640C                  Not Detail line, skip
         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?
         JO    D00640C                  Not really a UCB, skip
         AHI   R0,1                     Bump UCB count
D00640C  DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,D00640               and check again

D00650   DS    0H
*---------------------------------------------------------------------*
*     Use the lesser of UCB count and @_SubTask_Count for our         *
*    number of subtasks                                               *
*---------------------------------------------------------------------*
         C     R0,@_SubTask_Count       Check against nbr subtasks
         JNL   D00660                   OK, skip
         ST    R0,@_SubTask_Count       Too few UCBs, use UCB count

D00660   DS    0H
*---------------------------------------------------------------------*
*     If we will be doing Statistics, ...                             *
*---------------------------------------------------------------------*
         TM    @_Statistics,L'@_Statistics Doing stats?
         JNO   D00780                    No, skip

*---------------------------------------------------------------------*
*    ... move the non-execution-related stats lines ...               *
*---------------------------------------------------------------------*
         LA    R2,D_Stats_Line_Ptrs      A(Start of line pointers)
         SLR   R3,R3                     Clear count
D00660C  DS    0H
         LA    R1,@D_Parms               A(Parm list)
         BRAS  R14,W00010                Get A(Next entry)
         LTR   R15,R15                   Did we get one?
         JNZ   D00780                    No, skip
         LR    R9,R1                     Yes, point to it
         L     R15,0(0,R2)               A(Stats line)
         LH    R14,0(0,R15)              Get length of stats line
         AHI   R14,-1                    EX len
         EX    R14,D_MVC1                Move it

         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line
         OI    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Mark as done
         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done
         OI    VolTbl_Ent_ECB,X'40'      POST as done

         AHI   R3,1                      Bump count
         CHI   R3,3                      1st execution line?
         JNE   D00680E                   No, skip


         MVC   @D_TIME,D_TIME           Move L-Form of macro
         TIME  DEC,                     Get time                       +
               @D_Time_Area,             and return it here            +
               LINKAGE=SYSTEM,           don't use the SVC             +
               DATETYPE=YYYYMMDD,        format of returned data       +
               MF=(E,@D_TIME)            addr of macro list
         L     R0,@D_Time_Area          Get the time
         SRL   R0,12                    Shift out seconds and 100s
         ST    R0,@D_Time_Area          Save it
         OI    @D_Time_Area+3,X'0F'     OR in a sign
         MVC   @D_WkArea(7),=X'402120204B2020' Time mask
         ED    @D_WkArea(7),@D_Time_Area+1 Make it readable
         MVC   VolTbl_Ent_Display+D_Stats_Line3_Time-D_Stats_Line3(L'D_+
               Stats_Line3_Time),@D_WkArea+2
         L     R15,@D_Time_Area+8       Get Date (yyyymmdd)
         LA    R14,0                    Clear work register
         SLDL  R14,4                    Make room for sign
         STM   R14,R15,@D_Time_Area     Save it
         OI    @D_Time_Area+7,X'0F'     OR in a sign
         MVC   @D_WkArea(12),=X'402120202020602020602020'  Date mask
         ED    @D_WkArea(12),@D_Time_Area+3 Make it readable
         MVC   VolTbl_Ent_Display+D_Stats_Line3_Date-D_Stats_Line3(L'D_+
               Stats_Line3_Date),@D_WkArea+2

         L     R14,CVTPTR               A(CVT)
         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)
         MVC   VolTbl_Ent_Display+D_Stats_Line3_SysVer-D_Stats_Line3(L'+
               ECVTPNAM),ECVTPNAM-ECVT(R15)
         LA    R1,VolTbl_Ent_Display+D_Stats_Line3_SysVer+L'ECVTPNAM-1-+
               D_Stats_Line3           A(Last char)
         LA    R0,VolTbl_Ent_Display+D_Stats_Line3_SYSVer-D_Stats_Line3
D00670   DS    0H
         CLI   0(R1),C' '               Last significant character
         JNE   D00680                   Yes, skip
         S     R1,=FL4'1'               No, back up a byte
         CR    R1,R0                    Too far?
         JH    D00670                   No, check again
D00680   DS    0H
         AIF   (NOT D'CVTZOSE).D00680_010
         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?
         JZ    D00680C                  No, skip
         MVC   1(2,R1),=C'.e'           Yes, say so
         LA    R1,2(0,R1)               and bump pointer
D00680C  DS    0H
.D00680_010 ANOP
         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version
         MVI   2+L'ECVTPVER(R1),C'.'    Separator
         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel
         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator
         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+
               (R15)

D00680E  DS    0H
         CHI   R3,4                      2nd execution stats line?
         JNE   D00750C                   No, skip

         L     R15,CVTPTR                A(CVT)
         MVC   VolTbl_Ent_Display+D_Stats_Line4_SNAME-D_Stats_Line4(L'C+
               VTSNAME),CVTSNAME-CVT(R15)
         LA    R1,VolTbl_Ent_Display+D_Stats_Line4_SNAME+L'CVTSNAME-1-D+
               _Stats_Line4              A(Last char)
D00690   DS    0H
         CLI   0(R1),C' '                Trailing Blank?
         JNE   D00700                    No, skip
         S     R1,=FL4'1'                Yes, back up a byte
         J     D00690                    and try again
D00700   DS    0H
         MVI   2(R1),C'('                Open paren
         AHI   R1,3                      Point to next byte
         MVC   0(L'@D_CSRSI_Manuf,R1),@D_CSRSI_Manuf Move manufacturer
         LA    R1,L'@D_CSRSI_Manuf-1(0,R1) A(Last character)
D00702   DS    0H
         CLI   0(R1),C' '                Trailing blank?
         JNE   D00704                    No, OK
         BRCT  R1,D00702                 Yes, back up a byte
D00704   DS    0H
         MVI   1(R1),C' '                Move separator
         MVC   2(L'@D_CSRSI_Type,R1),@D_CSRSI_Type
         MVI   2+L'@D_CSRSI_Type(R1),C'-' Separator
         MVC   2+L'@D_CSRSI_Type+1(L'@D_CSRSI_Model,R1),@D_CSRSI_Model
         LA    R1,2+L'@D_CSRSI_Type+L'@D_CSRSI_Model(0,R1)
D00706   DS    0H
         CLI   0(R1),C' '                Trailing blank?
         JNE   D00708                    No, OK
         BRCT  R1,D00706                 Yes, back up and check again
D00708   DS    0H
         MVC   1(8,R1),=C', CPUID '      Literal
         MVC   9(L'@D_CSRSI_Serial,R1),@D_CSRSI_Serial
         MVI   9+L'@D_CSRSI_Serial(R1),C')'  Trailing paren
         LA    R1,10+L'@D_CSRSI_Serial(0,R1) A(Next byte)

D00740   DS    0H
         MVC   0(5,R1),=C' with'         Start of literal
         AHI   R1,5                      A(Next byte)
         TM    @_OW48527,L'@_OW48527     APAR OW48527 on?
         JO    D00750                    Yes, skip
         MVC   0(3,R1),=C'out'           No, say so
         AHI   R1,3                      A(Next byte)
D00750   DS    0H
         MVC   0(9,R1),=C' OW48527.'     Finish it off

D00750C  DS    0H
         CHI   R3,D_Stats_Line_Count     Any more to do?
         JNL   D00750E                   No, skip
         AHI   R2,4                      Yes, bump to next pointer
         J     D00660C                   and go do it

D00750E  DS    0H
*-------------------------------------------------------------------*
*    ... 2 more for the Stack statistics ...                        *
*-------------------------------------------------------------------*
         LA    R1,@D_Parms               A(Parm list)
         BRAS  R14,W00010                Get A(Next entry)
         LTR   R15,R15                   Did we get one?
         JNZ   D00780                    No, skip
         LR    R9,R1                     Yes, point to it

         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line
         OI    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack

         LA    R1,@D_Parms               A(Parm list)
         BRAS  R14,W00010                Get A(Next entry)
         LTR   R15,R15                   Did we get one?
         JNZ   D00780                    No, skip
         LR    R9,R1                     Yes, point to it

         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line
         OI    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack

*-------------------------------------------------------------------*
*    ... and 1 more for the CPU time.                               *
*-------------------------------------------------------------------*
         LA    R1,@D_Parms               A(Parm list)
         BRAS  R14,W00010                Get A(Next entry)
         LTR   R15,R15                   Did we get one?
         JNZ   D00780                    No, skip
         LR    R9,R1                     Yes, point to it

         OI    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line
         OI    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime

*---------------------------------------------------------------------*
*   If we are doing LSPACEs, get enough lines for the subtask         *
*  heading(s) and stats lines                                         *
*---------------------------------------------------------------------*
         TM    @_No_LSPACE,L'@_No_LSPACE Doing LSPACEs?
         JO    D00780                   No, skip subtask stuff

         L     R8,@_SubTask_Count       Get nbr subtasks
         AHI   R8,H_SubTask_Hdg_Count   Plus nbr heading lines
         SR    R3,R3                    Clear offset

D00760   DS    0H
         LA    R1,@D_Parms               A(Parm list)
         BRAS  R14,W00010                Get A(Next entry)
         LTR   R15,R15                   Did we get one?
         JNZ   D00780                    No, skip
         OI    VolTbl_Ent_Stats_Line-VolTbl_Ent(R1),L'VolTbl_Ent_Stats_+
               Line
         LTR   R3,R3                     Have we saved the offset?
         JNZ   D00770                    Yes, skip
         L     R15,@_VolTbl_Ptr          A(VolTbl)
         LR    R3,R1                     A(1st heading line)
         SR    R3,R15                    Offset of SubTask heading
         ST    R3,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) Save it
D00770   DS    0H

         BRCT  R8,D00760                 And do it again

D00780   DS    0H
*---------------------------------------------------------------------*
*     If we will not be doing LSPACEs ...                             *
*---------------------------------------------------------------------*
         TM    @_No_LSPACE,L'@_No_LSPACE  Doing LSPACE?
         JNO   D00800                   Yes, skip

D00790   DS    0H
*---------------------------------------------------------------------*
*     ... all volumes have been processed, and the table is complete. *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr No, A(VolTbl)
         JZ    D00800                   None, skip
         L     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         ST    R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15)
         OI    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' POST table complete

D00800   DS    0H
*---------------------------------------------------------------------*
*     Free up the esoteric table, if there is one ...                 *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@D_UNITA      A(Unit Table)
         JZ    D00810                   None, skip
         L     R0,0(0,R1)               Get its length

         BASR  R2,0
         USING (*,D00800_End-1),R2
         STORAGE RELEASE,               Free the old table             +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
D00800_End DS  0H
         DROP  R2

         LA    R15,0                    Clear work register
         ST    R15,@D_UNITA             and clear A(Unit table)

D00810   DS    0H
*---------------------------------------------------------------------*
*     ... and the VLDs, if there are any.                             *
*---------------------------------------------------------------------*
         LA    R15,0                   Clear work reg
         ST    R15,@D_Parms_T00010     No volser
         LA    R15,@D_VLD_Anchor       A(Anchor)
         ST    R15,@D_Parms_T00010+4   No volser
         LA    R1,@D_Parms              A(Parm list)
         BRAS  R14,T00010               Go free VLDs

*---------------------------------------------------------------------*
*     If we have found any UCBs, exit with a return code of 0         *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr Any VolTbl?
         JZ    D80010                   No, exit with error
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) Vols?
         JZ    D80010                   No, exit with error
         LA    R15,0                    Clear return code
         J     D90010                   and exit

D80010   DS    0H
*---------------------------------------------------------------------*
*   We couldnt find any UCBs - set the return code and exit           *
*---------------------------------------------------------------------*
         LA    R15,4                    No UCBs returned
         J     D90010                   and exit

D90010   DS    0H
*---------------------------------------------------------------------*
*    Free up our local storage ...                                    *
*---------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@D_Dynam              A(Local storage)
         L     R2,@D_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

D_Literals  DS  0H

D_MVC    MVC   0(0,R1),0(R15)           Move STORGRP
D_MVC1   MVC   VolTbl_Ent_Display(0),2(R15)  Move Stats line

D_CLC    CLC   0(0,R14),0(R15)          UCBTBYT4 vs DCEOBRDT

D_TrTbl  DC    256AL1(*-D_TrTbl)
         ORG   D_TrTbl+X'FF'
         DC    C'*'
         ORG   ,

D_TRTAB  EQU   *-X'F0'
         DC    C'0123456789ABCDEF'

D_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +
               MF=L                      keep ourselves reentrant
D_TIME_Length  EQU *-D_TIME


D_CHPID_Msg  DC CL(L'VolTbl_Ent_CHPIDs)' $:Phys unavail, -:Log unavail'

D_Stats_Line_Ptrs     EQU   *
                      DC    AL4(D_Stats_Line1-2)
                      DC    AL4(D_Stats_Line2-2)
                      DC    AL4(D_Stats_Line3-2)
                      DC    AL4(D_Stats_Line4-2)
                      DC    AL4(D_Stats_Line5-2)
                      DC    AL4(D_Stats_Line6-2)
                      DC    AL4(D_Stats_Line7-2)
                      DC    AL4(D_Stats_Line8-2)
                      DC    AL4(D_Stats_Line9-2)
                      DC    AL4(D_Stats_Line10-2)
                      DC    AL4(D_Stats_Line11-2)
D_Stats_Line_Count    EQU   (*-D_Stats_Line_Ptrs)/4

                      DC    AL2(D_Stats_Line1_End-D_Stats_Line1)
D_Stats_Line1         EQU   *
                      DC    C'&PGMNAME '
                      DC    C'&VERSION'
                      DC    C' '
D_Stats_Line1_Data    EQU   *
                      DC    C'assembled on '
                      DC    C'&ASMDT'
                      DC    C' at '
                      DC    C'&ASMTM'
                      DC    C' under '
                      DC    C'&SYSTEM_ID'
D_Stats_Line1_End     EQU   *

                      DC    AL2(D_Stats_Line2_End-D_Stats_Line2)
D_Stats_Line2         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C'with '
                      DC    C'&SYSASM'
                      DC    C' '
                      DC    C'&SYSVER'
                      DC    C'.'
D_Stats_Line2_End     EQU   *

                      DC    AL2(D_Stats_Line3_End-D_Stats_Line3)
D_Stats_Line3         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C'executing on '
D_Stats_Line3_Date    DC    CL10' '
                      DC    C' at '
D_Stats_Line3_Time    DC    CL5' '
                      DC    C' under '
D_Stats_Line3_SysVer  DC    CL(L'ECVTPNAM+2+1+L'ECVTPVER+1+L'ECVTPREL+1+
               +L'ECVTPMOD)' '
D_Stats_Line3_End     EQU   *

                      DC    AL2(D_Stats_Line4_End-D_Stats_Line4)
D_Stats_Line4         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C'on '
D_Stats_Line4_SNAME   DC    CL(L'CVTSNAME)' '
                      DC    C' '
                      DC    CL(12+L'CPCND_MAN+L'CPCND_TYPE+L'CPCND_MODE+
               L)' '
D_Stats_Line4_End     EQU   *

                      DC    AL2(D_Stats_Line5_End-D_Stats_Line5)
D_Stats_Line5         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C'Installation Defaults'
D_Stats_Line5_End     EQU   *

                      DC    AL2(D_Stats_Line6_End-D_Stats_Line6)
D_Stats_Line6         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' ISPF Output by default      : '
         AIF   (&ISPF_by_Default).D_Stats_Line6_010
                      DC    C'N'
         AGO   .D_Stats_Line6_020
.D_Stats_Line6_010  ANOP
                      DC    C'Y'
.D_Stats_Line6_020  ANOP
D_Stats_Line6_End     EQU   *

                      DC    AL2(D_Stats_Line7_End-D_Stats_Line7)
D_Stats_Line7         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' ISPF Output type            : '
                      DC    C'&ISPF_Default_Type'
D_Stats_Line7_End     EQU   *

                      DC    AL2(D_Stats_Line8_End-D_Stats_Line8)
D_Stats_Line8         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' Max LSPACE Wait (Foreground): '
         AIF   (&Fore_LSPACE_Wait EQ 0).D_Stats_Line8_010
                      DC    C'&Fore_LSPACE_Wait'
                      DC    C' secs.'
         AGO   .D_Stats_Line8_020
.D_Stats_Line8_010  ANOP
                      DC    C'None'
.D_Stats_Line8_020  ANOP
D_Stats_Line8_End     EQU   *

                      DC    AL2(D_Stats_Line9_End-D_Stats_Line9)
D_Stats_Line9         EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' Max LSPACE Wait (Background): '
         AIF   (&Back_LSPACE_Wait EQ 0).D_Stats_Line9_010
                      DC    C'&Back_LSPACE_Wait'
                      DC    C' secs.'
         AGO   .D_Stats_Line9_020
.D_Stats_Line9_010  ANOP
                      DC    C'None'
.D_Stats_Line9_020  ANOP
D_Stats_Line9_End     EQU   *

                      DC    AL2(D_Stats_Line10_End-D_Stats_Line10)
D_Stats_Line10        EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' Default number of SubTasks  : '
         AIF   (&Default_SubTask_Count EQ 0).D_Stats_Line10_010
                      DC    C'&Default_SubTask_Count'
         AGO   .D_Stats_Line10_020
.D_Stats_Line10_010 ANOP
                      DC    C'Dynamic'
.D_Stats_Line10_020 ANOP
D_Stats_Line10_End    EQU   *

                      DC    AL2(D_Stats_Line11_End-D_Stats_Line11)
D_Stats_Line11        EQU   *
                      DC    CL(D_Stats_Line1_Data-D_Stats_Line1)' '
                      DC    C' Maximum number of SubTasks  : '
         AIF   (&Max_SubTask_Count EQ 0).D_Stats_Line11_010
                      DC    C'&Max_SubTask_Count'
         AGO   .D_Stats_Line11_020
.D_Stats_Line11_010 ANOP
                      DC    C'None'
.D_Stats_Line11_020 ANOP
D_Stats_Line11_End    EQU   *


         LTORG

D_Literals_End  DS  0H

@D_Dynam                  DSECT       Dynamic area for D00000
                          DS    18F    O/S Style save area
@D_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@D_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)
@D_DBLWD                  DS    D      Doubleword work area
@D_WkArea                 DS    CL12   EDit Word Area
@D_UCBNAME                DS    CL4    UCB name
@D_UNITA                  DS    AL4    A(UCB Table from EDTINFO
@D_Volume_Count           DS    FL4    Nbr vols in the table
@D_IECDDEVT_Ptr           DS    AL4    A(SYS1.NUCLEUS(IECDDEVT))
@D_VLD_Anchor             DS    DL8    A(Start of SMS SG VLDs)
@D_SMS_Ptrs               DS    2AL4   A(STORGRP, SMS Status)
@D_R00010_Word            DS    FL4    A word for R00010
                          DS    X      Flag byte
@D_Eligible_UCB_Found     EQU   *-1,X'80' 1... .... At least 1 UCB
@D_UCB_Addr_Updated       EQU   *-1,X'40' .1.. .... 4 --> 3 byte addr
@D_Single_Volser          EQU   *-1,X'20' ..1. .... Specific Volser
@D_SMS_Unavail            EQU   *-1,X'10' ...1 .... SMS not available
@D_SMS_Ptrs_OK            EQU   *-1,X'08' .... 1... SMS data valid
@D_CHPID_Unavail          EQU   *-1,X'04' .... .1.. CHP unavail
                          DS    0F     Alignment
@D_IOCT                   DS    CL48   IOC Token area for UCBSCAN

                          DS    0F      Alignment
@D_UCBSCAN_WorkArea       DS    CL100   UCBSCAN Work Area
                          ORG   @D_UCBSCAN_WorkArea
@D_CSRSI_Manuf            DS    CL(L'SI11V1CPCMANUFACTURER)
@D_CSRSI_Type             DS    CL(L'SI11V1CPCTYPE)
@D_CSRSI_Model            DS    CL(L'SI11V1CPCMODEL)
@D_CSRSI_Serial           DS    CL4
                          ORG   ,

@D_Macro                  DS    0D     Macros
                          EDTINFO MF=(L,@D_EDTINFO) EDTINFO L-Form
                          ORG   @D_Macro
                          IOCINFO MF=(L,@D_IOCINFO) IOCINFO L-Form
                          ORG   @D_Macro
                          UCBINFO MF=(L,@D_UCBINFO)
@D_UCBINFO_Data           DS    XL256
                          ORG   @D_Macro
                          UCBSCAN MF=(L,@D_UCBSCAN) UCBSCAN L-Form
                          DS    0F     Alignment
@D_UCB                    DS    XL48   UCB Copy from UCBSCAN
                          DS    0F     Alignment
@D_DCE_Length             DS    XL2    DCE Area length
@D_DCE                    DS    XL48   DCE Copy from UCBSCAN
                          ORG   @D_Macro
@D_SMS_Temp_StorGrp       DS    CL(L'VLDSTGRP)
                          ORG   @D_Macro
@D_TIME                   DS    CL(D_TIME_Length)   TIME Macro area
                          DS    0D
@D_Time_Area              DS    XL16   Data returned by TIME
                          ORG   @D_Macro
                          DS    0F
@D_CSRSI_Parm             DS    4FL4   Parms for CSRSI
                          ORG   ,      End of Macros

@D_Parms                  DS    0F     Parms for called rtns
@D_Parms_Std              DS    3AL4    Standard 3 parms
@D_Parms_Extra            EQU   *       Extra parms
@D_Parms_R00010           DS    5AL4       for R00010
                          ORG   @D_Parms_Extra
@D_Parms_T00010           DS    2AL4       for T00010
                          ORG   ,
                          DS    0D          Alignment
@D_Dynam_Length           EQU   *-@D_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'E00010: Manage LSPACE SubTasks'
         PUSH  USING

E00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : E00010                                                 *
*                                                                     *
*  Abstract  : ATTACH and DETACH LSPACE Subtasks (H00010)             *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - No valid LSPACE data retrieved                *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1997/05/16 SDDA030 - ATTACHed subtasks to issue LSPACE *
*                                   so that we don't wait forever for *
*                                   devices that are constantly busy. *
*              1998/09/17 SDDA030 - V2.0                              *
*                                 - Corrected logic error where some  *
*                                   STIMERMs were not being CANCELled *
*                                 - Used Compare-and-Swap in pseudo-  *
*                                   POST processing, rather than      *
*                                   blindly ORing POST bit if no WAIT *
*                                   was present (E00390).             *
*                                 - Moved STIMERMs from this routine  *
*                                   To H00010.                        *
*                                 - Pass A(Volume Table) to H00010    *
*                                   rather than individual entries    *
*                                   within the table.                 *
*              1999/03/03 SDDA030 - V2.5                              *
*                                 - Added Version and Assembly info   *
*                                   to statistics display             *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*              1999/07/30 SDDA030 - V2.7                              *
*                                 - Added SubTask CPU time to         *
*                                   statistics display                *
*              1999/08/20 SDDA030 - V2.8                              *
*                                 - Added SubTask Wait time to        *
*                                   statistics display                *
*              1999/09/01 SDDA030 - V2.9                              *
*                                 - Passed totals fields as part of   *
*                                   SubTask_Area, and totalled them   *
*                                   after all subtasks complete.      *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Inserted total volume count in the*
*                                   Totals line                       *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Created stats line for 24-bit     *
*                                   stack.                            *
*                                 - Reserved space for the Stack stats*
*                                   lines, but deferred filling in    *
*                                   values until they get output, in  *
*                                   F00010.                           *
*              2000/05/23 SDDA030 - V2.12                             *
*                                 - Removed code that worried about   *
*                                   subtasks that timed out.          *
*                                 - Trimmed parm list passed to H00010*
*                                 - Updated Stats lines to remove     *
*                                   WAIT time data, and replace with  *
*                                   APF authorization msg.            *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Reset Parm list passed to H00010  *
*                                 - Re-added WAIT stuff to stats line.*
*                                 - Added IKJEFTSR re-invocation if   *
*                                   we are not APFd.                  *
*                                 - Moved CPU used stuff to V00010.   *
*                                 - Made ourselves non-swappable while*
*                                   daughter tasks active.            *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Added VTOCIX and Frag Index info. *
*                                 - Added call to U0010 to format     *
*                                   detail and total lines.           *
*                                 - Issue WAIT for @_MaxTasks ECBs,   *
*                                   rather than for 1 ECB.            *
*                                 - Acquired H00010 work area from the*
*                                   stack.                            *
*              2001/11/12 SDDA030 - V2.15                             *
*                                   Passed STIMERM Wait time factor   *
*                                   (based on #SubTasks/#LPs) to      *
*                                   H00010.                           *
*                                 - Checked Assembler version when    *
*                                   generating our assembly time      *
*                                   stamp.                            *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - If we will be using only 1 subtask*
*                                   BASR rather than ATTACH           *
*                                 - Used E_Stats_Line2 to verify that *
*                                   IKJEFTSR invoked the same version *
*                                   as was originally invoked.        *
*              2002/06/11 SDDA030 - V2.18                             *
*                                 - If OW48527 installed, don't WAIT  *
*                                   for subtasks to terminate         *
*                                 - Moved various fields passed to    *
*                                   subtasks into VolTbl              *
*              2002/08/08 SDDA030 - V2.19                             *
*                                 - If we can't dispatch subtasks,    *
*                                   POST entries and table as done.   *
*              2003/01/16 SDDA030 - V2.20                             *
*                                 - Correct bug when eliminating sub- *
*                                   task stats if we aren't APF'd.    *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Always ATTACH with ECB=, DETACH   *
*                                   done in S00010.                   *
*                                 - BRAS instead of ATTACHX H00010 if *
*                                   only 1 vol, instead of only 1     *
*                                   subtask.                          *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - IDENTIFY H00010 with a unique name*
*                                   (based on TCB address) so we can  *
*                                   run multiple copies simultaneously*
*                                 - Used standardized calling sequence*
*              ____/__/__ _______ -                                   *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,E_Literals           Point to our literals
         USING (E_Literals,E_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@E_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@E_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @E_Dynam,R13             Assign a base
         L     R15,@E_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@E_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@E_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@E_Parms_Std         Save it
         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@E_Parms_Std+4       Save it
         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@E_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*     Check that, in fact, we have something to do.                   *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    E80010                   None, exit with error
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JZ    E80010                   No volumes, exit with error
         TM    @_No_LSPACE,L'@_No_LSPACE Yes, should we issue LSPACEs?
         JO    E00230                   No, all done

         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?
         JO    E00100                   Yes, OK

*---------------------------------------------------------------------*
*     We must be APF-Authorized to do our stuff. If we aren't, we     *
*    re-invoke ourselves via IKJEFTSR (unless we are currently        *
*    running as an IKJEFTSR invocation).                              *
*---------------------------------------------------------------------*
         TESTAUTH FCTN=1                Check APF Authorization
         LTR   R15,R15                  Are we?
         JNZ   E00020                   No, skip
         TM    @_IKJEFTSR,L'@_IKJEFTSR  Yes, IKJEFTSR'd?
         JZ    E00100                   No, OK

*---------------------------------------------------------------------*
*     We are APF'd and invoked under IKJEFTSR. Check to make sure     *
*    that the code we are executing (under IKJEFTSR, which LOADs from *
*    STEPLIB/LNKLST) is the same as was originally invoked as a       *
*    command (possibly from ISPLLIB), using the time of assembly.     *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_IKJEFTSR_TimeStamp_Ptr A(Callers timestmp)
         JZ    E00010C                  Nothing, error
         CLC   E_IKJEFTSR_TimeStamp(E_IKJEFTSR_TimeStamp_Length),0(R15)
         JE    E00100                   Same as ours, OK
E00010C  DS    0H
         OI    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err No, flag as an error
         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl Incomplete
         J     E80010                   and go produce stats

E00020   DS    0H
         TM    @_IKJEFTSR,L'@_IKJEFTSR  Are we running from IKJEFTSR?
         JZ    E00030                   No, skip
         OI    @_No_APF,L'@_No_APF      Yes, still not authorized
         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl incomplete
         J     E80010                   and go produce totals and stats

E00030   DS    0H
*---------------------------------------------------------------------*
*     We are not APF'd, and not running as a result of IKJEFTSR, so   *
*    re-invoke ourselves via IKJEFTSR.                                *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
*     Initialize our flags for IKJEFTSR                               *
*---------------------------------------------------------------------*
         LA    R15,E_IKJEFTSR_Flags     Point to our flags
         ST    R15,@E_IKJEFTSR_Parms    Save it

*---------------------------------------------------------------------*
*     Use the program name as found from the PRB.                     *
*---------------------------------------------------------------------*
         L     R14,PSATNEW-PSA(0)       Get A(our TCB)
         SLL   R14,8                    Clean
         SRL   R14,8                      it
         L     R15,TCBRBP-TCB(R14)      A(RB)
E00050   DS    0H
         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)
         SLL   R0,8                     Clean
         SRL   R0,8                       it
         CR    R0,R14                   Last RB (RBLINK = A(TCB))?
         JE    E00060                   Yes, skip
         LR    R15,R0                   No, point to previous RB
         J     E00050                   and keep trying
E00060   DS    0H
         LA    R14,0                    Get pointer to
         ICM   R14,B'0111',RBCDE1-RBBASIC(R15)  our CDE
         MVC   @E_IKJEFTSR_PgmName,CDNAME-CDENTRY(R14)  Move pgm name
         LA    R15,@E_IKJEFTSR_PgmName  A(Program name)
         ST    R15,@E_IKJEFTSR_Parms+4  Save it

*---------------------------------------------------------------------*
*     Length of the program name                                      *
*---------------------------------------------------------------------*
         LA    R15,@E_IKJEFTSR_PgmName+L'@E_IKJEFTSR_PgmName-1
E00070   DS    0H
         CLI   0(R15),C' '              Trailing blank?
         JNE   E00080                   No, skip
         BRCT  R15,E00070               Yes, keep checking
E00080   DS    0H
         LA    R14,@E_IKJEFTSR_PgmName-1 Calculate length
         SR    R15,R14                   of program name
         ST    R15,@E_IKJEFTSR_PgmName_Length  Save it
         LA    R15,@E_IKJEFTSR_PgmName_Length A(Length)
         ST    R15,@E_IKJEFTSR_Parms+8   Save it

*---------------------------------------------------------------------*
*     Pointers to the Return Code, Reason Code and ABEND Code areas.  *
*---------------------------------------------------------------------*
         LA    R15,@_IKJEFTSR_RC        A(Return Code Area)
         ST    R15,@E_IKJEFTSR_Parms+12  Save it

         LA    R15,@_IKJEFTSR_Reas      A(Reason Code Area)
         ST    R15,@E_IKJEFTSR_Parms+16  Save it

         LA    R15,@E_IKJEFTSR_ABEND     A(ABEND Code Area)
         ST    R15,@E_IKJEFTSR_Parms+20  Save it

*---------------------------------------------------------------------*
*     Pointers to the parms we will be passing to ourselves           *
*---------------------------------------------------------------------*
         LA    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs A(Parms for the Pgm)
         ST    R15,@E_IKJEFTSR_Parms+24  Save it
         OI    @E_IKJEFTSR_Parms+24,X'80' Flag as last parm

         LA    R15,@E_IKJEFTSR_Pgm_Parm1 A(Pgm Parm 1) - A(@_Dynam)
         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs Save it

*---------------------------------------------------------------------*
*     Point to our timestamp, which contains the assembly date,       *
*    time and version. This will be used by the version of SPACE      *
*    invoked by IKJEFTSR to ensure that the same code is running.     *
*---------------------------------------------------------------------*
         LA    R15,E_IKJEFTSR_TimeStamp A(Interesting assembly stats)
         ST    R15,@_IKJEFTSR_TimeStamp_Ptr Save it

*---------------------------------------------------------------------*
*     And finally the parms themselves:                               *
*       HL2'4',AL4(@_Dynam)                                           *
*       HL2'16',1st 16 bytes of @_Dynam                               *
*---------------------------------------------------------------------*
         LHI   R15,4                    Length of an address
         STH   R15,@E_IKJEFTSR_Pgm_Parm1 Save it
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@E_IKJEFTSR_Pgm_Parm1+2 Save it

         LA    R15,@E_IKJEFTSR_Pgm_Parm2 A(Pgm Parm 1) - A(@_Dynam)
         ST    R15,@E_IKJEFTSR_Pgm_Parm_Ptrs+4 Save it
         OI    @E_IKJEFTSR_Pgm_Parm_Ptrs+4,X'80'  Last one

         LA    R15,L'@E_IKJEFTSR_Pgm_Parm2-2 Length of data
         STH   R15,@E_IKJEFTSR_Pgm_Parm2 Save it
         MVC   @E_IKJEFTSR_Pgm_Parm2+2(L'@E_IKJEFTSR_Pgm_Parm2-2),@_Dyn+
               am

*---------------------------------------------------------------------*
*     Re-invoke ourselves via IKJEFTSR so that we are (hopefully)     *
*    APF-authorized.                                                  *
*---------------------------------------------------------------------*
         LA    R1,@E_IKJEFTSR_Parms     A(IKJEFTSR Parm List)
         L     R15,CVTPTR               A(CVT)
         L     R15,CVTTVT-CVT(R15)      A(TSVT)
         L     R15,TSVTASF-TSVT(R15)    A(IKJEFTSR)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*     Save the return code from IKJEFTSR, so if something went wrong, *
*    we can tell somebody.                                            *
*---------------------------------------------------------------------*
         ST    R15,@_IKJEFTSR_RC        Save Return Code
         CHI   R15,4                    How did it go?
         JNH   E00090                   OK, skip
         OI    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err  Flag an error
         OI    @_LSPACE_Failed,L'@_LSPACE_Failed VolTbl not filled in
         J     E80010                   and clean up VolTbl
E00090   DS    0H

         LA    R15,0                    Clear return code
         J     E90010                   and exit

E00100   DS    0H
*---------------------------------------------------------------------*
*     OK, now we can start the real work,                             *
*                                                                     *
*     Set up to ATTACH the tasks to actually issue the LSPACE.        *
*    We do this so that if one subtask gets hung up on a RESERVEd     *
*    device, the other subtasks can still retrieve LSPACE info.       *
*                                                                     *
*     First, IDENTIFY the routine (H00010) we will ATTACH ...         *
*---------------------------------------------------------------------*
         L     R15,@_VolTbl_Ptr        A(Volume Table)
         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes
         CHI   R15,1                   Doing more than 1?
         JNH   E00160                  No, no need to IDENTIFY
         L     R0,PSATNEW-PSA(0)       Yes, get A(our TCB)
         SLL   R0,4                    Make room for 'sign'
         ST    R0,@E_DBLWD+4           Save it
         OI    @E_DBLWD+7,X'0F'        Pack it
         UNPK  @E_H00010_IDENTIFY_ID+1(7),@E_DBLWD+4(4) Unpack it
         LA    R15,E_Hex_TrTab         A(Translate Table)
         AHI   R15,-240                adjust it
         TR    @E_H00010_IDENTIFY_ID+1(7),0(R15) Make it readable
         MVI   @E_H00010_IDENTIFY_ID,C'H' Init 1st char
         LARL  R1,H00010               A(Our routine)
         IDENTIFY EPLOC=@E_H00010_IDENTIFY_ID, and let MVS know        +
               ENTRY=(1)                about it

E00160   DS    0H
*---------------------------------------------------------------------*
*    Initialize our timer total, and the number of completed subtasks.*
*    These are used to 'heuristically' set the timer values for the   *
*    STIMERMs used in H00010 ...                                      *
*---------------------------------------------------------------------*
         LA    R0,0                    Clear work register
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    E80010                  Nothing, exit quick smart
         ST    R0,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)
         ST    R0,VolTbl_Hdr_LSPACE_Avg+4-VolTbl_Hdr(R15)

*---------------------------------------------------------------------*
*    Calculate the STIMERM Adjustment factor, based on the ratio of   *
*    SubTasks to Logical Processors - this is used to try to prevent  *
*    false RESERVEd messages when dispatching a lot of subtasks on    *
*    a few LPs (we should really take processor speed and weights     *
*    into account as well, but we don't know how).                    *
*                                                                     *
*    We arbitrarily calculate it as:                                  *
*     ((#Subtasks/#LPs)/4)                                            *
*---------------------------------------------------------------------*
         L     R15,@_SubTask_Count      Get MaxTasks
         LA    R14,0                    Clear other part of dividend
         D     R14,@_LP_Count           Get ratio of Subtasks to LPs
         SRL   R15,2                    divided by 4
         LTR   R15,R15                  Anything?
         JNZ   E00170                   Yes, OK
         LHI   R15,1                    No, default to 1
E00170   DS    0H
         L     R14,@_VolTbl_Ptr         A(VolTbl)
         ST    R15,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R14) Save it

*---------------------------------------------------------------------*
*     Initialize the fields related to LSPACE timeouts                *
*---------------------------------------------------------------------*
         OI    VolTbl_Hdr_OW48527-VolTbl_Hdr(R14),L'VolTbl_Hdr_OW48527
         MVC   VolTbl_Hdr_MaxLWait-VolTbl_Hdr(L'VolTbl_Hdr_MaxLWait,R14+
               ),@_MaxLWait

*---------------------------------------------------------------------*
*     Lower our dispatching priority, so that we can ATTACH our       *
*    subtasks with our original (higher) priority (most of the elap-  *
*    sed time in the subtasks is spent WAITing for LSPACE).           *
*---------------------------------------------------------------------*
         TM    @_CHAP_Done,L'@_CHAP_Done Have we already CHAPped?
         JO    E00170A                  Yes, skip
         CHAP  -1,'S'                   No, do it now
         OI    @_CHAP_Done,L'@_CHAP_Done and set our flag

E00170A  DS    0H
*---------------------------------------------------------------------*
*     ... and get some storage for our ATTACHed tasks, as described   *
*    in the SubTask_Area DSECT.                                       *
*---------------------------------------------------------------------*
         L     R0,@_SubTask_Count       Number of SubTasks
         MHI   R0,SubTask_Area_Ent_Length * length per sub-task
         AHI   R0,SubTask_Area_Hdr_Length + header length

         BASR  R2,0
         USING (*,E00170C_End-1),R2
         STORAGE OBTAIN,                Go get some storage            +
               LENGTH=(0)                this long
E00170C_End DS  0H
         DROP  R2

         ST    R1,@_SubTask_Area_Ptr    Save its address
         ST    R0,SubTask_Area_Hdr_Len-SubTask_Area(R1)  Save length
         L     R0,@_SubTask_Count       Number of SubTasks
         ST    R0,SubTask_Area_Hdr_Count-SubTask_Area(R1) Save #

         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?
         JO    E00170E                  Yes, OK

*---------------------------------------------------------------------*
*    Set ourselves non-swappable - if we are swappable, and we get    *
*   hung up on a RESERVEd volume, SRM will try to swap us out. To do  *
*   do, (s)he must terminate our I/O, and while (s)he is trying to do *
*   this, any asychronous processing (such as STIMERM Exits) will be  *
*   suppressed. In our case, it is the STIMERM Exit that will allow   *
*   the I/O to be terminated, so we have to run non-swappable.        *
*                                                                     *
*    Note that we issue STAX DEFER before we do this (STAX in a       *
*   non-TSO environment seems to be benign).                          *
*---------------------------------------------------------------------*
         MVC   @E_TIME,E_TIME           MOVE Time macro
         TIME  STCK,                    Get the current time           +
               @E_Time_Area,             return it here                +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               MF=(E,@E_TIME)            staying re-entrant
         MVC   @E_NSwap_Start,@E_Time_Area  Save DONTSWAP TOD

         MVC   @E_STAX,E_STAX           Move STAX Macro
         STAX  DEFER=YES,               Defer Attentions               +
               MF=(E,@E_STAX)            staying re-entrant

         SYSEVENT DONTSWAP              Make ourselves non-swappable

E00170E  DS    0H
*---------------------------------------------------------------------*
*     Point to our ECBLIST area ...                                   *
*---------------------------------------------------------------------*
         L     R10,@_SubTask_Area_Ptr   A(SubTask_Area)
         AHI   R10,SubTask_Area_Hdr_Length Point past header
         L     R8,@_SubTask_Count       Get number we have to do

*---------------------------------------------------------------------*
*    ... initialize the area for each sub-task ...                    *
*---------------------------------------------------------------------*
E00180   DS    0H
         XC    0(SubTask_Area_Ent_Length,R10),0(R10)  Clear entry

*---------------------------------------------------------------------*
*    ... set up the parm list for the subtask ...                     *
*---------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)
         L     R15,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,SubTask_Area_Ent_Parms+4-SubTask_Area_Ent(R10)
         L     R15,@E_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,SubTask_Area_Ent_Parms+8-SubTask_Area_Ent(R10)
         L     R15,@_VolTbl_Ptr          A(VolTbl)
         ST    R15,SubTask_Area_Ent_Parms+12-SubTask_Area_Ent(R10)

         LA    R1,SubTask_Area_Ent_Parms-SubTask_Area_Ent(R10)

*---------------------------------------------------------------------*
*    ... and ATTACH (or BASR, if we are doing only 1 volume).         *
*---------------------------------------------------------------------*
         L     R15,@_VolTbl_Ptr         A(Volume Table)
         L     R15,VolTbl_Hdr_Count-VolTbl(R15) Get number of volumes
         CHI   R15,1                    Doing more than 1?
         JH    E00190                   Yes, use ATTACH
         BRAS  R14,H00010               No, just go do it
         OI    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R10),X'40' Done
         LA    R1,0                     Clear 'TCB pointer'
         J     E00200                   and skip

E00190   DS    0H
         MVC   @E_ATTACHX,E_ATTACHX     Move ATTACH parms
         BASR  R2,0
         USING (*,E00190_End-1),R2
         ATTACHX EPLOC=@E_H00010_IDENTIFY_ID,  ATTACH H00010           +
               ECB=(10),                 POST this ECB when complete   +
               SZERO=YES,                Share SubPool 0               +
               ASYNCH=YES,               Allow subtask asynch exits    +
               DPMOD=1,                  Run at a higher priority      +
               MF=(E,(1)),               Parmlist area                 +
               SF=(E,@E_ATTACHX)         keep ourselves reentrant
E00190_End DS  0H
         DROP  R2

E00200   DS    0H
         ST    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R10) A(TCB)

         AHI   R10,SubTask_Area_Ent_Length  A(next sub-task area)
         BRCT  R8,E00180                and continue

         TM    @_OW48527,L'@_OW48527    Yes, is OW48527 present?
         JO    E00230                   Yes, all done

*---------------------------------------------------------------------*
*    WAIT for our H00010 instances to complete                        *
*---------------------------------------------------------------------*
         L     R0,@_SubTask_Count       Nbr ECBs to WAIT for
         CHI   R0,1                     More than 1?
         JNH   E00210                   No, we BASRed, not ATTACHed
         LA    R1,@E_Parms              A(Parms)
         BRAS  R14,S00010               Wait for our subtasks

E00210   DS    0H
*---------------------------------------------------------------------*
*     We are done - make ourselves swappable again ...                *
*---------------------------------------------------------------------*
         SYSEVENT OKSWAP                We can be swapped out now

         MVC   @E_STAX,E_STAX           Move STAX Macro
         STAX  DEFER=NO,                Allow Attentions               +
               MF=(E,@E_STAX)            staying re-entrant

*---------------------------------------------------------------------*
*     ... calculate the time we were non-swappable ...                *
*---------------------------------------------------------------------*
         MVC   @E_TIME,E_TIME           MOVE Time macro
         TIME  STCK,                    Get the current time           +
               @E_Time_Area,             return it here                +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               MF=(E,@E_TIME)            staying re-entrant
         LM    R14,R15,@E_Time_Area     Get current time
         SL    R15,@E_NSwap_Start+4     Calculate
         JNM   E00220                   No borrow, skip
         SL    R14,=FL4'1'              Borrow, reduce
E00220   DS    0H
         SL    R14,@E_NSwap_Start       Calculate
         STM   R14,R15,@_NSwap_Time     Save Non-Swap time

*---------------------------------------------------------------------*
*     ... and exit.                                                   *
*---------------------------------------------------------------------*
         J     E00230                   and skip

E00230   DS    0H
*---------------------------------------------------------------------*
*     Clear the return code, and exit                                 *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     E90010                   and exit

E80010   DS    0H
*---------------------------------------------------------------------*
*   We cannot, or should not, issue LSPACEs, so we will POST all the  *
*  appropriate lines as complete ...                                  *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@_VolTbl_Ptr  A(Table of Volumes)
         JZ    E80016                   Nothing, skip
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count
         JZ    E80016                   None, skip
         AHI   R9,VolTbl_Ent-VolTbl     Point to 1st entry
E80012   DS    0H
         TM    VolTbl_Ent_Stats_31Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+
               ts_31Stack
         JO    E80014                   Stack Stats line, skip it
         TM    VolTbl_Ent_Stats_24Stack-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+
               ts_24Stack
         JO    E80014                   Stack Stats line, skip it
         TM    VolTbl_Ent_Stats_CPUTime-VolTbl_Ent(R9),L'VolTbl_Ent_Sta+
               ts_CPUTime
         JO    E80014                   CPU Stats, skip it

         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R9) Current ECB
         TM    VolTbl_Ent_ECB-VolTbl_Ent(R9),X'80' Anyone WAITing?
         JO    E80013                   Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R9) Pseudo-POST it
         JZ    E80014                   OK, skip the real POST
E80013   DS    0H
         POST  VolTbl_Ent_ECB-VolTbl_Ent(R9),0 POST line as complete

E80014   DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,E80012               and check again

*---------------------------------------------------------------------*
*   ... and if there are any Subtask Stats lines, get rid of them ... *
*---------------------------------------------------------------------*
         L     R15,@_VolTbl_Ptr         A(Volume table)
         ICM   R1,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)
         JZ    E80016                   No SubTask stats, skip
         AHI   R1,-VolTbl_Hdr_Length    Nbr lines
         LA    R0,0                      excluding
         D     R0,=AL4(VolTbl_Ent_Len)   Subtask Stats
         ST    R1,VolTbl_Hdr_Count-VolTbl_Hdr(15) Update nbr lines
         LA    R1,0                      and clear offset
         ST    R1,VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15)

E80016   DS    0H
*---------------------------------------------------------------------*
*   ... POST the table as complete ...                                *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(Table of Volumes)
         JZ    E80018                   None, skip
         L     R0,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Current ECB
         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'80' Anyone WAITing?
         JO    E80017                   Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Hdr_ECB-VolTbl_Hdr(R15) Pseudo-POST it
         JZ    E80018                   OK, skip the real POST
E80017   DS    0H
         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R15),0 POST table as complete

E80018   DS    0H
*---------------------------------------------------------------------*
*   ... and exit with a return code of 4.                             *
*---------------------------------------------------------------------*
         LA    R15,4                    Nothing good happened
         J     E90010                   and exit

E90010   DS    0H
         LR    R3,R15                 Save return code

*-------------------------------------------------------------------*
*    DELETE H00010 (which we IDENTIFYed earlier)                    *
*-------------------------------------------------------------------*
         CLI   @E_H00010_IDENTIFY_ID,C'H'    Did we IDENTIFY?
         JNO   E90020                 No, skip
         DELETE EPLOC=@E_H00010_IDENTIFY_ID  Yes, Un-IDENTIFY
         XC    @E_H00010_IDENTIFY_ID,@E_H00010_IDENTIFY_ID

E90020   DS    0H
*-------------------------------------------------------------------*
*    If we are running under IKJEFTSR, update @_CPU_Time_Used       *
*   with the time we spent (because we are running under a          *
*   separate TCB).                                                  *
*-------------------------------------------------------------------*
         TM    @_OW48527,L'@_OW48527  OW48527 installed?
         JO    E90040                 Yes, skip

         TM    @_IKJEFTSR,L'@_IKJEFTSR Running because of IKJEFTSR?
         JNO   E90040                  No, skip

         TIMEUSED STORADR=@E_DBLWD,     Get CPU time used              +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               CPU=MIC                   get it in microseconds
         LM    R14,R15,@_CPU_Time_Used  Get current CPU Time used
         AL    R15,@E_DBLWD+4           Bump it
         BRC   12,E90030                No Carry, OK
         AL    R14,=FL4'1'              Carry, bump
E90030   DS    0H
         AL    R14,@E_DBLWD             Bump high-order word
         STM   R14,R15,@_CPU_Time_Used  Save CPU Time

E90040   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LA    R1,@E_Dynam              A(Local storage)
         L     R2,@E_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         LR    R15,R3                   Restore return code

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

E_Literals            DS   0H

E_IKJEFTSR_Flags      EQU  *            Flag bytes for IKJEFTSR
                      DC   X'00'         Must be 0
                      DC   X'00'         Invoke in isolated environ
                      DC   X'01'         Dump if abend
                      DC   X'02'         Invoking a program

E_IKJEFTSR_TimeStamp  EQU  *
                      DC   C'&PGMNAME'
                      DC   C'&VERSION'
                      DC   C'&SYSDATC'
                      DC   C'&SYSTIME'
E_IKJEFTSR_TimeStamp_Length EQU *-E_IKJEFTSR_TimeStamp


E_TIME                TIME  LINKAGE=SYSTEM, Get the time               +
               MF=L                      keep ourselves reentrant
E_TIME_Length         EQU *-E_TIME

E_ATTACHX             ATTACHX EP=0,     ATTACH something               +
               ECB=0,                    POST this ECB when complete   +
               SZERO=YES,                Share SubPool 0               +
               ASYNCH=YES,               Allow subtask asynch exits    +
               DPMOD=5,                  Run at a higher priority      +
               SF=L                      keep ourselves reentrant
E_ATTACHX_Length      EQU  *-E_ATTACHX

E_STAX                STAX DEFER=YES, Suspend Attention Interrupts     +
               MF=L                      keep ourselves reentrant
E_STAX_Length         EQU  *-E_STAX

E_Hex_TrTab           DC   C'0123456789ABCDEF'

                      LTORG

E_Literals_End        DS    0H


@E_Dynam                  DSECT        Dynamic area for E00000
                          DS    18F     O/S Style save area
@E_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@E_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@E_DBLWD                  DS    D       Work area

@E_NSwap_Start            DS    DL8     STCK at DONTSWAP

@E_H00010_IDENTIFY_ID     DS    CL8     IDENTIFY Name

@E_Macro                  DS    0D      Macros
@E_TIME                   DS    CL(E_TIME_Length) TIME Macro area
                          DS    0D
@E_Time_Area              DS    XL16     Data returned by TIME
@E_WkArea                 DS    CL10     EDit Word Area
                          ORG   @E_Macro
@E_ATTACHX                DS    CL(E_ATTACHX_Length) ATTACHX Macro area
                          ORG   @E_Macro
@E_STAX                   DS    CL(E_STAX_Length)  STAX Macro area
                          ORG   @E_Macro
@E_IKJEFTSR_Parms         DS    7AL4     Parm List for IKJEFTSR
@E_IKJEFTSR_PgmName       DS    CL8      Program name
@E_IKJEFTSR_PgmName_Length DS   FL4      Program name length
@E_IKJEFTSR_ABEND         DS    FL4      Abend code area
@E_IKJEFTSR_Pgm_Parm_Ptrs DS    2AL4     Pgm parm pointers

@E_IKJEFTSR_Pgm_Parm1     DS    CL6      Len + A(@_Dynam)
@E_IKJEFTSR_Pgm_Parm2     DS    CL18     Len + 16 bytes of @_Dynam
                          ORG   ,       End of Macros

@E_Parms                  DS    0F      Parms for called rtns
@E_Parms_Std              DS    3AL4     Standard 3 parms
                          ORG   ,
                          DS    0D       Alignment
@E_Dynam_Length           EQU   *-@E_Dynam      Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'F00010: Output Results'

         PUSH  USING

F00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : F00010                                                 *
*                                                                     *
*  Abstract  : Display results of LSPACE stuff                        *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0                                                 *
*                                                                     *
*  Notes     : Uses the Info Table built by D00010, and               *
*               whose address is in @_VolTbl_Ptr                      *
*              For ISPF output,                                       *
*                Invoke ISPF processor (G00010)                       *
*              For a TSO Cmd,                                         *
*               PUTLINE for each unit                                 *
*              For a Batch job,                                       *
*               Write to SYSPRINT for each unit                       *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Changed default sort order from   *
*                                   descending volser to none.        *
*                                 - Do STLINENO stuff and build       *
*                                   PUTLINE CBs here instead of C00010*
*                                 - Removed generation of Hdr1-3 in   *
*                                   batch - now done in Y00010.       *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Added SORT() keywords to F_TBLOFF.*
*                                 - Passed sort parms to I00010 as    *
*                                   pointers.                         *
*                                 - Passed sort direction to I00010.  *
*                                   Used 24-bit stack for STLINENO.   *
*                                 - Filled in values in Stack Stats   *
*                                   lines.                            *
*              2000/05/23 SDDA030 - V2.12                             *
*                                 - Added messages for:               *
*                                    - IOSCDR unavailable             *
*                                    - ISPF services unavailable      *
*                                 - Split out ISPF output handling to *
*                                   G00010.                           *
*                                 - Invoked V00010 to update stats    *
*                                   lines.                            *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Removed IOSCDR message            *
*                                 - Added messages for LNKLST and     *
*                                   IJEFTSR errors.                   *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Checked Terminal Line Size when   *
*                                   doing PUTLINEs.                   *
*              2002/06/11 SDDA030 - V2.18                             *
*                                 - WAIT for VolTbl_Ent to be populated
*                                   before outputting                 *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardized calling sequence*
*                                 - Added 'Internal Error' and        *
*                                   'Incompatible OS' messages.       *
*                                 - Added 'Insufficient Storage' msg  *
*              ____/__/__ _______                                     *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,F_Literals           Point to our literals
         USING (F_Literals,F_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@F_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@F_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @F_Dynam,R13             Assign a base
         L     R15,@F_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@F_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@F_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@F_Parms_Std         Save it
         L     R15,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@F_Parms_Std+4       Save it
         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@F_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*   If everything worked OK, but we are suppressing all the output,   *
*  we are done.                                                       *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    F00020                   None, skip
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JZ    F00020                   No volumes, skip
         TM    @_LSPACE_Failed,L'@_LSPACE_Failed LSPACE problem?
         JO    F00020                   Yes, skip
         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN err?
         JO    F00020                   Yes, skip

         TM    @_No_Headings,L'@_No_Headings  Suppressing headings?
         JNO   F00020                   No, skip
         TM    @_No_Details,L'@_No_Details Suppressing detail?
         JNO   F00020                   No, skip
         TM    @_No_Totals,L'@_No_Totals  Suppressing Totals?
         JNO   F00020                   No, skip
         TM    @_Statistics,L'@_Statistics Producing Statistics?
         JO    F00020                   Yes, skip

         LA    R15,0                    Clear return code
         J     F90010                   and exit

F00020   DS    0H
*---------------------------------------------------------------------*
*   If there is anything to display ...                               *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    F00030                   None, skip the sort
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JZ    F00030                   No volumes, skip sort

*---------------------------------------------------------------------*
*   ... sort it, if required.                                         *
*---------------------------------------------------------------------*
         CLI   @_Sort_Field,C' '        Any sort?
         JE    F00030                   No, skip

         LA    R15,@_Sort_Field         A(Sort Field)
         ST    R15,@F_Parms_I00010      Save it
         LA    R15,@_Sort_Direction     A(Sort direction)
         ST    R15,@F_Parms_I00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,I00010               Go sort the table

F00030   DS    0H
*---------------------------------------------------------------------*
*   Set up any applicable error messages                              *
*---------------------------------------------------------------------*
         MVI   @F_ErrMsgL,C' '          Clear msg area
         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL
         MVC   @F_ErrMsgS,@F_ErrMsgL    Short message too

         TM    @_OW48527,L'@_OW48527    APAR OW48527 installed?
         JO    F00060                   Yes, skip IKJEFTSR stuff

         TM    @_No_APF,L'@_No_APF      Are we APF'ed?
         JNO   F00040                   Yes, skip
*---------------------------------------------------------------------*
*     - Insufficient APF                                              *
*       not APFed even when invoked by IKJEFTSR, or IKJEFTSR failed   *
*       with RC=14, Reas=18 or 34                                     *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg02),F_EMsg02 Move APF msg
         J     F00165                   and skip
F00040   DS    0H
         TM    @_IKJEFTSR_Err,L'@_IKJEFTSR_Err IKJEFTSR error?
         JNO   F00050                   No, skip
         L     R15,@_IKJEFTSR_RC        Yes, get IKJEFTSR RC
         CHI   R15,20                   RC = 20?
         JNE   F00045                   No, generic IKJEFTSR error
         L     R15,@_IKJEFTSR_Reas      Yes, get reason code
         CHI   R15,40                   Program not found?
         JNE   F00045                   No, generic IKJEFTSR msg
*---------------------------------------------------------------------*
*     - Not in LNKLST/STEPLIB concatenation                           *
*       IKJEFTSR couldn't find the module (RC=14,Reas=28)             *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg06),F_EMsg06 Move LNKLST msg
         J     F00165                   and skip
F00045   DS    0H
*---------------------------------------------------------------------*
*     - Unknown IKJEFTSR Error xx-yy                                  *
*       Something else from IKJEFTSR xx: return code, yy:reason       *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg07),F_EMsg07 Move message
         L     R15,@_IKJEFTSR_RC        Get ISPF failure return code
         SLL   R15,4                    Make room for the sign
         STH   R15,@F_DBLWD             Save it
         OI    @F_DBLWD+1,X'0F'         Make it packed
         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it
         MVC   @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),@F_DBLWD+3
         TR    @F_ErrMsgL+F_EMsg07_RC-F_EMsg07(2),F_Hex_TrTab

         L     R15,@_IKJEFTSR_Reas      Get ISPF failure reason code
         SLL   R15,4                    Make room for the sign
         STH   R15,@F_DBLWD             Save it
         OI    @F_DBLWD+1,X'0F'         Make it packed
         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it
         MVC   @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),@F_DBLWD+3
         TR    @F_ErrMsgL+F_EMsg07_Reas-F_EMsg07(2),F_Hex_TrTab
         J     F00165                   And skip
F00050   DS    0H
         TM    @_SYSCLOCK_Err,L'@_SYSCLOCK_Err Code mismatch?
         JNO   F00060                   No, skip
*---------------------------------------------------------------------*
*     - TimeStamp mismatch                                            *
*       IKJEFTSR invoked a different version of the code - could be   *
*       caused by this pgm being in ISPLLIB                           *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg09),F_EMsg09
         J     F00165                   and skip
F00060   DS    0H
         TM    @_Internal_Err,L'@_Internal_Err Internal error?
         JNO   F00070                   No, skip
*---------------------------------------------------------------------*
*     - Unrecognized parm (probably on re-invocation via IKJEFTSR)    *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg11),F_EMsg11
         J     F00165                   and skip
F00070   DS    0H
         TM    @_Incompatible_OS,L'@_Incompatible_OS Incompatible?
         JNO   F00110                   No, skip
*---------------------------------------------------------------------*
*     - CSVQUERY function unavailable                                 *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg05),F_EMsg05
         L     R14,CVTPTR               A(CVT)
         L     R15,CVTECVT-CVT(0,R14)   A(EVCT)
         MVC   @F_ErrMsgL+L'F_EMsg05(L'ECVTPNAM),ECVTPNAM-ECVT(R15)
         LA    R1,@F_ErrMsgL+L'F_EMsg05+L'ECVTPNAM-1
         LA    R0,@F_ErrMsgL+L'F_EMsg05
F00080   DS    0H
         CLI   0(R1),C' '               Last significant character
         JNE   F00090                   Yes, skip
         S     R1,=FL4'1'               No, back up a byte
         CR    R1,R0                    Too far?
         JH    F00080                   No, check again
F00090   DS    0H
         TM    CVTOSLV5-CVT(R14),CVTZOSE z/OS.e?
         JZ    F00100                   No, skip
         MVC   1(2,R1),=C'.e'           Yes, say so
         LA    R1,2(0,R1)               and bump pointer
F00100   DS    0H
         MVC   2(L'ECVTPVER,R1),ECVTPVER-ECVT(R15)  Version
         MVI   2+L'ECVTPVER(R1),C'.'    Separator
         MVC   2+L'ECVTPVER+1(L'ECVTPREL,R1),ECVTPREL-ECVT(R15) Rel
         MVI   2+L'ECVTPVER+1+L'ECVTPREL(R1),C'.'    Separator
         MVC   2+L'ECVTPVER+1+L'ECVTPREL+1(L'ECVTPMOD,R1),ECVTPMOD-ECVT+
               (R15)
         J     F00165                   And skip
F00110   DS    0H
         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err GETMAIN?
         JNO   F00150                   No, skip
*---------------------------------------------------------------------*
*     - Insufficient Storage                                          *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgL(L'F_EMsg10),F_EMsg10
         ICM   R15,B'1111',@_VolTbl_Ptr  A(VolTbl)
         JZ    F00165                   None, skip
         L     R0,VolTbl_Hdr_Vols_Eligible-VolTbl_Hdr(R15)
         S     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JP    F00120                   Some omitted, skip
         MVC   @F_ErrMsgL+L'F_EMsg10+1(41),=C'Some totals/statistics li+
               nes may be missing'
         J     F00165                   all done
F00120   DS    0H
         CVD   R0,@F_DBLWD              Pack missing vols
         MVC   @F_ErrMsgL+L'F_EMsg10(10),=X'40206B2020206B202120'
         LA    R1,@F_ErrMsgL+L'F_EMsg10+9 Prime pointer
         LR    R14,R1                  Save it
         EDMK  @F_ErrMsgL+L'F_EMsg10(10),@F_DBLWD+4
         LA    R15,@F_ErrMsgL+L'F_EMsg10+1 Left adjust start
         CR    R1,R15                   Do we need to adjust?
         JNH   F00140                   No, skip
         SR    R14,R1                   Yes, EX len of number
         EX    R14,F_EX1                Left adjust it
         AR    R15,R14                  A(Last char)
F00140   DS    0H
         MVC   1(16,R15),=C' volumes omitted'
         J     F00165                   and skip
F00150   DS    0H
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    F00160                   None, skip
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JNZ   F00170                   Got some data, skip
F00160   DS    0H
*---------------------------------------------------------------------*
*     - VolTbl empty                                                  *
*---------------------------------------------------------------------*
         MVC   @F_ErrMsgS(4),=C'None'   No data
         MVC   @F_ErrMsgL(L'F_EMsg01),F_EMsg01 Move No data msg
         J     F00170                   and skip

F00165   DS    0H
         MVC   @F_ErrMsgS(10),=C'Incomplete' Flag table as incomplete

F00170   DS    0H
         NI    @_ReDisplay,X'FF'-L'@_ReDisplay  Off redisplay flag

*---------------------------------------------------------------------*
*      If output is via ISPF, go do it                                *
*---------------------------------------------------------------------*
         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?
         JO    F00190                   Yes, skip

         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?
         JO    F00180                   Yes, skip
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?
         JO    F00180                   Yes, skip
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?
         JZ    F00190                   No, skip

F00180   DS    0H
         LA    R15,@F_ErrMsgS           A(Short error msg)
         ST    R15,@F_Parms_G00010      Save it
         LA    R15,@F_ErrMsgL           A(Long error msg)
         ST    R15,@F_Parms_G00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,G00010               Go do ISPF stuff

         TM    @_ReDisplay,L'@_ReDisplay Do we need to display again?
         JO    F00170                   Yes, go do it
         LTR   R15,R15                  No, did it work?
         JZ    F90010                   Yes, exit quick smart
         STH   R15,@F_G00010_RC         No, save return code
         STH   R0,@F_G00010_Reas         and reason code

F00190   DS    0H
*---------------------------------------------------------------------*
*      Perform initialization stuff for our environment               *
*---------------------------------------------------------------------*
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    F00240                   No, skip

*---------------------------------------------------------------------*
*   TSO Command Processing - Clear the screen, and build our          *
*  PUTLINE control blocks                                             *
*---------------------------------------------------------------------*
         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack pointer)
         ICM   R0,B'1111',0(R15)        A(24-bit stack)
         JNZ   F00200                   OK, skip

         LHI   R0,@_24Bit_Stack_Length  Length of storage we need
         SSCSTACK INIT,                 Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=24                    below the line

         L     R15,@F_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R1,0(0,R15)              Update it

F00200   DS    0H
         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)
         L     R2,0(0,R2)               A(24-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=F00230_End-F00230,    this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save the address

         LR    R1,R0                    Amount of storage we got
         LR    R0,R3                    Point to it
         LARL  R14,F00230                RMODE24 stuff)
         LHI   R15,F00230_End-F00230    Length of STLINENO stuff
         MVCL  R0,R14                   Move it

         LR    R15,R3                   Point to the RMODE 24 stuff
         BASR  R14,R15                  Go do it

         L     R2,@F_24Bit_Stack_Ptr_Ptr A(24_bit Stack Pointer)
         L     R2,0(0,R2)               A(24-bit Stack)
         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R3),                starting here                 +
               STACK=(R2)                on this stack

*-------------------------------------------------------------------*
*    ... and build the PUTLINE control blocks.                      *
*-------------------------------------------------------------------*
         L     R1,@_CPPL_Ptr            A(CPPL)
         MVC   @F_IOPL+IOPLUPT-IOPL(L'IOPLUPT),CPPLUPT-CPPL(R1)
         MVC   @F_IOPL+IOPLECT-IOPL(L'IOPLECT),CPPLECT-CPPL(R1)
         LA    R15,@F_IOECB             A(Our ECB)
         ST    R15,@F_IOPL+IOPLECB-IOPL Save it
         LA    R15,@F_PLPB              A(PUTLINE Parm block)
         ST    R15,@F_IOPL+IOPLIOPB-IOPL Save it
         MVC   @F_PLPB,F_PLPB           Move PUTLINE Parm Block
         LA    R15,@F_OLD               A(OLD)
         ST    R15,@F_PLPB+4            Save in PLPB
         LA    R15,0                    Clear work reg
         ST    R15,@F_PLPB+8            Clear A(Format line)

         LH    R1,@_LineSize            Get linesize from command line
         LTR   R1,R1                    Anything?
         JNZ   F00210                   Yup, skip
         GTSIZE  ,                      Get terminal line size
         AHI   R1,-1                     minus 1 byte
F00210   DS    0H
         LHI   R15,VolTbl_Ent_Display_Len Max len of data
         LTR   R1,R1                    LINESIZE(MAX)?
         JM    F00220                   Yes, use it
         CR    R15,R1                   Can we display all the data?
         JNH   F00220                   Yes, OK
         LR    R15,R1                   No, display as much as we can
F00220   DS    0H
         AHI   R15,@F_VolTbl_Ent_Copy-@F_OLD Add len of OLD
         STH   R15,@F_OLDLN             Save it
         LA    R15,0                    Clear
         STH   R15,@F_OLDOF              offset
         J     F00270                   and skip

*---------------------------------------------------------------------*
*   This code fragment issues STLINENO. This code is moved to 24-bit  *
*    storage, because the STLINENO SVC must be issued in AMODE 24.    *
*---------------------------------------------------------------------*
         PUSH  USING                    Save the USING environment
         DROP  ,                        Free all current USINGs

F00230   DS    0H
         USING *,R15                    Assign temp base
         STM   R0,R15,F00230_Save       Save callers registers
         LR    R11,R15                  Load 'perm' base reg
         DROP  R15                      Free temp
         USING F00230,R11               Tell assembler about R11

         STLINENO LINE=1                Clear the screen

         LM    R0,R15,F00230_Save       Restore callers registers
         BSM   0,R14                    And exit


F00230_Save   DS   18F                  Save area
              DS   0D                   Alignment

         DROP  R11                      Free up base reg

F00230_End   EQU        *               End of STLINENO Code

         POP   USING                   Restore USING environment

F00240   DS    0H
*---------------------------------------------------------------------*
*   Batch Job Processing                                              *
*---------------------------------------------------------------------*
         LHI   R0,4095                  Get count for Hdg0
         LH    R15,@_Line_Count         Get current line count
         CR    R15,R0                   Did C00010 start a new page?
         JE    F00250                   No, we had better
         LHI   R15,4094                 Yes, only Hdg1-3
         J     F00260                   and skip
F00250   DS    0H
         LHI   R15,4090                 New page, Hdg0-3
F00260   DS    0H
         STH   R15,@_Line_Count         Save updated line count

         J     F00270                   and skip

F00270   DS    0H
*---------------------------------------------------------------------*
*   If we are here because ISPF output was requested, but we          *
*  couldn't access ISPF DM services, say so now.                      *
*---------------------------------------------------------------------*
         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?
         JO    F00280                   Yes, skip
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?
         JO    F00280                   Yes, skip
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?
         JZ    F00300                   No, skip

F00280   DS    0H
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE Not any more
         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF Not any more
         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF Not any more

         TM    @_ISPF_Explicit,L'@_ISPF_Explicit ISPF specified?
         JZ    F00300                   No, skip message

         LA    R14,F_EMsg03             A(Source)
         LHI   R15,L'F_EMsg03           Source Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         LH    R15,@F_G00010_RC         Get ISPF failure return code
         SLL   R15,4                    Make room for the sign
         STH   R15,@F_DBLWD             Save it
         OI    @F_DBLWD+1,X'0F'         Make it packed
         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it
         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),@F_DBLWD+3
         TR    @F_VolTbl_Ent_Copy+F_EMsg03_RC-F_EMsg03(2),F_Hex_TrTab

         LH    R15,@F_G00010_Reas       Get ISPF failure reason code
         SLL   R15,4                    Make room for the sign
         STH   R15,@F_DBLWD             Save it
         OI    @F_DBLWD+1,X'0F'         Make it packed
         UNPK  @F_DBLWD+2(3),@F_DBLWD(2) Unpack it
         MVC   @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),@F_DBLWD+3
         TR    @F_VolTbl_Ent_Copy+F_EMsg03_Reas-F_EMsg03(2),F_Hex_TrTab

         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    F00290                   No, skip

         PUTLINE MF=(E,@F_IOPL)         Write it

         LA    R14,F_EMsg04             A(Source)
         LHI   R15,L'F_EMsg04           Source Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         PUTLINE MF=(E,@F_IOPL)         Write it
         J     F00300                   and skip

F00290   DS    0H
         LA    R15,@F_VolTbl_Ent_Copy   A(Message)
         ST    R15,@F_Parms_Y00010      Save it
         LHI   R15,L'F_EMsg03           Length of message
         ST    R15,@F_Parms_Y00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,Y00010               Output to SYSPRINT

         LA    R15,F_EMsg04             A(Message)
         ST    R15,@F_Parms_Y00010      Save it
         LHI   R15,L'F_EMsg04           Length of message
         ST    R15,@F_Parms_Y00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,Y00010               Output to SYSPRINT
         J     F00300                   and skip

F00300   DS    0H
*---------------------------------------------------------------------*
*   If we have an error message, put it out now                       *
*---------------------------------------------------------------------*
         CLI   @F_ErrMsgL,C' '          Anything?
         JE    F00320                   Nope, skip

         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JNO   F00310                   No, skip

         LA    R14,@F_ErrMsgL           A(Source)
         LHI   R15,L'@F_ErrMsgL         Source Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         PUTLINE MF=(E,@F_IOPL)         Write it
         J     F00320                   and skip
F00310   DS    0H
         LA    R15,@F_ErrMsgL           A(Message)
         ST    R15,@F_Parms_Y00010      Save it
         LHI   R15,L'@F_ErrMsgL         Len of data
         ST    R15,@F_Parms_Y00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,Y00010               Output to SYSPRINT
         J     F00320                   and skip

F00320   DS    0H
*---------------------------------------------------------------------*
*   Common processing                                                 *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    F80010                   None, exit with error
         ICM   R15,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15)
         JZ    F80010                   No volumes, exit with error

         TM    @_No_Headings,L'@_No_Headings  Headings wanted?
         JO    F00400                   No, skip

         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    F00400                   No, skip

*---------------------------------------------------------------------*
*   TSO Command processing for Headings                               *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)
         JZ    F00400                   No vol tbl, skip headings
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get count
         JZ    F00400                   None,skip headings
         AHI   R9,VolTbl_Ent-VolTbl_Hdr Yes, point to first
         USING VolTbl_Ent,R9            Assign a base
F00370   DS    0H
         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1
         JO    F00380                   Yes, skip
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line
         JZ    F00400                   End of headings, skip
F00380   DS    0H
         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?
         JO    F00390                   Yes, skip
         WAIT  ECB=VolTbl_Ent_ECB       Not yet, wait for it
F00390   DS    0H
         LA    R14,VolTbl_Ent_Display   A(Source)
         LHI   R15,VolTbl_Ent_Display_Len Source Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         PUTLINE MF=(E,@F_IOPL)         Write it

         AHI   R9,VolTbl_Ent_Len        Bump table pointer
         BRCT  R10,F00370               and do next

         DROP  R9                       Free our base

F00400   DS    0H
*---------------------------------------------------------------------*
*   Common processing for VolTbl Entry                                *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume Table)
         JZ    F90010                   Nothing, exit
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) nbr ents
         JZ    F90010                   Nothing, exit
         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry
         USING VolTbl_Ent,R9            and assign a base

F00410   DS    0H
*--------------------------------------------------------------------*
*     If this is a heading line, skip it                             *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1
         JO    F00470                   Yes, skip
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line
         JO    F00470                   a heading, skip it

*--------------------------------------------------------------------*
*     If this is a line we want ...                                  *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line
         JNO   F00420                   No, skip
         TM    @_No_Details,L'@_No_Details Do we want details?
         JNO   F00440                   Yes, go process it
         J     F00470                   No, ignore it

F00420   DS    0H
         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?
         JNO   F00430                   No, skip
         TM    @_No_Totals,L'@_No_Totals Do we want totals?
         JNO   F00440                   Yes, go process it
         J     F00470                   No, ignore it

F00430   DS    0H
*--------------------------------------------------------------------*
*     If this is a Statistics line, fill it in ...                   *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line
         JNO   F00440                   No, go display it

         LA    R15,VolTbl_Ent           Point to the Volume Tbl entry
         ST    R15,@F_Parms_V00010      Save it
         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,V00010               Go process stats

F00440   DS    0H
         TM    VolTbl_Ent_ECB,X'40'     Has the line been populated?
         JO    F00450                   Yes, skip
         WAIT  ECB=VolTbl_Ent_ECB       Not yet, WAIT for it

F00450   DS    0H
*--------------------------------------------------------------------*
*     ... and output this line, either via PUTLINE ...               *
*--------------------------------------------------------------------*
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    F00460                   No, skip

         LA    R14,VolTbl_Ent_Display   A(Source)
         LHI   R15,VolTbl_Ent_Display_Len Source Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         PUTLINE MF=(E,@F_IOPL)         Write it
         J     F00470                   and skip

F00460   DS    0H
*--------------------------------------------------------------------*
*     ... or to SYSPRINT                                             *
*--------------------------------------------------------------------*
         LA    R15,VolTbl_Ent_Display   Data area
         ST    R15,@F_Parms_Y00010      Save it
         LHI   R15,VolTbl_Ent_Display_Len Len of data
         ST    R15,@F_Parms_Y00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,Y00010               Go print it
         J     F00470                   and skip

F00470   DS    0H
*--------------------------------------------------------------------*
*     Point to next VolTbl Entry, and continue                       *
*--------------------------------------------------------------------*
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,F00410               and continue
         DROP  R9

F00480   DS    0H
*--------------------------------------------------------------------*
*   We've finished displaying the table, so write it to OutFile, if  *
*    required.                                                       *
*--------------------------------------------------------------------*
         SLR   R15,R15                  Clear return code
         CLI   @_OutFile_DDName,C' '    Any output file?
         JE    F00600                   No, just exit

         LA    R15,@_OutFile_DDName     Yes, point to it
         ST    R15,@F_Parms_X00010      Save it
         TM    @_OutData_DISPLAY,L'@_OutData_DISPLAY
         JNO   F00500                   No, skip
         LA    R15,@_OutData_DISPLAY    Yes, point to it
         J     F00520                   and skip
F00500   DS    0H
         TM    @_OutData_CB,L'@_OutData_CB
         JNO   F00510                   No, skip
         LA    R15,@_OutData_CB         Yes, point to it
         J     F00520                   and skip
F00510   DS    0H
         LA    R15,@_OutData_ALL        All output
F00520   DS    0H
         ST    R15,@F_Parms_X00010+4    Save A(OutData Flag)
         LA    R1,@F_Parms              A(Parm list)
         BRAS  R14,X00010               Output to file, if necessary
         LTR   R15,R15                  Did it work?
         JZ    F00600                   Yes, exit

*--------------------------------------------------------------------*
*     OutFile processing failed - build our error message ...        *
*--------------------------------------------------------------------*
         MVI   @F_ErrMsgL,C' '          Clear msg area
         MVC   @F_ErrMsgL+1(L'@F_ErrMsgL-1),@F_ErrMsgL
         MVC   @F_ErrMsgL(L'F_Emsg12),F_EMsg12  Move msg start
         MVC   @F_ErrMsgL+L'F_EMsg12+1(L'@_OutFile_DDName),@_OutFile_DD+
               Name
         LA    R15,@F_ErrMsgL+L'F_EMsg12+1+L'@_OutFile_DDName-1
F00530   DS    0H
         CLI   0(R15),C' '              End of DDName?
         JNE   F00540                   yes, skip
         BCT   R15,F00530               No, back up and try again
F00540   DS    0H
         MVC   2(21,R15),=C'not useable - ignored'

*--------------------------------------------------------------------*
*     ... and let the user know ...                                  *
*--------------------------------------------------------------------*
         TM    @_Batch_Environ,L'@_Batch_Environ Are we Batch?
         JO    F00570                   Yes, skip
         TM    @_ISPF_SPACE,L'@_ISPF_SPACE ISPF Output requested?
         JO    F00550                   Yes, skip
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF ISPF Output requested?
         JO    F00550                   Yes, skip
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF ISPF Output requested?
         JZ    F00570                   No, skip

F00550   DS    0H
*--------------------------------------------------------------------*
*     ... via ISPF ...                                               *
*--------------------------------------------------------------------*
         MVC   @F_LINKX,F_LINKX         Move LINK L-Form

         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@F_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@F_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@F_ISPF_Parms+4      Save it
         LA    R15,=C'OutFile Error'    Short message
         ST    R15,@F_ISPF_Parms+8      Save it
         LA    R15,=AL4(13)             Length of message
         ST    R15,@F_ISPF_Parms+16     Save it
         OI    @F_ISPF_Parms+16,X'80'   Flag end of list

         LARL  R2,F00560                A(Error return address)
         LINKX EP=ISPLINK,              Link to ISPF Interface         +
               ERRET=(2),                error here                    +
               MF=(E,@F_ISPF_Parms),     passing these parms           +
               SF=(E,@F_LINKX)           staying re-entrant

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@F_ISPF_Parms+4      Save it
         LA    R15,@F_ErrMsgL           Long message
         ST    R15,@F_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'@F_ErrMsgL)   Length of message
         ST    R15,@F_ISPF_Parms+16     Save it
         OI    @F_ISPF_Parms+16,X'80'   Flag end of list
         LINKX EP=ISPLINK,              Link to ISPF Interface         +
               ERRET=(2),                error here                    +
               MF=(E,@F_ISPF_Parms),     passing these parms           +
               SF=(E,@F_LINKX)           staying re-entrant

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@F_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@F_ISPF_Parms+4      Save it
         OI    @F_ISPF_Parms+4,X'80'    Mark end of list
         LINKX EP=ISPLINK,              Link to ISPF Interface         +
               ERRET=(2),                error here                    +
               MF=(E,@F_ISPF_Parms),     passing these parms           +
               SF=(E,@F_LINKX)           staying re-entrant
         J     F00590                   and exit with error

F00560   DS    0H
         LA    R1,@F_ErrMsgL            A(Error Message)
         LA    R0,L'@F_ErrMsgL          Length
         TPUT  (1),(0)                  All else failed
         J     F00590                   and exit with error

F00570   DS    0H
*--------------------------------------------------------------------*
*     ... or PUTLINE ...                                             *
*--------------------------------------------------------------------*
         TM    @_TSO_Command,L'@_TSO_Command Is this a TSO command?
         JZ    F00580                   No, skip

         LA    R14,@F_ErrMsgL           A(Source)
         LHI   R15,L'@F_ErrMsgL         Length
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,@F_VolTbl_Ent_Copy    A(Target)
         LHI   R1,@F_VolTbl_Ent_Copy_Len Target length
         MVCL  R0,R14                   Move message
         PUTLINE MF=(E,@F_IOPL)         Write it
         J     F00590                   and skip

F00580   DS    0H
*--------------------------------------------------------------------*
*     ... or to SYSPRINT                                             *
*--------------------------------------------------------------------*
         LA    R15,@F_ErrMsgL           A(Error Msg)
         ST    R15,@F_Parms_Y00010      Save it
         LA    R15,L'@F_ErrMsgL         Length
         ST    R15,@F_Parms_Y00010+4    Save it

         LA    R1,@F_Parms              A(Parms)
         BRAS  R14,Y00010               Go print it
         J     F00590                   and exit with error

F00590   DS    0H
*--------------------------------------------------------------------*
*     Set the return code, and exit                                  *
*--------------------------------------------------------------------*
         LA    R15,4                    OutFile processing failed
         J     F00600                   and exit

F00600   DS    0H
*--------------------------------------------------------------------*
*     All done processing the VolTbl Entries - exit                  *
*--------------------------------------------------------------------*
         J     F90010                   exit quick smart


F80010   DS    0H
*--------------------------------------------------------------------*
*     Nothing to display                                             *
*--------------------------------------------------------------------*
         LA    R15,4                    Set return code
         J     F90010                   and exit

F90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@F_Dynam              A(Local storage)
         L     R2,@F_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

F_Literals  DS  0H

F_PLPB   PUTLINE OUTPUT=(0,TERM,SINGLE,DATA),                          +
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +
               MF=L
F_PLPB_Length EQU *-F_PLPB

F_LINKX  LINKX EP=ISPLINK,            ISPF services                    +
               SF=L                    List form only
F_LINKX_Length EQU   *-F_LINKX

F_EMsg01 DC    C'&PGMNAME.01I No Devices/Volumes match selection criter+
               ia'
F_EMsg02 DC    C'&PGMNAME.02I Insufficient APF authorization'
F_EMsg03 DC    C'&PGMNAME.03I ISPF DM Services unavailable xx-yy'
F_EMsg03_RC    EQU F_EMsg03+L'F_EMsg03-5,2
F_EMsg03_Reas  EQU F_EMsg03+L'F_EMsg03-2,2
F_EMsg04 DC    C'&PGMNAME.04I Forcing non-ISPF output'
F_EMsg05 DC    C'&PGMNAME.05I CSVQUERY unavailable on this system '
F_EMsg06 DC    C'&PGMNAME.06I Program not found in STEPLIB/LNKLST'
F_EMsg07 DC    C'&PGMNAME.07I IKJEFTSR Error xx-yy'
F_EMsg07_RC    EQU   F_EMsg07+L'F_EMsg07-5,2
F_EMsg07_Reas  EQU   F_EMsg07+L'F_EMsg07-2,2
F_EMsg08 DC    C'&PGMNAME.08I LSPACE failed for at least 1 volume'
F_EMsg09 DC    C'&PGMNAME.09I Incompatible version'
F_EMsg10 DC    C'&PGMNAME.10I Insufficient storage:'
F_EMsg11 DC    C'&PGMNAME.11I Internal Error - Unknown invocation type'
F_EMsg12 DC    C'&PGMNAME.12I OutFile DDName'

F_EX1    MVC   0(0,R15),0(R1)

F_Hex_TrTab           EQU   *-240
                      DC    C'0123456789ABCDEF'

         LTORG

F_Literals_End  DS  0H


@F_Dynam                  DSECT        Dynamic area for F00000
                          DS    18F     O/S Style save area
@F_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@F_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@F_DBLWD                  DS    D       Work area

@F_G00010_RC              DS    HL2     G00010 Return Code
@F_G00010_Reas            DS    HL2     G00010 Reason Code

@F_Parms                  DS    0F      Parms for called rtns
@F_Parms_Std              DS    3AL4     Standard 3 parms
@F_Parms_Extra            EQU   *        Extra parms
@F_Parms_G00010           DS    2AL4        for G00010
                          ORG   @F_Parms_Extra
@F_Parms_I00010           DS    2AL4        for I00010
                          ORG   @F_Parms_Extra
@F_Parms_V00010           DS    AL4         for V00010
                          ORG   @F_Parms_Extra
@F_Parms_X00010           DS    2AL4        for X00010
                          ORG   @F_Parms_Extra
@F_Parms_Y00010           DS    2AL4        for Y00010
                          ORG   @F_Parms_Extra
@F_ISPF_Parms             DS    5AL4   ISPF Parm List
@F_LINKX                  DS    CL(F_LINKX_Length)
                          ORG   ,
                          DS    0F      Alignment
@F_IOPL                   DS    CL(IOPL_Length)  IOPL block
                          DS    0F      Alignment
@F_PLPB                   DS    CL(F_PLPB_Length) PUTLINE Parm Blk
@F_IOECB                  DS    F       ECB for PUTLINE
@F_OLD                    EQU   *       OLD for PUTLINE
@F_OLDLN                  DS    HL2      Length
@F_OLDOF                  DS    HL2      Offset
@F_VolTbl_Ent_Copy        DS    2CL((VolTbl_Ent_Display_Len/2)+1)
@F_VolTbl_Ent_Copy_Len    EQU   *-@F_VolTbl_Ent_Copy
@F_ErrMsgS                DS    CL24
@F_ErrMsgL                DS    CL(L'VolTbl_Ent_ErrMsg)
                          DS    0D          Alignment
@F_Dynam_Length           EQU   *-@F_Dynam  Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'G00010: Output Results using ISPF'

         PUSH  USING

G00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : G00010                                                 *
*                                                                     *
*  Abstract  : Display results of LSPACE stuff via ISPF               *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(ISPF Short Message)                        *
*                        A(ISPF Long Message)                         *
*  Outputs   : R15: 00 - all OK                                       *
*                   04 - ISPQRY Failed,       R0: RC from ISPQRY      *
*                   08 - ISPLINK LOAD failed, R0: RC from LOAD        *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2000/05/23 SDDA030 - V2.12                             *
*                                 - New, code was originally in       *
*                                   F00010.                           *
*                                 - Added MULT to TBADD.              *
*                                 - If we are APF-auth turn off       *
*                                   JSCBAUTH before trying to use DM, *
*                                   and ATTACH a task to reset it     *
*                                   when we are done.                 *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Removed IOSCDR message pointer.   *
*                                 - Removed JSCBAUTH stuff.           *
*                                 - Added 'Incomplete' ISPF msg.      *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Added BRIF/EDIF support.          *
*                                 - Used BRIF if ISPF(S) wanted, but  *
*                                   panel not available.              *
*              2002/02/12 SDDA030 - V2.16                             *
*                                 - Moved ISPF(S) code to K00010      *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Added code to allow switching     *
*                                   between display modes.            *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,G_Literals           Point to our literals
         USING (G_Literals,G_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@G_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@G_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @G_Dynam,R13             Assign a base
         L     R15,@G_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@G_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@G_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@G_Parms_Std         Save it
         L     R15,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@G_Parms_Std+4       Save it
         L     R15,@G_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@G_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*      If we can use ISPF, LOAD ISPLINK                               *
*---------------------------------------------------------------------*
         LA    R1,0                     Clear parm reg
         LINK  EP=ISPQRY                Check ISPF services
         LTR   R15,R15                  Are they available?
         JNZ   G80010                   No, use line-by-line
G00020   DS    0H
         BASR  R2,0
         USING (*,G00020_End-1),R2
         LOAD  EP=ISPLINK               Get A(ISPF Interface)
G00020_End DS  0H
         DROP  R2
         LTR   R15,R15                  Is it there?
         JNZ   G80020                   No, skip
         ST    R0,@_ISPLINK             Yes, save EPA

*---------------------------------------------------------------------*
*      ISPF seems to be available - save our display environment and  *
*     ask ISPF to return errors to us.                                *
*---------------------------------------------------------------------*
         LA    R15,=CL8'CONTROL'        CONTROL
         ST    R15,@G_ISPF_Parms
         LA    R15,=CL8'DISPLAY'        DISPLAY
         ST    R15,@G_ISPF_Parms+4
         LA    R15,=CL8'SAVE'           SAVE
         ST    R15,@G_ISPF_Parms+8
         OI    @G_ISPF_Parms+8,X'80'    Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'CONTROL'        CONTROL
         ST    R15,@G_ISPF_Parms
         LA    R15,=CL8'ERRORS'         ERRORS
         ST    R15,@G_ISPF_Parms+4
         LA    R15,=CL8'RETURN'         RETURN
         ST    R15,@G_ISPF_Parms+8
         OI    @G_ISPF_Parms+8,X'80'    Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*      Clear our flags                                                *
*---------------------------------------------------------------------*
         NI    @G_SETMSG_Issued,X'FF'-L'@G_SETMSG_Issued Clear flg

*---------------------------------------------------------------------*
*      If there is an error message, SETMSG it ...                    *
*---------------------------------------------------------------------*
         L     R15,@G_Dynam+4           A(HSA)
         L     R15,24(0,R15)            Get original R1
         ICM   R14,B'1111',12(R15)      A(Short Error message)
         JZ    G00030                   Nothing, skip
         CLI   0(R14),C' '              Message blank?
         JE    G00030                   Yes, no message

         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@G_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         ST    R14,@G_ISPF_Parms+8      Save A(short message)
         LA    R15,=FL4'24'             Max len of SMSG
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         L     R15,@G_Dynam+4           A(HSA)
         L     R15,24(0,R15)            Get original R1
         L     R15,16(0,R15)            A(Long message)
         ST    R15,@G_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'VolTbl_Ent_ErrMsg) Length of Long Msg
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@G_ISPF_Parms+4      Save it
         OI    @G_ISPF_Parms+4,X'80'    Mark end of list
         LA    R1,@G_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG

G00030   DS    0H
*---------------------------------------------------------------------*
*      If there is anything to do ...                                 *
*---------------------------------------------------------------------*
         SLR   R15,R15                  Clear return code
         ICM   R1,B'1111',@_VolTbl_Ptr A(VolTbl)
         JZ    G90010                   None, all done
         ICM   R1,B'1111',VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R1)
         JZ    G90010                   None, all done

*---------------------------------------------------------------------*
*      If we will be invoking BRIF, put out the message indicating    *
*     that the SORT command is available.                             *
*---------------------------------------------------------------------*
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?
         JNO   G00060                   No, skip
         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued Already a msg?
         JO    G00060

         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@G_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         LA    R15,G_Sort_SMsg          SORT Cmd available
         ST    R15,@G_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'G_Sort_SMsg)  Length of message
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         LA    R15,G_Sort_LMsg          Long message
         ST    R15,@G_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'G_Sort_LMsg)  Length of message
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ000'        A(Message ID)
         ST    R15,@G_ISPF_Parms+4      Save it
         OI    @G_ISPF_Parms+4,X'80'    Mark end of list
         LA    R1,@G_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

G00060   DS    0H
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Do we want BRIF?
         JO    G00070                   Yes, skip
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF No, how about EDIF?
         JO    G00070                   Yes, skip

*---------------------------------------------------------------------*
*      Invoke our standard ISPF SPACE display; if it fails, we will   *
*     force BRIF.                                                     *
*---------------------------------------------------------------------*
         LA    R1,@G_Parms              A(Parms)
         BRAS  R14,K00010               Go display ISPF(S)
         TM    @_ReDisplay,L'@_ReDisplay Do it again?
         JO    G00080                   Yes, exit quick smart
         LTR   R15,R15                  No, how did it go?
         JZ    G00080                   OK, skip

*---------------------------------------------------------------------*
*      We will use BRIF - set our flag, and let the user know         *
*---------------------------------------------------------------------*
         OI    @_ISPF_BRIF,L'@_ISPF_BRIF No, force BRIF
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE

         TM    @G_SETMSG_Issued,L'@G_SETMSG_Issued  Already SETMSG'd?
         JO    G00070                   Yes, don't clobber it

         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@G_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         LA    R15,G_BRIF_SMsg          A(Short Message)
         ST    R15,@G_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'G_BRIF_SMsg)  Length of variable
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@G_ISPF_Parms+4      Save it
         LA    R15,G_BRIF_LMsg          A(Long message)
         ST    R15,@G_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'G_BRIF_LMsg)  Length of message
         ST    R15,@G_ISPF_Parms+16     Save it
         OI    @G_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@G_ISPF_Parms+4      Save it
         OI    @G_ISPF_Parms+4,X'80'    Mark end of list
         LA    R1,@G_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         OI    @G_SETMSG_Issued,L'@G_SETMSG_Issued  We've done a SETMSG

         J     G00070                   and go do it

G00070   DS    0H
         LA    R1,@G_Parms              A(Parms)
         BRAS  R14,J00010               Go EDIF/BRIF

         LA    R15,0                    Clear return code
         LA    R0,0                     and reason code
         J     G90010

G00080   DS    0H
*--------------------------------------------------------------------*
*     END or RETURN from DISPLAY: Clear return codes and exit.       *
*--------------------------------------------------------------------*
         LA    R0,0                     Clear reason code
         LA    R15,0                     and return code
         J     G90010                   exit


G80010   DS    0H
*-------------------------------------------------------------------*
*    Error - ISPQRY failed                                          *
*-------------------------------------------------------------------*
         LR    R0,R15                 Set reason code (RC from ISPQRY)
         LA    R15,4                  Set return code
         J     G90010                 and exit

G80020   DS    0H
*-------------------------------------------------------------------*
*    Error - LOAD for ISPLINK failed                                *
*-------------------------------------------------------------------*
         LR    R0,R15                 Set reason code (RC from LOAD)
         LA    R15,8                  Set return code
         J     G90010                 and exit


G90010   DS    0H
*---------------------------------------------------------------------*
*   Clean up and return to caller                                     *
*---------------------------------------------------------------------*
         LR    R3,R15                 Save return code
         LR    R4,R0                   and reason code

*---------------------------------------------------------------------*
*   If we successfully LOADed ISPLINK ...                             *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_ISPLINK     Get A(ISPF Interface)
         JZ    G90030                   None, skip

*---------------------------------------------------------------------*
*   ... VDELETE any ISPF variables we created ...                     *
*---------------------------------------------------------------------*
         LA    R15,=CL8'VDELETE'        Yes, A(ISPF Function)
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'*'              A(Variable names)
         ST    R15,@G_ISPF_Parms+4      Save it
         OI    @G_ISPF_Parms+4,X'80'    Flag end of list
         LA    R1,@G_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*   ... restore the ISPF Display environment ...                      *
*---------------------------------------------------------------------*
         LA    R15,=CL8'CONTROL'        ISPF Function
         ST    R15,@G_ISPF_Parms        Save it
         LA    R15,=CL8'DISPLAY'        Character variables
         ST    R15,@G_ISPF_Parms+4      Save it
         LA    R15,=CL8'RESTORE'        Character variables
         ST    R15,@G_ISPF_Parms+8      Save it
         OI    @G_ISPF_Parms+8,X'80'    Flag end of list
         LA    R1,@G_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*   ... and DELETE ISPLINK                                            *
*---------------------------------------------------------------------*
         DELETE EP=ISPLINK              Delete it
         LA    R15,0                    and clear
         ST    R15,@_ISPLINK             the pointer

G90030   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LA    R1,@G_Dynam              A(Local storage)
         L     R2,@G_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         LR    R15,R3                   Restore return code
         LR    R0,R4                    Restore reason code
         L     R14,12(0,R13)            Restore return address
         LM    R1,R12,24(R13)           Restore other registers
         BSM   0,R14                    and return

G_Literals  DS   0H

G_Sort_SMsg DC C'SORT Cmd avail'
G_Sort_LMsg DC C'''SORT'' can be used to sort the table'

G_BRIF_SMsg DC C'BRIF substituted'
G_BRIF_LMsg DC C'Panel &PNLNAME not found'

         LTORG

G_Literals_End  DS   0H


@G_Dynam                  DSECT        Dynamic area for G00000
                          DS    18F     O/S Style save area
@G_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@G_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@G_DBLWD                  DS    D       Work area
@G_ISPF_Parms             DS    10FL4   ISPF Parm list
                          DS    X       Flag Byte
@G_SETMSG_Issued          EQU   *-1,X'80' 1... .... SETMSG issued

@G_Parms                  DS    0F      Parms for called rtns
@G_Parms_Std              DS    3AL4     Standard 3 parms
@G_Parms_Extra            EQU   *        Extra parms
                          ORG   ,
                          DS    0D      Alignment
@G_Dynam_Length           EQU   *-@G_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING

         TITLE 'H00010: Issue LSPACE for device'

         PUSH  USING

H00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : H00010                                                 *
*                                                                     *
*  Abstract  : Issue LSPACE and save selected F4 DSCB data            *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(Volume Table)                              *
*  Outputs   : VolTbl updated                                         *
*                                                                     *
*  Operation : Initialize                                             *
*                Do while unprocessed entries in Volume Table         *
*                  Flag entry as processed                            *
*                  Issue STIMER                                       *
*                  Issue LSPACE for device described by VolTbl_Ent    *
*                  Cancel STIMER                                      *
*                  Format detail line                                 *
*                  Update Totals                                      *
*                  If last volume,                                    *
*                    Format Totals line, if present                   *
*                  EndIf                                              *
*                EndDo                                                *
*              Update Stats Line, if present                          *
*              Terminate                                              *
*                                                                     *
*  History   : 1997/05/16 SDDA030 - New                               *
*              1998/09/17 SDDA030 - V2.0                              *
*                                 - Used Compare-and-Swap in pseudo-  *
*                                   POST processing, rather than      *
*                                   blindly ORing POST bit if no WAIT *
*                                   was present.                      *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Added ESTAE to trap ABENDs and    *
*                                   POST SPACE with a code of 8.      *
*                                 - Moved STIMERM from D00010 to this *
*                                   routine.                          *
*              1998/11/13 SDDA030 - V2.2                              *
*                                 - This routine now goes through the *
*                                   Volume Table, rather than WAITing *
*                                   for SPACE to POST it with the     *
*                                   address of an entry to process.   *
*                                   ESTAE merely restarts the search  *
*                                   through the table, rather than    *
*                                   POSTing the ECB (there seems to be*
*                                   no point in re-ATTACHing after an *
*                                   ESTAE).                           *
*              1999/09/01 SDDA030 - V2.9                              *
*                                 - Do not use CDS instruction to up- *
*                                   date totals fields, as they are   *
*                                   now in the subtask area.          *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Used areas within the VolTbl      *
*                                   entry to hold control blocks from *
*                                   LSPACE.                           *
*                                 - Removed SMS anomaly check (now    *
*                                   in E00010).                       *
*              2000/05/23 SDDA030 - V2.12                             *
*                                 - Removed STIMERM-related stuff     *
*                                   Added IOSCDR to check if we can   *
*                                   get out to the DASD device before *
*                                   issuing LSPACE.                   *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Undid stuff from V2.12            *
*                                 - Replaced POST with ESTAE and      *
*                                   ABEND in STIMERM exit (H06000).   *
*                                 - Mimimum STIMERM WAIT time = 1 sec.*
*                                 - Used micro-secs and MICVL instead *
*                                   of Timer Units.                   *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Removed detail and total line     *
*                                   formatting.                       *
*                                 - Used work area passed by E00010   *
*                                   rather than GETMAIN.              *
*              2001/11/12 SDDA030 - V2.15                             *
*                                 - Corrected bug in calculating      *
*                                   STIMERM times - all our times are *
*                                   now maintained in usec.           *
*                                 - Used STIMERM Wait time factor in  *
*                                   calculating wait time.            *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - Generated LSPACE error messages   *
*                                   internally, instead of asking     *
*                                   LSPACE to do it.                  *
*              2002/06/11 SDDA030 - V2.18                             *
*                                 - Formatted detail and total lines  *
*                                   in this routine.                  *
*                                 - Filled in SubTask Statistics Line.*
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Rounded numbers in the display    *
*                                   area where appropriate.           *
*                                 - Used TRKCALC to get track size,   *
*                                   rather than use DS4DEVTK. For     *
*                                   example, for 3390s:               *
*                                     DS4DEVTK = 58786                *
*                                     TRKCALC  = 56664                *
*                                 - Used standardized calling sequence*
*                                 - Saved callers registers on the    *
*                                   Linkage Stack                     *
*                                 - Used STIMERM around LSPACE if     *
*                                   MaxLWait specified                *
*                                                                     *
*  Notes     : This routine differs from the others in this program   *
*              in that it is ATTACHed.                                *
*                                                                     *
*---------------------------------------------------------------------*


*---------------------------------------------------------------------*
*     Save caller's registers, get dynamic storage, etc. etc.         *
*---------------------------------------------------------------------*
         BAKR  R14,0                    Save callers registers
         LARL  R11,H_Literals           Point to our literals
         USING (H_Literals,H_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get some storage for our LIFO stack ...                        *
*-------------------------------------------------------------------*
         LHI   R0,@_31Bit_Stack_Length  Length of storage we need
         SSCSTACK INIT,                 Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=31                    above-the-line

         LR    R4,R1                    Save its address

*-------------------------------------------------------------------*
*    ... and get an area on it for our local storage                *
*-------------------------------------------------------------------*
         SSCSTACK PUSH,                 Get Stack area                 +
               LEN=@H_Dynam_Length,      this long                     +
               STACK=(R4)                 using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@H_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         LR    R13,R1                   Load dynam base
         USING @H_Dynam,R13             Assign a base
         MVC   4(4,R13),=C'F1SA'        Init save area
         ST    R4,@H_31Bit_Stack_Ptr    Save A(Stack)

         EREG  R0,R4                    Restore callers registers

*---------------------------------------------------------------------*
*     Save our parm addresses ...                                     *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',12(R1)       A(Volume Table)
         JZ    H90010                   Nothing, all done
         ST    R15,@H_VolTbl_Ptr        Save it
         LA    R14,VolTbl_Hdr_LSPACE_Avg-VolTbl_Hdr(R15)
         ST    R14,@H_LSPACE_Avg_Ptr    Save it
         LA    R14,VolTbl_Hdr_STIMERM_Adj-VolTbl_Hdr(R15)
         ST    R14,@H_STIMERM_Adj_Ptr   Save it

*---------------------------------------------------------------------*
*     ... set up the addresses of the lines we need ...               *
*---------------------------------------------------------------------*
         L     R15,@H_VolTbl_Ptr        A(VolTbl)
         ICM   R0,B'1111',VolTbl_Hdr_Total_Off-VolTbl_Hdr(R15) Totals
         JZ    H00020                   None, skip
         AR    R0,R15                   Convert offset to address
         ST    R0,@H_Totals_Line_Ptr    Save it
H00020   DS    0H
         ICM   R0,B'1111',VolTbl_Hdr_SMS_Off-VolTbl_Hdr(R15) SMS msg
         JZ    H00030                   None, skip
         AR    R0,R15                   Convert offset to address
         ST    R0,@H_SMS_Anomaly_Ptr    Save it
H00030   DS    0H
         ICM   R0,B'1111',VolTbl_Hdr_SubT_Off-VolTbl_Hdr(R15) SubTask
         JZ    H00040                   None, skip
         AR    R0,R15                   Convert offset to address
         ST    R0,@H_Stats_Line_Ptr     Save it

H00040   DS    0H
*---------------------------------------------------------------------*
*     ... and set our flag, indicating the presence of OW48527, and   *
*     the maximum LSPACE Wait time                                    *
*---------------------------------------------------------------------*
        L     R15,@H_VolTbl_Ptr         A(VolTbl)
        TM    VolTbl_Hdr_OW48527-VolTbl_Hdr(R15),L'VolTbl_Hdr_OW48527
        JNO   H00040C                   Not installed, skip
        OI    @H_OW48527,L'@H_OW48527   OK, set our flag
H00040C DS    0H
        MVC   @H_MaxLWait,VolTbl_Hdr_MaxLWait-VolTbl_Hdr(R15)

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@H_Parms_Std         Save it
         LA    R15,@H_31Bit_Stack_Ptr   A(31-bit Stack Pointer)
         ST    R15,@H_Parms_Std+4       Save it
         LA    R15,@H_24Bit_Stack_Ptr   A(24-bit Stack Pointer)
         ST    R15,@H_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*     Set up our ESTAE parms                                          *
*---------------------------------------------------------------------*
         MVC   @H_ESTAE_RMask,=X'FFFF'  Restore all registers

*---------------------------------------------------------------------*
*     Find an unprocessed entry in the Volume Table                   *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@H_VolTbl_Ptr Point to the Volume Table
         JZ    H90010                   None, exit
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries
         JZ    H90010                   None, exit
         AHI   R9,VolTbl_Ent-VolTbl     Yes, point to the first

         USING VolTbl_Ent,R9            Assign a base

H00050   DS    0H
*---------------------------------------------------------------------*
*     Establish an ESTAE, if required                                 *
*---------------------------------------------------------------------*
         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry
         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address

         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued Do we have an ESTAE?
         JO    H00060                   Yes, skip

         MVC   @H_ESTAE,H_ESTAE         Move L-Form
         L     R3,=AL4(H07000)          A(Exit
         ESTAEX (3),                    Establish ESTAE Exit           +
               CT,                       create it                     +
               PARAM=@H_Dynam,           passing this parm             +
               MF=(E,@H_ESTAE)           keeping ourselves reentrant
         LTR   R15,R15                  Did it work?
         JNZ   H00060                   No, skip
         OI    @H_ESTAE_Issued,L'@H_ESTAE_Issued Yes, set our flag

H00060   DS    0H
*---------------------------------------------------------------------*
*     If this entry has not been processed ...                        *
*---------------------------------------------------------------------*
         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent

         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line
         JNO   H00410                   No, skip this entry
         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?
         JO    H00410                   Yes, dont use it
         XC    @H_Current_VolTbl_Ent,@H_Current_VolTbl_Ent

         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed
         JNZ   H00410                   Yes, try next

*---------------------------------------------------------------------*
*     ... Compare-and-Swap the flag byte, ...                         *
*---------------------------------------------------------------------*
         L     R1,VolTbl_Ent_Processed  No, get the Flag byte
         LA    R0,L'VolTbl_Ent_Processed Set up the
         SLL   R0,24                     flag turned
         OR    R0,R1                     on
         CS    R1,R0,VolTbl_Ent_Processed and update it
         JNZ   H00410                   Somebody else here, skip

*---------------------------------------------------------------------*
*     ... bump our counters ...                                       *
*---------------------------------------------------------------------*
         L     R14,@H_Total_Vols_Proc   Get nbr vols we processed
         AHI   R14,1                    Bump it
         ST    R14,@H_Total_Vols_Proc   and save it

*---------------------------------------------------------------------*
*     Calculate the time we will WAIT for LSPACE to complete, if      *
*     MaxLWait has not been specified.                                *
*     We arbitrarily wait for (8 * Avg of all previously completed    *
*    LSPACEs * Adjustment Factor), rounded up to the next second.     *
*                                                                     *
*     If we are running with OW48527, this time is passed to LSPACE;  *
*    otherwise, we set up a STIMERM to pop after this time.           *
*---------------------------------------------------------------------*
         LH    R15,@H_MaxLWait          Get MaxLWait
         CHI   R15,0                    Was it specified?
         JNE   H00080                   Yes, use it
         L     R15,@H_LSPACE_Avg_Ptr    A(Avg Wait for LSPACE in usec)
         ICM   R15,B'1111',0(R15)       Get it
         JNZ   H00070                   Something there, skip
         L     R15,=FL4'250000'         Nothing, default to .25 sec
H00070   DS    0H
         LA    R14,0                    Clear R14
         SLDL  R14,3                    Multiply by 8
         L     R1,@H_STIMERM_Adj_Ptr    A(Adjustment factor)
         M     R14,0(0,R1)              Adjust it
         D     R14,=FL4'1000000'        Convert to seconds
         AHI   R15,1                    Bump it
         CHI   R15,5                    More than 5 seconds?
         JNH   H00080                   No, OK
         LHI   R15,5                    Yes, max of 5 secs
H00080   DS    0H
         ST    R15,@H_LSPACE_Wait_Max   Save it

*---------------------------------------------------------------------*
*   If we are running without APAR OW48527, or MaxLWait was specified,*
*   update our ESTAE Retry routine address and registers ...          *
*---------------------------------------------------------------------*
         TM    @H_OW48527,L'@H_OW48527  Is the APAR on
         JNO   H00090                   No, skip
         LH    R0,@H_MaxLWait           Get MaxLWait
         CHI   R0,0                     Was it specified?
         JE    H00100                   No, skip

H00090   DS    0H
         ST    R9,@H_Current_VolTbl_Ent Save A(VolTbl_Ent) for ESTAE
         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry
         MVC   @H_ESTAE_Retry,=AL4(H00120) Set retry address

*---------------------------------------------------------------------*
*     ... and establish a timer, so we don't wait forever for LSPACE  *
*---------------------------------------------------------------------*
         LA    R15,@H_Dynam             A(Dynamic storage)
         ST    R15,@H_STIMERM_Exit_Parms Save it for the exit routine
         LA    R15,@H_STIMERM_Exit_Parms Point to parm area
         ST    R15,@H_STIMERM_Exit_Parms_Ptr  Save the address
         LA    R3,@H_STIMERM_Exit_Parms_Ptr Point to parm area addr
         L     R4,=AL4(H06000)          A(Exit)

         L     R15,@H_LSPACE_Wait_Max   Get nbr secs to wait
         MHI   R15,100                  in BINTVL
         ST    R15,@H_DBLWD             Save it

         MVC   @H_STIMERM_Set,H_STIMERM_Set Move L-Form of macro
         STIMERM SET,                   Set a timer                    +
               ID=@H_STIMERM_ID,         save the ID here              +
               BINTVL=@H_DBLWD,          for this long                 +
               EXIT=(4),                 invoke this when we pop       +
               PARM=(3),                 with this parm                +
               WAIT=NO,                  Dont wait                     +
               MF=(E,@H_STIMERM_Set)     keep ourselves reentrant

H00100   DS    0H
*---------------------------------------------------------------------*
*     Set up our areas that will be used by LSPACE                    *
*---------------------------------------------------------------------*
         XC    VolTbl_Ent_LSPACE_Data,VolTbl_Ent_LSPACE_Data
         XC    VolTbl_Ent_DSCB,VolTbl_Ent_DSCB Clear DSCB area
         NI    VolTbl_Ent_LSPACE_Fail,X'FF'-L'VolTbl_Ent_LSPACE_Fail

*---------------------------------------------------------------------*
*     Save the current TOD (ie, when LSPACE started)                  *
*---------------------------------------------------------------------*
         MVC   @H_TIME,H_TIME           MOVE Time macro
         TIME  STCK,                    Get the current time           +
               @H_LSPACE_Start,          return it here                +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               MF=(E,@H_TIME)            staying re-entrant

*---------------------------------------------------------------------*
*     Set up the LSPACE parms, including LSPAXTIM if we are both      *
*    assembling and running on systems with OW48527                   *
*---------------------------------------------------------------------*
         MVC   @H_LSPACE,H_LSPACE       Move LSPACE parms
         AIF   (NOT D'LSPAXTIM).OW48527_200
         TM    @H_OW48527,L'@H_OW48527  Are we running with OW48527?
         JNO   H00110                   No, skip
         L     R15,@H_LSPACE_Wait_Max   Get Wait Time
         ICM   R0,B'1111',@H_STIMERM_ID Did we set up a STIMER?
         JNZ   H00110                   Yes, use LSPACE default
         STC   R15,@H_LSPACE+LSPAXTIM-LSPACE_Parm Update wait limit
H00110   DS    0H
.OW48527_200 ANOP

*---------------------------------------------------------------------*
*     Get the volume info using LSPACE                                *
*---------------------------------------------------------------------*
         LA     R3,VolTbl_Ent_UCBCopy   A(Our UCB)
         LSPACE UCB=(3),                Get free space                 +
               DATA=VolTbl_Ent_LSPACE_Data, save return info here      +
               F4DSCB=VolTbl_Ent_DSCB,   Return F4 DSCB too            +
               MF=(E,@H_LSPACE)          Parm area here

H00120   DS    0H
*---------------------------------------------------------------------*
*     Cancel our STIMERM, if there is one ...                         *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@H_STIMERM_ID  Did we establish a timer?
         JZ    H00130                   No, skip

         MVC   @H_STIMERM_Can,H_STIMERM_Cancel Move L-Form macro
         STIMERM CANCEL,                Cancel our timer               +
               ID=@H_STIMERM_ID,         with this Id                  +
               MF=(E,@H_STIMERM_Can)     keep ourselves reentrant
         XC    @H_STIMERM_ID,@H_STIMERM_ID Clear STIMERM ID

*---------------------------------------------------------------------*
*     ... and update our ESTAE retry routine pointer, now that LSPACE *
*    is done                                                          *
*---------------------------------------------------------------------*
         STM   R0,R15,@H_ESTAE_Regs     Save our registers for retry
         MVC   @H_ESTAE_Retry,=AL4(H00380) Set retry address

H00130   DS    0H
*---------------------------------------------------------------------*
*     Save the current TOD, and calculate the amount of time we have  *
*    been waiting for LSPACE ...                                      *
*---------------------------------------------------------------------*
         MVC   @H_TIME,H_TIME           MOVE Time macro
         TIME  STCK,                    Get the current time           +
               @H_TIME_Area,             return it here                +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               MF=(E,@H_TIME)            staying re-entrant

         LM    R14,R15,@H_Time_Area     Get current time
         SL    R15,@H_LSPACE_Start+4    Calculate
         JNM   H00140                   No borrow, skip
         SL    R14,=FL4'1'              Borrow, reduce
H00140   DS    0H
         SL    R14,@H_LSPACE_Start      Calculate WAIT time
         SRDL  R14,12                   in usec
         STM   R14,R15,@H_LSPACE_Wait   Save it

*---------------------------------------------------------------------*
*     ... and add it to the appropriate total (Successful or          *
*    Unsuccessful LSPACE WAIT time)                                   *
*---------------------------------------------------------------------*
         LA    R3,@H_Total_LSPACE_Wait_OK     Assume all worked
         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?
         JE    H00150                   Yes, skip
         LA    R3,@H_Total_LSPACE_Wait_Bad  No, A(unsuccess total)

H00150   DS    0H
         LM    R0,R1,0(R3)              Get total (in usec)
         ALR   R1,R15                   Add the wait time
         BRC   12,H00160                No carry, skip
         AL    R0,=FL4'1'               Carry, bump
H00160   DS    0H
         ALR   R0,R14                   Bump Wait totals
         STM   R0,R1,0(R3)              Save Wait Time totals

*---------------------------------------------------------------------*
*     If LSPACE failed ...                                            *
*---------------------------------------------------------------------*
         CLI   @H_LSPACE+LSPAERCD-LSPACE_Parm,X'00' Did LSPACE Work?
         JE    H00220                   Yes, skip

*---------------------------------------------------------------------*
*     ... flag the VolTbl_Ent, and generate an appropriate message (we*
*    generate our own messages, because we would have to re-invoke    *
*    LSPACE to get LSPACE to do it, and the conditions that caused it *
*    to fail initially may have changed or disappeared by the time we *
*    issue LSPACE again) ...                                          *
*---------------------------------------------------------------------*
         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail
         CLC   =X'14850000',@H_LSPACE+LSPAERCD-LSPACE_Parm ESTAE?
         JNE   H00170                   No, skip
         TM    VolTbl_Ent_U522,L'VolTbl_Ent_U522 Because of us?
         JNO   H00170                   No, skip
         MVC   VolTbl_Ent_ErrMsg(L'H_MsgU522A),H_MsgU522A Say so
         LH    R0,@H_MaxLWait           Get MaxLWait
         CVD   R0,@H_DBLWD              Pack it
         MVC   @H_DBLWD(4),=X'40202120' Move mask
         LA    R1,@H_DBLWD+3            Set up start marker
         EDMK  @H_DBLWD(4),@H_DBLWD+6   Edit it
         LA    R14,@H_DBLWD+3           Last possible character
         SR    R14,R1                   Length of result
         LR    R15,R1                   A(Source)
         AHI   R15,-3                   Adjust it
         LA    R1,VolTbl_Ent_ErrMsg+L'H_MsgU522A A(Target)
         EX    R14,H_MVC                Move MaxLWait
         LA    R1,1(R1,R14)             Point last it
         MVC   0(L'H_MsgU522B,R1),H_MsgU522B Move remainder
         J     H00210                   and skip
H00170   DS    0H
         L     R15,=AL4(H_LSPACE_Msgs)  A(Message Table)
         LA    R14,0                    Clear work register
H00180   DS    0H
         CLC   0(1,R15),@H_LSPACE+LSPAERCD-LSPACE_Parm  Our RC?
         JNE   H00190                   No, skip
         CLI   1(R15),X'00'             Yes, should we check SubFunc?
         JE    H00200                   No, use this message
         CLC   1(1,R15),@H_LSPACE+LSPASFID-LSPACE_Parm  Yes, our SF?
         JE    H00200                   Yes, skip
H00190   DS    0H
         CLC   0(2,R15),=X'0000'        No, last entry?
         JE    H00200                   Yes, we'd better use it
         IC    R14,2(0,R15)             No, get len of message
         LA    R15,3(R14,R15)           Point to next entry
         J     H00180                   and check it out

H00200   DS    0H
         IC    R14,2(0,R15)             Length of the message
         AHI   R14,-1                   EX Len
         LA    R1,VolTbl_Ent_ErrMsg     A(Target)
         EX    R14,H_MVC                Move the message
         LA    R14,1(R1,R14)            Point past it
         MVC   0(29,R14),=C', DADSM/CVAF Diagnostic Info:'
         MVO   @H_DBLWD(5),@H_LSPACE+LSPAERCD-LSPACE_Parm(4)
         OI    @H_DBLWD+4,X'0F'         'Pack' it
         UNPK  29(9,R14),@H_DBLWD(5)    Unpack it
         MVI   29(R14),C' '             Move separator
         LA    R15,H_TrTbl              Point to translate table
         AHI   R15,-240                 Adjust pointer
         TR    30(8,R14),0(R15)         Make it readable
H00210   DS    0H
         J     H00380                   Go process next volume

H00220   DS    0H
*---------------------------------------------------------------------*
*     LSPACE worked, so re-calculate the average time used by LSPACE  *
*---------------------------------------------------------------------*
         L     R3,@H_LSPACE_Avg_Ptr     A(Timer area)
H00230   DS    0H
         LM    R0,R1,0(R3)              Get Avg ms, nbr LSPACEs done
         LR    R15,R0                   Get Avg micro-secs
         MR    R14,R1                   Calculate total micro-secs
         AL    R15,@H_LSPACE_Wait+4     Add the ones we used
         BRC   12,H00240                No carry, skip
         AL    R14,=FL4'1'              Carry, bump
H00240   DS    0H
         AL    R14,@H_LSPACE_Wait       Bump total WAIT time
         LR    R4,R1                    Get total LSPACEs completed
         AHI   R4,1                     Bump because we just finished
         DR    R14,R4                   Re-calculate average
         LR    R14,R15                  Set up new values for
         LR    R15,R4                    Avg, # completed LSPACEs
         CDS   R0,R14,0(R3)             Update them
         JNE   H00230                   Collision, try again

*---------------------------------------------------------------------*
*     If the previous volume we processed wasn't on the same device   *
*    type as this one, use TRKCALC to get the track size              *
*---------------------------------------------------------------------*
         CLC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB Same?
         JE    H00270                   Yes, skip
         MVC   @H_UCBTBYT4,VolTbl_Ent_UCBCopy+UCBTBYT4-UCBOB No
         TRKCALC FUNCTN=TRKBAL,         Track balance                  +
               TYPE=@H_UCBTBYT4,         A(Type)                       +
               LOC=ANY,                  which is above the line       +
               R=1,                      an empty track                +
               K=0,                      no keys                       +
               DD=VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4,  max size         +
               REMOVE=NO,                Use an empty track            +
               MAXSIZE=YES,              Return max we can use         +
               REGSAVE=YES,              Save registers                +
               MF=(E,@H_TRKCALC)         staying re-entrant
         CHI   R15,12                    How did it go?
         JNL   H00250                    Not good, set default
         LTR   R0,R0                     Did we get a size back?
         JNZ   H00260                    Yes, OK
H00250   DS    0H
         LH    R0,VolTbl_Ent_DSCB+DS4DEVTK-IECSDSL4 No, use default
         XC    @H_UCBTBYT4,@H_UCBTBYT4
H00260   DS    0H
         ST    R0,@H_BytesPerTrack       Save bytes per track
H00270   DS    0H

*---------------------------------------------------------------------*
*     Format the LSPACE info about this volume, and update our        *
*    totals ...                                                       *
*---------------------------------------------------------------------*
         L     R15,@H_Total_Vols_OK     Get total valid volumes
         AHI   R15,1                    Bump it
         ST    R15,@H_Total_Vols_OK     Save it

*     Tracks in the VTOC

         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Get Trks/Cyl
         LA    R1,0                     Clear register
         ICM   R1,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+6-IECSDSL4 Ending CC
         LA    R15,0                    Clear register
         ICM   R15,B'0011',VolTbl_Ent_DSCB+DS4VTOCE+2-IECSDSL4
         SR    R1,R15                   End CC minus start CC
         MR    R0,R0                          Get nbr tracks
         AH    R1,VolTbl_Ent_DSCB+DS4VTOCE+8-IECSDSL4 Add ending HH
         SH    R1,VolTbl_Ent_DSCB+DS4VTOCE+4-IECSDSL4 Less starting HH
         AHI   R1,1                     Bump it
         CDFBR R0,R1                    Convert to floating point
         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field
         BRAS  R14,H03000               Put in table

         STD   R0,VolTbl_Ent_Sort_VTOCTrk Save it
         ADB   R0,@H_Total_VTOCTrk      Bump total
         STD   R0,@H_Total_VTOCTrk       and save it

*     Total DSCBS in the VTOC

         LA    R0,0                     Clear work reg
         IC    R0,VolTbl_Ent_DSCB+DS4DEVDT-IECSDSL4 DSCBS/Trk
         CDFBR R0,R0                    Convert to floating point
         MDB   R0,VolTbl_Ent_Sort_VTOCTrk Nbr tracks in the VTOC

         STD   R0,@H_TotDSCB            Save it
         ADB   R0,@H_Total_DSCBs        Bump total
         STD   R0,@H_Total_DSCBs        and save it

*     Free DSCBs in the VTOC

         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs
         CDFBR R0,R1                    Convert to floating point
         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field
         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field
         BRAS  R14,H03000               Put in table

         STD   R0,VolTbl_Ent_Sort_FreeDSCB Save for sorting
         ADB   R0,@H_Total_FreeDSCBs    Bump total
         STD   R0,@H_Total_FreeDSCBs    and save it

*     % Free DSCBs in the VTOC

         L     R1,VolTbl_Ent_LSPACE_Data+LSPDF0S-LSPACE_Data Free DSCBs
         CDFBR R0,R1                    Convert to floating point
         MDB   R0,=DBL8'1000'           100.0%
         DDB   R0,@H_TotDSCB            Calc % free DSCBs
         LA    R1,VolTbl_Ent_VTOCFree   Point to target field
         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field
         BRAS  R14,H03000               Put in table

         DDB   R0,=DBL8'10'             back to xx.x%
         STD   R0,VolTbl_Ent_Sort_VTOCFree Save it

*     Total bytes on the volume

         LA    R0,0                     Clear register
         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl
         CDFBR R0,R0                    Convert to floating point
         LA    R0,0                     Clear register
         ICM   R0,B'0011',VolTbl_Ent_DSCB+DS4DEVSZ-IECSDSL4 Cyls/Device
         CDFBR R2,R0                    Convert to floating point
         MDBR  R0,R2                    Get Trks/Device
         LA    R0,0                     Clear work register
         L     R0,@H_BytesPerTrack      Bytes/Trk
         CDFBR R2,R0                    Convert to floating point
         MDBR  R0,R2                    Bytes/Device
         STD   R0,VolTbl_Ent_Sort_VolSize Save for sorting
         STD   R0,@H_VolSize            Save it
         LA    R1,VolTbl_Ent_VolSize    Point to output field
         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field
         BRAS  R14,H03000               Put in table

         ADB   R0,@H_Total_VolSize      Bump total
         STD   R0,@H_Total_VolSize      and save it

*     Nbr Free Extents on the volume

         L     R1,VolTbl_Ent_LSPACE_Data+LSPDNEXT-LSPACE_Data Free ext
         CDFBR R0,R1                    Convert to floating point
         LA    R1,VolTbl_Ent_FreeExt    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field
         BRAS  R14,H03000               Put in table

         STD   R0,VolTbl_Ent_Sort_FreeExt Save for sorting
         ADB   R0,@H_Total_Extents      Bump total
         STD   R0,@H_Total_Extents      and save it

*     Free Tracks on the volume

         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls
         CDFBR R0,R0                    Convert to floating point
         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl
         CDFBR R2,R0                    Convert to floating point
         MDBR  R0,R2                    Get nbr free trks (in cyls)
         L     R0,VolTbl_Ent_LSPACE_Data+LSPDTTRK-LSPACE_Data Free trks
         CDFBR R2,R0                    Convert to floating point
         ADBR  R0,R2                    Bump nbr trks
         STD   R0,VolTbl_Ent_Sort_FreeTrk Save for sorting
         LA    R1,VolTbl_Ent_FreeTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field
         BRAS  R14,H03000               Put in table

         ADB   R0,@H_Total_FreeTracks   Bump total
         STD   R0,@H_Total_FreeTracks   and save it

*     Free Bytes on the volume

         LD    R0,VolTbl_Ent_Sort_FreeTrk Get nbr free tracks
         LA    R0,0                     Clear work register
         L     R0,@H_BytesPerTrack      Bytes/Trk
         CDFBR R2,R0                    Convert to Floating point
         MDBR  R0,R2                    Nbr free bytes
         STD   R0,VolTbl_Ent_Sort_FreeBytes Save for sorting
         LA    R1,VolTbl_Ent_FreeBytes  Point to output field
         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field
         BRAS  R14,H03000               Put in table

         ADB   R0,@H_Total_FreeBytes    Bump totals
         STD   R0,@H_Total_FreeBytes    and save it

*     % Free space on the volume

         LD    R0,VolTbl_Ent_Sort_FreeBytes Free Bytes on the volume
         MDB   R0,=DBL8'1000'           Set up for % calc (100.0%)
         DDB   R0,@H_VolSize            Divide by Bytes/Device
         LA    R1,VolTbl_Ent_FreePct    Point to output field
         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field
         BRAS  R14,H03000               Put in table

         DDB   R0,=DBL8'10'             Convert to xx.x%
         STD   R0,VolTbl_Ent_Sort_FreePct Save it

*     Free Cylinders on the volume

         L     R1,VolTbl_Ent_LSPACE_Data+LSPDTCYL-LSPACE_Data Free Cyls
         CDFBR R0,R1                    Convert to floating point
         LA    R1,VolTbl_Ent_FreeCyl    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field
         BRAS  R14,H03000               Put in table

         STD   R0,VolTbl_Ent_Sort_FreeCyl Save for sorting
         ADB   R0,@H_Total_FreeCyls     Bump totals
         STD   R0,@H_Total_FreeCyls     and save it

*     Largest extent (in tracks) on the volume

         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls
         CDFBR R0,R0                    Convert to FP
         LH    R0,VolTbl_Ent_DSCB+DS4DEVSZ+2-IECSDSL4 Trks/Cyl
         CDFBR R2,R0                    Convert to FP
         MDBR  R0,R2                    Get nbr trks
         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLTRK-LSPACE_Data Get trks
         CDFBR R2,R0                    Convert to FP
         ADBR  R0,R2                    Add to total
         STD   R0,VolTbl_Ent_Sort_LargTrk Save for sorting
         LA    R1,VolTbl_Ent_LargTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field
         BRAS  R14,H03000               Put in table

         CDB   R0,@H_Largest_FreeTracks Biggest so far?
         JNH   H00280                   No, skip
         STD   R0,@H_Largest_FreeTracks Yes, save it

H00280   DS    0H

*     Largest extent (in cylinders) on the volume

         L     R0,VolTbl_Ent_LSPACE_Data+LSPDLCYL-LSPACE_Data Larg Cyls
         CDFBR R0,R0                    Convert to floating point
         LA    R1,VolTbl_Ent_LargCyl    Point to output field
         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field
         BRAS  R14,H03000               Put in table

         STD   R0,VolTbl_Ent_Sort_LargCyl Save for sorting
         CDB   R0,@H_Largest_FreeCyls   Largest so far?
         JNH   H00290                   No, skip
         STD   R0,@H_Largest_FreeCyls   Yes, save it

H00290   DS    0H
*---------------------------------------------------------------------*
*     VTOC IX Status: A - Active                                      *
*                     E - Exists, but not active                      *
*                     N - Does not exist                              *
*---------------------------------------------------------------------*
         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXAC
         JO    H00300                   Yes, skip
         TM    VolTbl_Ent_LSPACE_Data+LSPDSTAT-LSPACE_Data,LSPDIXDS IX?
         JO    H00310                   Yes, skip
         MVI   VolTbl_Ent_VTOCIX+1,C'N' No, No IX VTOC
         J     H00320                   and skip
H00300   DS    0H
         MVI   VolTbl_Ent_VTOCIX+1,C'A' IX VTOC active
         J     H00320                   and skip
H00310   DS    0H
         MVI   VolTbl_Ent_VTOCIX+1,C'Y' IX VTOC exists
         J     H00320                   and skip

H00320   DS    0H
*---------------------------------------------------------------------*
*     Fragmentation Index                                             *
*---------------------------------------------------------------------*
         L     R0,VolTbl_Ent_LSPACE_Data+LSPDFRAG-LSPACE_Data Frag Indx
         CHI   R0,999                   Too big?
         JNH   H00330                   No, OK
         LHI   R0,999                   Yes, set to max
H00330   DS    0H
         CDFBR R0,R0                    Convert to floating point
         LHI   R0,L'VolTbl_Ent_Frag_Indx Len of target field
         LA    R1,VolTbl_Ent_Frag_Indx  Point to it
         BRAS  R14,H03000               Go format it

         ADB   R0,@H_Total_FragIndex    Bump totals
         STD   R0,@H_Total_FragIndex    and save it

*---------------------------------------------------------------------*
*     SMS Anomaly                                                     *
*---------------------------------------------------------------------*
         CLI   VolTbl_Ent_DSCB+DS4SMSFG-IECSDSL4,DS4NTSMS SMS in VTOC?
         JE    H00340                   No, skip
         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS Yes, UCB SMS too?
         JO    H00370                   Yes, OK
         J     H00350                   No, set message
H00340   DS    0H
         TM    VolTbl_Ent_UCBCOPY+UCBFL5-UCBOB,UCBSMS NO, UCB = SMS?
         JZ    H00370                   No, OK
H00350   DS    0H
         MVI   VolTbl_Ent_VTOC_SMS,C'*' No, flag it
         ICM   R14,B'1111',@H_SMS_Anomaly_Ptr  Yes, A(SMS Anomaly line)
         JZ    H00370                   None, skip
         TM    VolTbl_Ent_ECB-VolTbl_Ent(R14),X'40' Already done?
         JO    H00370                   Yes, skip
         LA    R0,VolTbl_Ent_VTOC_SMS-VolTbl_Ent(0,R14) A(Target)
         LHI   R1,VolTbl_Ent_Display_End-VolTbl_Ent_VTOC_SMS Target Len
         LA    R14,H_SMS_Anomaly_Msg    A(Source)
         LA    R15,L'H_SMS_Anomaly_Msg  Source length
         O     R15,=XL4'40000000'       Fill with blanks
         MVCL  R0,R14                   Move message

         L     R15,@H_SMS_Anomaly_Ptr   A(SMS Anomaly line)
         L     R0,VolTbl_Ent_ECB-VolTbl_Ent(R15) Current ECB
         TM    VolTbl_Ent_ECB-VolTbl_Ent(R15),X'80' Anyone WAITing?
         JO    H00360                   Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB-VolTbl_Ent(R15) Pseudo-POST it
         JZ    H00370                   OK, skip the real POST
H00360   DS    0H
         POST  VolTbl_Ent_ECB-VolTbl_Ent(R15),0 POST line as complete
H00370   DS    0H

H00380   DS    0H
*---------------------------------------------------------------------*
*     POST this entry as complete ...                                 *
*---------------------------------------------------------------------*
         L     R14,VolTbl_Ent_ECB       Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    H00390                   Yes, we need to POST
         L     R15,=XL4'40000000'       No, POST code of 0
         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it
         JZ    H00400                   OK, skip the real POST
H00390   DS    0H
         POST  VolTbl_Ent_ECB,0         Flag as complete
H00400   DS    0H

H00410   DS    0H
*---------------------------------------------------------------------*
*     ... and see if we can find another volume to do.                *
*---------------------------------------------------------------------*
         AHI   R9,VolTbl_Ent_Len        Point to next VolTbl_Ent
         BRCT  R10,H00050               and check it out

*---------------------------------------------------------------------*
*     We are done - update the totals, if required ...                *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@H_Totals_Line_Ptr   A(Totals Line)
         JZ    H00560                   None, skip

H00420   DS    0H
         L     R0,VolTbl_Ent_Total_Vols_OK Curr count
         LR    R1,R0                    Save it
         A     R1,@H_Total_Vols_OK      Bump it
         CS    R0,R1,VolTbl_Ent_Total_Vols_OK Update it
         JNZ   H00420                   Collision, try again

         LD    R0,@H_Total_VTOCTrk      Amount we did
H00430   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_VTOCTrk Orig Val
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get new totals
         CDS   R0,R2,VolTbl_Ent_Total_VTOCTrk Update it
         JNZ   H00430                   Collision, try again

         LD    R0,@H_Total_DSCBs        Get amount we did
H00440   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_DSCBs
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_DSCBs Update it
         JNZ   H00440                   Collision, try again

         LD    R0,@H_Total_FreeDSCBs    Get amount we did
H00450   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_FreeDSCBs
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_FreeDSCBs Update
         JNZ   H00450                   Collision, try again

         LD    R0,@H_Total_VolSize      Get amount we did
H00460   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_VolSize
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_VolSize Update it
         JNZ   H00460                   Collision, try again

         LD    R0,@H_Total_Extents      Get amount we did
H00470   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_Extents
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_Extents Update it
         JNZ   H00470                   Collision, try again

         LD    R0,@H_Total_FreeTracks   Get amount we did
H00480   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_FreeTracks
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_FreeTracks Update
         JNZ   H00480                   Collision, try again

         LD    R0,@H_Total_FreeBytes    Get amount we did
H00490   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_FreeBytes
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_FreeBytes Update
         JNZ   H00490                   Collision, try again

         LD    R0,@H_Total_FreeCyls     Get amount we did
H00500   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_FreeCyls
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_FreeCyls Update
         JNZ   H00500                   Collision, try again

         LD    R0,@H_Largest_FreeTracks Get the biggest we did
H00510   DS    0H
         LM    R0,R1,VolTbl_Ent_Largest_FreeTracks
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         CDBR  R0,R2                    Biggest so far?
         JNH   H00520                   No, skip
         STD   R0,@H_DBLWD              Yes, save new largest
         LM    R2,R3,@H_DBLWD           Get old, new values
         CDS   R0,R2,VolTbl_Ent_Largest_FreeTracks
         JNZ   H00510                   Collision, try again

H00520   DS    0H

         LD    R0,@H_Largest_FreeCyls   Get the largest we did
H00530   DS    0H
         LM    R0,R1,VolTbl_Ent_Largest_FreeCyls
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         CDBR  R0,R2                    Biggest so far?
         JNH   H00540                   No, skip
         STD   R0,@H_DBLWD              Yes, save new largest
         LM    R2,R3,@H_DBLWD           Get old, new values
         CDS   R0,R2,VolTbl_Ent_Largest_FreeCyls
         JNZ   H00530                   Collision, try again

H00540   DS    0H

         LD    R0,@H_Total_FragIndex    Yes, bump totals
H00550   DS    0H
         LM    R0,R1,VolTbl_Ent_Total_FragIndex
         STM   R0,R1,@H_DBLWD           Save original value
         LD    R2,@H_DBLWD              Load up FP register
         ADBR  R2,R0                    Bump it
         STD   R2,@H_DBLWD              Save updated total
         LM    R2,R3,@H_DBLWD           Get old, new totals
         CDS   R0,R2,VolTbl_Ent_Total_FragIndex Update
         JNZ   H00550                   Collision, try again

H00560   DS    0H
*---------------------------------------------------------------------*
*     ... and then the total number of volumes we did                 *
*---------------------------------------------------------------------*
         L     R15,@H_VolTbl_Ptr        A(Volume Table)
         L     R0,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Get current
         LR    R1,R0                    Save it
         A     R1,@H_Total_Vols_Proc    Bump it
         CS    R0,R1,VolTbl_Hdr_Vols_Proc-VolTbl_Hdr(R15) Update it
         JNZ   H00560                   Collision, try again

*---------------------------------------------------------------------*
*     If this completes the table, fill in the totals, if required    *
*---------------------------------------------------------------------*
         C     R1,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All done?
         JL    H00610                   No, skip
         OI    @H_VolTbl_Complete,L'@H_VolTbl_Complete Yes, flag it

         ICM   R9,B'1111',@H_Totals_Line_Ptr A(Totals line)
         JZ    H00590                   None, all done

         LD    R0,VolTbl_Ent_Total_VolSize Get Total bytes
         LTDBR R0,R0                    Any?
         JZ    H00570                   No, we're done with the totals

         LD    R0,VolTbl_Ent_Total_FreeTracks Total free tracks
         LA    R1,VolTbl_Ent_FreeTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeTrk  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_FreeCyls Total Free Cyls
         LA    R1,VolTbl_Ent_FreeCyl    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeCyl  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes
         DDB   R0,VolTbl_Ent_Total_Volsize divided by total bytes
         MDB   R0,=DBL8'1000'           Set up as a % (100.0)
         LA    R1,VolTbl_Ent_FreePct    Point to output field
         LHI   R0,L'VolTbl_Ent_FreePct  Length of output field
         BRAS  R14,H03000               Put in table
         DDB   R0,=DBL8'10'             back to xx.x
         STD   R0,VolTbl_Ent_Total_FreePct Save it

         LD    R0,VolTbl_Ent_Total_FreeBytes Total Free Bytes
         LA    R1,VolTbl_Ent_FreeBytes  Point to output field
         LHI   R0,L'VolTbl_Ent_FreeBytes Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_Extents Total Extents
         LA    R1,VolTbl_Ent_FreeExt    Point to output field
         LHI   R0,L'VolTbl_Ent_FreeExt  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Largest_FreeCyls Largest Free Cyls
         LA    R1,VolTbl_Ent_LargCyl    Point to output field
         LHI   R0,L'VolTbl_Ent_LargCyl  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Largest_FreeTracks Largest Free Tracks
         LA    R1,VolTbl_Ent_LargTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_LargTrk  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_VTOCTrk Total VTOC tracks
         LA    R1,VolTbl_Ent_VTOCTrk    Point to output field
         LHI   R0,L'VolTbl_Ent_VTOCTrk  Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_FreeDSCBs Total Free DSCBs
         LA    R1,VolTbl_Ent_FreeDSCB   Point to output field
         LHI   R0,L'VolTbl_Ent_FreeDSCB Length of output field
         BRAS  R14,H03000               Put in table

         LD    R0,VolTbl_Ent_Total_FreeDSCBs Get Total Free DSCBs
         DDB   R0,VolTbl_Ent_Total_DSCBs Get percent free
         MDB   R0,=DBL8'1000'           * 100.0
         LA    R1,VolTbl_Ent_VTOCFree   Point to output field
         LHI   R0,L'VolTbl_Ent_VTOCFree Length of output field
         BRAS  R14,H03000               Put in table
         MDB   R0,=DBL8'10'             back to xx.x
         STD   R0,VolTbl_Ent_Total_VTOCFree Save it

         LD    R0,VolTbl_Ent_Total_VolSize Get Total Bytes
         LA    R1,VolTbl_Ent_VolSize    Point to output field
         LHI   R0,L'VolTbl_Ent_VolSize  Length of output field
         BRAS  R14,H03000               Put in table

         L     R0,VolTbl_Ent_Total_Vols_OK Number of volumes with data
         CDFBR R2,R0                    Convert to floating point
         LD    R0,VolTbl_Ent_Total_FragIndex Get Total Frag Index
         DDBR  R0,R2                    Get avg frag index
         LA    R1,VolTbl_Ent_Frag_Indx  Point to output field
         LHI   R0,L'VolTbl_Ent_Frag_Indx Length of output field
         BRAS  R14,H03000               Put in table

H00570   DS    0H
*---------------------------------------------------------------------*
*     ... POST it as complete ...                                     *
*---------------------------------------------------------------------*
         L     R14,VolTbl_Ent_ECB       Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    H00580                   Yes, we need to POST
         L     R15,=XL4'40000000'       No, POST code of 0
         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it
         JZ    H00590                   OK, skip the real POST
H00580   DS    0H
         POST  VolTbl_Ent_ECB,0         Flag as complete

H00590   DS    0H
*---------------------------------------------------------------------*
*     ... if the SMS anomaly line has not been completed (because     *
*    there was no SMS anomaly), flag it as complete now               *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@H_SMS_Anomaly_Ptr A(SMS Anomaly line)
         JZ    H00610                   None, skip
         TM    VolTbl_Ent_ECB,X'40'     Already POSTed?
         JO    H00610                   Yes, skip
         L     R14,VolTbl_Ent_ECB       Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    H00600                   Yes, we need to POST
         L     R15,=XL4'40000000'       No, POST code of 0
         CS    R14,R15,VolTbl_Ent_ECB   Pseudo-POST it
         JZ    H00610                   OK, skip the real POST
H00600   DS    0H
         POST  VolTbl_Ent_ECB,0         Flag as complete

H00610   DS    0H
*---------------------------------------------------------------------*
*     Fill in our Stats line, if present                              *
*---------------------------------------------------------------------*
         ICM   R9,B'1111',@H_Stats_Line_Ptr A(1st Stats Heading line)
         JZ    H00730                   None, skip

*---------------------------------------------------------------------*
*     If the headings haven't yet been filled in (i.e., we are the    *
*    first ones here), fill them in ...                               *
*---------------------------------------------------------------------*
         LA    R2,H_SubTask_Hdgs        A(Start of headings)
         LA    R4,H_SubTask_Hdg_Lens    A(Lengths of heading lines)
         LHI   R5,H_SubTask_Hdg_Count   Get nbr heading lines
H00620   DS    0H
         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?
         JNZ   H00650                   Yes, try next

         L     R1,VolTbl_Ent_Processed  No, get the Flag byte
         LA    R0,L'VolTbl_Ent_Processed Set up the
         SLL   R0,24                     flag turned
         OR    R0,R1                     on
         CS    R1,R0,VolTbl_Ent_Processed and update it
         JNE   H00650                   Somebody else here, skip it

         LH    R3,0(0,R4)               Len of heading line
         O     R3,=XL4'40000000'        Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,L'VolTbl_Ent_Display  Length of target
         MVCL  R0,R2                    Move heading
         OI    VolTbl_Ent_Stats_Done,l'VolTbl_Ent_Stats_Done Done

         L     R0,VolTbl_Ent_ECB        Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    H00630                   Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it
         JZ    H00640                   OK, skip the real POST
H00630   DS    0H
         POST  VolTbl_Ent_ECB,0         POST line as complete
H00640   DS    0H

H00650   DS    0H
         AHI   R9,VolTbl_Ent_Len        Bump entry pointer
         AHI   R4,2                     Bump lengths pointer
         BRCT  R5,H00620                and try again

*---------------------------------------------------------------------*
*     Headings all done, find an unused entry for our subtask stats   *
*    At this point, R9 points to the line after the subtask hdgs.     *
*---------------------------------------------------------------------*
         L     R14,@H_VolTbl_Ptr        A(VolTbl)
         AHI   R14,VolTbl_Ent-VolTbl_Hdr  A(1st entry)
         LR    R15,R9                   A(Our entry
         SR    R15,R14                  Offset of our line
         LA    R14,0                    Clear R14
         LHI   R0,VolTbl_Ent_Len        Length of 1 entry
         DR    R14,R0                   Get our entry num
         S     R15,=FL4'1'              Relative to 0
         JM    H00730                   Negative, skip it
         L     R10,@H_VolTbl_Ptr        A(VolTbl) again
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(0,R10) Nbr entries
         SR    R10,R15                  Nbr entries remaining
         JNP   H00730                   None, skip it
         LR    R3,R10                   Init SubTask Nbr
H00660   DS    0H
         TM    VolTbl_Ent_Processed,L'VolTbl_Ent_Processed Done?
         JNZ   H00670                   Yes, try next

         L     R1,VolTbl_Ent_Processed  No, get the Flag byte
         LA    R0,L'VolTbl_Ent_Processed Set up the
         SLL   R0,24                     flag turned
         OR    R0,R1                     on
         CS    R1,R0,VolTbl_Ent_Processed and update it
         JE    H00680                   OK, skip
H00670   DS    0H
         AHI   R9,VolTbl_Ent_Len        Bump entry pointer
         BRCT  R10,H00660               and try again
         J     H00730                   None, skip it
H00680   DS    0H
*---------------------------------------------------------------------*
*     Output our subtask stats.  Note that if we did all the volumes, *
*   we were BASR'd to, rather than ATTACHed. In this case, we do      *
*   not put out the 1st and 3rd fields (SubTask Nbr and CPU Time).    *
*---------------------------------------------------------------------*
         L     R14,=AL4(H_SubTask_Line) A(Stats line skeleton)
         LHI   R15,H_SubTask_Line_Len   Len of skeleton
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LA    R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move skeleton

         L     R15,@H_Total_Vols_Proc   Total volumes
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_TotVol-H_SubTask_Line(+
               L'H_SubTask_Line_TotVol),@H_DBLWD+5

         L     R0,@H_Total_Vols_Proc    Number of volumes we did
         L     R15,@H_VolTbl_Ptr        A(Volume Table)
         C     R0,VolTbl_Hdr_Vols_Total-VolTbl_Hdr(R15) All us?
         JL    H00690                   No, others here too
         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+1-H_SubTask_Line(L+
               'H_SubTask_Line_Nbr-1),VolTbl_Ent_Display+H_SubTask_Line+
               _Nbr-H_SubTask_Line      Clear ED mask
         MVC   VolTbl_Ent_Display+H_SubTask_Line_Nbr+L'H_SubTask_Line_N+
               br-3-H_SubTask_Line(3),=C'N/A'
         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+1-H_SubTask_Line(L+
               'H_SubTask_Line_CPU-1),VolTbl_Ent_Display+H_SubTask_Line+
               _CPU-H_SubTask_Line      Clear ED mask
         MVC   VolTbl_Ent_Display+H_SubTask_Line_CPU+L'H_SubTask_Line_C+
               PU-3-H_SubTask_Line(3),=C'N/A'
         J     H00700                   and skip

H00690   DS    0H
         SR    R3,R10                   SubTask nbr
         AHI   R3,1                     Relative to 1
         CVD   R3,@H_DBLWD              Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_Nbr-H_SubTask_Line(L'H+
               _SubTask_Line_Nbr),@H_DBLWD+6

         TIMEUSED STORADR=@H_DBLWD,     Get CPU time used              +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               CPU=MIC                   get it in microseconds
         LM    R14,R15,@H_DBLWD         Get microseconds
         D     R14,=FL4'1000'           Convert to milliseconds
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_CPU-H_SubTask_Line(L'H+
               _SubTask_Line_CPU),@H_DBLWD+5

H00700   DS    0H
         L     R15,@H_Total_Vols_OK     Volumes where LSPACE worked
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_OK-H_SubTask_Line(+
               L'H_SubTask_Line_Vol_OK),@H_DBLWD+5

         LM    R14,R15,@H_Total_LSPACE_Wait_OK Good LSPACE time (usec)
         D     R14,=FL4'1000'           Convert to milliseconds
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_OK-H_SubTask_Line+
               (L'H_SubTask_Line_Wait_OK),@H_DBLWD+5

         L     R15,@H_Total_Vols_Proc   Total volumes
         S     R15,@H_Total_Vols_OK      minus ones where LSPACE OK
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_Vol_Bad-H_SubTask_Line+
               (L'H_SubTask_Line_Vol_Bad),@H_DBLWD+5

         LM    R14,R15,@H_Total_LSPACE_Wait_Bad Fail LSPACE time (usec)
         D     R14,=FL4'1000'           Convert to milliseconds
         CVD   R15,@H_DBLWD             Pack it
         ED    VolTbl_Ent_Display+H_SubTask_Line_Wait_Bad-H_SubTask_Lin+
               e(L'H_SubTask_Line_Wait_Bad),@H_DBLWD+5


         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done

         L     R0,VolTbl_Ent_ECB        Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    H00710                   Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it
         JZ    H00720                   OK, skip the real POST
H00710   DS    0H
         POST  VolTbl_Ent_ECB,0         POST line as complete
H00720   DS    0H


H00730   DS    0H
*---------------------------------------------------------------------*
*     If we are the last ones here (i.e., we finished VolTbl),        *
*    flag the table as complete                                       *
*---------------------------------------------------------------------*
         TM    @H_VolTbl_Complete,L'@H_VolTbl_Complete All done?
         JNO   H00750                   No, skip

         L     R10,@H_VolTbl_Ptr        A(VolTbl)
         L     R14,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Contents of our ECB
         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R10),X'80' Anyone WAITing?
         JO    H00740                   Yes, we need to POST
         L     R15,=XL4'40000000'       No, POST code of 0
         CS    R14,R15,VolTbl_Hdr_ECB-VolTbl_Hdr(R10) Pseudo-POST it
         JZ    H00750                   OK, skip the real POST
H00740   DS    0H
         POST  VolTbl_Hdr_ECB-VolTbl_Hdr(R10),0 Flag as complete
H00750   DS    0H

         J     H90010                   All done, exit


* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *

H03000   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Format and scale a long binary FP number                          *
*                                                                     *
*   On Entry, FP0     = Long FP value                                 *
*             GPR 0   = Length of Target Field                        *
*             GPR 1   = A(Target field)                               *
*                                                                     *
*   On Exit,  N/A                                                     *
*                                                                     *
*   Notes: This routine should only be used for output fields with    *
*          lengths if 4, 5, or 6.                                     *
*          Output fields of length = 4 are assumed to be percents.    *
*          Values destined for output fields with lengths of 5 or 6   *
*          will be scaled, if necessary. All scaled values will have  *
*          a single decimal point.                                    *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LDR   R6,R0                    Save FP R0

         LA    R15,0                    Clear scale indicator
         CHI   R0,5                     Check output length
         JL    H03040                   a %, skip scaling
         JH    H03010                   6-char field, skip
         LD    R2,=DBL8'10000'          Max value + 1
         J     H03020
H03010   DS    0H
         LD    R2,=DBL8'100000'         Max value + 1
H03020   DS    0H
         CDBR  R0,R2                    Do we have to scale?
         JNH   H03040                   No, skip
         LTR   R15,R15                  Have we scaled already?
         JNZ   H03030                   Yes, skip
         DDB   R2,=DBL8'100'            No, max val +1
H03030   DS    0H
         DDB   R0,=DBL8'1000'           Divide by 1000
         AHI   R15,1                    Bump scaling factor
         J     H03020                   and check again

H03040   DS    0H
         LTR   R15,R15                  Did we have to scale it?
         JZ    H03050                   No, skip
         MVC   @H_MaskArea,=X'40202021204B2040' Yes, move mask
         LA    R15,H_Scale-1(R15)       Get scaling factor
         MVC   @H_Scale,0(R15)          Save it
         MDB   R0,=DBL8'10'             Add a decimal point
         J     H03070                   and skip
H03050   DS    0H
         CHI   R0,5                     Is this a percent?
         JNL   H03060                   No, skip
         MVC   @H_MaskArea,=X'4040202021204B20' Yes, move mask
         CDB   R0,=DBL8'999.4'          Will we round up to 100%?
         JNH   H03070                   No, OK
         LD    R0,=DBL8'999.4'          Yes, set to 99.9%
         J     H03070                   and skip
H03060   DS    0H
         MVC   @H_MaskArea,=X'404020206B202120' Move mask
H03070   DS    0H
         CFDBR R15,B'0100',R0           Convert and round
         CVD   R15,@H_DBLWD             Pack it
         ED    @H_MaskArea,@H_DBLWD+5   Edit in the number
         CLI   @H_MaskArea+L'@H_MaskArea-1,C' ' Did we scale?
         JNE   H03080                   No, skip
         MVC   @H_MaskArea+L'@H_MaskArea-1(1),@H_Scale Yes, move factor
H03080   DS    0H
         LA    R15,@H_MaskArea+L'@H_MaskArea Point to
         SR    R15,R0                     start of our data
         MVC   @H_MaskArea,0(R15)       Left align in mask area
         LR    R15,R0                   Get length again
         AHI   R15,-1                   EX length
         L     R1,24(0,R13)             A(Target field)
         EX    R15,H_MVC1               Move to output field
H03090   DS    0H

         LM    R14,R12,12(R13)          Restore registers
         LDR   R0,R6                    Restore FP R0

         BR    R14                      and exit

* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *



H06000   DS    0H

*---------------------------------------------------------------------*
*     Our timer has expired - verify that we are in the middle of     *
*    LSPACE by checking that the PRB at the end of the RB chain has   *
*    issued an SVC 78 (LSPACE).                                       *
*     If SVC78 is active, or has not yet been issued,                 *
*        Establish an ESTAE with PURGE=HALT                           *
*        ABEND X'0522'                                                *
*     Else                                                            *
*        disappear quietly (we have popped after LSPACE completed, but*
*                           before the STIMERM was cancelled)         *
*---------------------------------------------------------------------*
         PUSH  USING                    Save our USING environment
         DROP  ,

         USING *,R15                    Assign temp base
         STM   14,12,12(13)             Save callers registers
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING H06000,R11               Assign permanent base
         L     R1,4(0,R1)               Get A(Parms passed)
         L     R10,0(0,R1)              Get A(Dynamic storage)
         USING @H_Dynam,R10             Assign a base

*        STM   R14,R1,@H6_Debug_Save    Save our registers
*        WTO   '&PGMNAME - STIMERM Exit popping'
*        LM    R14,R1,@H6_Debug_Save    Restore our registers

*---------------------------------------------------------------------*
*   We will be checking the RB chain, to verify that we are, indeed,  *
*  in LSPACE. If the ground should shift under us while we are doing  *
*  this, we may get an S0C4, or some such, and the CVAF ESTAE (with   *
*  PURGE=NONE) will be scheduled, and we will hang. We therefore      *
*  establish our PURGE=HALT ESTAE here.                               *
*---------------------------------------------------------------------*
*        STM   R14,R1,@H6_Debug_Save    Save our registers
*        WTO   '&PGMNAME - STIMERM Exit - establishing ESTAE'
*        LM    R14,R1,@H6_Debug_Save    Restore our registers

         MVC   @H6_ESTAE,H6_ESTAE       Move L-Form
         ESTAEX H06800,                 Establish ESTAE Exit           +
               CT,                       create it                     +
               PURGE=HALT,               terminating IO                +
               MF=(E,@H6_ESTAE)          keeping ourselves reentrant

*---------------------------------------------------------------------*
*   Chase down the RB chain for the last RB ...                       *
*---------------------------------------------------------------------*
         L     R14,PSATNEW-PSA(0)       Get A(our TCB)
         SLL   R14,8                    Clean
         SRL   R14,8                      it
         L     R15,TCBRBP-TCB(R14)      A(RB)
H06010   DS    0H
         L     R0,RBLINK-RBBASIC(R15)   A(Previous RB)
         SLL   R0,8                     Clean
         SRL   R0,8                       it
         CR    R0,R14                   Last RB (RBLINK = A(TCB))?
         JE    H06020                   Yes, skip
         LR    R15,R0                   No, point to previous RB
         J     H06010                   and keep trying
H06020   DS    0H

*---------------------------------------------------------------------*
*   ... and see if it is running SVC 78 (LSPACE)                      *
*---------------------------------------------------------------------*
         AHI   R15,-(RBPRFXND-RBPREFIX)   Back up to RB prefix
         CLC   =X'004E',RBINTCOD-RBPREFIX(R15) SVC 78?
         JE    H06030                   Yes, try to terminate

*        STM   R14,R1,@H6_Debug_Save    Save our registers
*        WTO   '&PGMNAME - STIMERM Exit - not in LSPACE'
*        LM    R14,R1,@H6_Debug_Save    Restore our registers

         ESTAEX 0                       No, delete our ESTAE

         RETURN (14,12),,RC=0           and return

H06030   DS    0H

*---------------------------------------------------------------------*
*   LSPACE is active, and, we assume, hung up. We have already set    *
*  up our ESTAE with PURGE=HALT, which, on an ABEND, will get control *
*  first, after the I/O is HALTed. This ESTAE merely percolates, so   *
*  that the CVAF and LSPACE ESTAEs can do their tricks, and we will   *
*  eventually end up in our ESTAE, which continues processing as if   *
*  LSPACE had failed.                                                 *
*---------------------------------------------------------------------*
*        STM   R14,R1,@H6_Debug_Save    Save our registers
*        WTO   '&PGMNAME - STIMERM Exit - ABENDing U0522'
*        LM    R14,R1,@H6_Debug_Save    Restore our registers

         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl Entry)
         JZ    H06040                   None, skup
         OI    VolTbl_Ent_U522-VolTbl_Ent(R9),L'VolTbl_Ent_U522
H06040   DS    0H
         ABEND X'0522'                  and abend with U522 (get it?)

H06800   DS    0H

*---------------------------------------------------------------------*
*   This is the Exit for the ESTAE established in the STIMERM exit.   *
*  This exit does nothing, merely returning to RTM with percolate.    *
*  It is only here because we need the first ESTAE on the queue to    *
*  have PURGE=HALT, so the I/O to the RESERVEd volume can be          *
*  terminated.                                                        *
*---------------------------------------------------------------------*
         LA    R15,0                    Percolate
         BSM   0,R14                     on return

H6_ESTAE ESTAEX 1,                      Establish ESTAE Exit           +
               CT,                       create it                     +
               PURGE=HALT,               PURGEing I/O                  +
               MF=L                      keeping ourselves reentrant
H6_ESTAE_Length EQU *-H6_ESTAE

         DROP  R11,R10                  Free up temp bases

         POP   USING                    Restore USING environment

*********************   Start of the ESTAE   **************************
*                                                                     *
*                                                                     *
         SPACE ,
H07000   DS    0H
         PUSH  USING                    Save the USING environment
         DROP  ,                        Drop all current USINGs
         SPACE ,
*---------------------------------------------------------------------*
*   This is the ESTAE routine. All this does is:                      *
*    Format an abend message                                          *
*    Invoke the retry routine                                         *
*                                                                     *
*   Note that we run with our own set of USINGs here.                 *
*---------------------------------------------------------------------*
         USING *,R15                    Assign temporary base
         CHI   R0,12                    Is there an SDWA?
         JE    H07010                   No, skip

*---------------------------------------------------------------------*
*   We have an SDWA, so load the appropriate registers:               *
*      R11 --> SDWA                                                   *
*      R1  =   Abend Code                                             *
*      R3  --> Parmarea                                               *
*---------------------------------------------------------------------*
         STM   R14,R11,12(R13)          Yes, save our registers
         LR    R11,R1                   Point to the SDWA
         L     R1,SDWAABCC-SDWA(R11)    Get the Abend code
         L     R3,SDWAPARM-SDWA(R11)    Point to our parm address
         L     R3,0(0,R3)               Point to our parms
         J     H07020                   and skip
H07010   DS    0H

*---------------------------------------------------------------------*
*   We don't have an SDWA, so clear R11 (the SDWA address)            *
*---------------------------------------------------------------------*
         LA    R11,0                    Clear A(SDWA)

H07020   DS    0H
*---------------------------------------------------------------------*
*   Load up the base for our storage, and tell the assembler.         *
*   At this point,                                                    *
*    R1  contains the ABEND code                                      *
*    R3  contains the address of @H_Dynam                             *
*    R11 contains the address of the SDWA, or 0                       *
*---------------------------------------------------------------------*
         LR    R12,R15                  Load a base register
         DROP  R15                      Free up temp base
         USING H07000,R12               Tell the assembler about R11
         USING @H_Dynam,R3              Assign a base for our parms

*---------------------------------------------------------------------*
*   Format our ABEND message                                          *
*---------------------------------------------------------------------*
         ST    R1,@H_DBLWD              Save completion code
         ICM   R9,B'1111',@H_Current_VolTbl_Ent A(VolTbl_Ent)
         JZ    H07050                   None, skip
         USING VolTbl_Ent,R9            Assign a base
         OI    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail No data
         CLC   =X'0522',@H_DBLWD+2      Is this U522 (STIMER pop)?
         J     H07050                   Yes, exit

         MVC   VolTbl_Ent_ErrMsg,=CL(L'VolTbl_Ent_ErrMsg)'**SubTask ABE+
               ND xxxx'
         MVI   VolTbl_Ent_ErrMsg+16,C'S' Assume system abend
         L     R15,@H_DBLWD             Get ABEND code
         SLL   R15,8                    Clear high-order byte and
         SRL   R15,20                    User Abend code
         LTR   R15,R15                  Is it a system Abend?
         JNZ   H07040                   Yes, skip
         MVI   VolTbl_Ent_ErrMsg+16,C'U' No, User abend
         L     R15,@H_DBLWD             Get Abend code
         SLL   R15,20                   Clear System
         SRL   R15,20                     Abend code
H07040   DS    0H
         SLL   R15,4                    Make room for 'sign'
         STH   R15,@H_DBLWD+6           Save it
         OI    @H_DBLWD+7,X'0F'         Make it packed
         UNPK  VolTbl_Ent_ErrMsg+17(3),@H_DBLWD+6(2) Unpack abend code
         LA    R15,H_TrTbl              Point to translate table
         S     R15,=FL4'240'            Adjust pointer
         TR    VolTbl_Ent_ErrMsg+17(3),0(R15) Make it readable
         DROP  R9                       Free up base

H07050   DS    0H
*---------------------------------------------------------------------*
*   We will be retrying, so we will no longer have an ESTAE. Turn off *
*  our flag, so that the retry routine will re-establish it ...       *
*---------------------------------------------------------------------*
         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now

*---------------------------------------------------------------------*
*   ... and retry, either with an SDWA ...                            *
*---------------------------------------------------------------------*
         LTR   R11,R11                  Is there an SDWA?
         JZ    H07060                   No, skip SDWA retry
         SPACE ,
         L     R4,@H_ESTAE_Retry        Yes, A(Retry routine)
         LA    R5,@H_ESTAE_RMask        A(Register mask)
         SETRP WKAREA=(11),             Set retry parms using this SDWA+
               RC=4,                     Retry                         +
               RETADDR=(4),              using this retry routine      +
               RETREGS=YES,              and our registers             +
               RUB=(5),                  which live here               +
               FRESDWA=YES,              and get rid of the SDWA       +
               REGS=(14,12)              Return to RTM

H07060   DS    0H
*---------------------------------------------------------------------*
*   ... or without                                                    *
*---------------------------------------------------------------------*
         L     R0,@H_ESTAE_Retry         A(Retry routine)
         LM    R1,R13,@H_ESTAE_Regs+4    Restore regs
         LA    R15,4                     Retry
         BR    R14                       go do it


         DROP  ,                        Drop everything
         POP   USING                    Restore USING environment

*                                                                     *
*                                                                     *
**********************   End of the ESTAE   ***************************


H90010   DS    0H
*---------------------------------------------------------------------*
*     We have finished doing our work                                 *
*     First, delete our ESTAE if required ...                         *
*---------------------------------------------------------------------*
         TM    @H_ESTAE_Issued,L'@H_ESTAE_Issued ESTAE?
         JZ    H90020                   No, skip
         ESTAEX 0                       Yes, delete it
         NI    @H_ESTAE_Issued,X'FF'-L'@H_ESTAE_Issued No ESTAE now

H90020   DS    0H
*---------------------------------------------------------------------*
*    ... free up the 24-bit stack, if appropriate ...                 *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@H_24Bit_Stack_Ptr A(24-bit storage)
         JZ    H90030                   None, skip
         SSCSTACK TERM,                 Get rid of the stack           +
               STACK=(1)                 starting here

H90030   DS    0H
*---------------------------------------------------------------------*
*    ... then our locat 31-bit storage                                *
*---------------------------------------------------------------------*
         LA    R1,@H_Dynam              A(Local storage)
         L     R3,@H_31Bit_Stack_Ptr    A(31-bit Stack)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R3)                on this stack

*-------------------------------------------------------------------*
*    ... and the stack itself ...                                   *
*-------------------------------------------------------------------*
         SSCSTACK TERM,                 Free the stack                 +
               STACK=(R3)                starting here

*---------------------------------------------------------------------*
*    ... and exit.                                                    *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         PR    ,                        and return to caller


H_Literals  DS  0H

H_MVC    MVC   0(0,R1),3(R15) Move LSPACE error msg

         PUSH  PRINT
         PRINT NOGEN

H_LSPACE LSPACE MF=L
H_LSPACE_Length EQU *-H_LSPACE

H_ESTAE  ESTAEX 1,                      Establish ESTAE Exit           +
               CT,                       create it                     +
               PARAM=0,                  passing this parm             +
               MF=L                      keeping ourselves reentrant
H_ESTAE_Length EQU *-H_ESTAE

H_STIMERM_Set STIMERM SET,              Set a timer                    +
               MF=L                      keep ourselves reentrant
H_STIMERM_Set_Length EQU   *-H_STIMERM_Set

H_STIMERM_Cancel STIMERM CANCEL,        Cancel our timer               +
               MF=L                      keep ourselves reentrant
H_STIMERM_Cancel_Length EQU   *-H_STIMERM_Cancel

H_TIME   TIME  LINKAGE=SYSTEM,          Get the time                   +
               MF=L                      keep ourselves reentrant
H_TIME_Length  EQU *-H_TIME

H_SMS_Anomaly_Msg     DC C'* indicates SMS status in UCB and VTOC are i+
               nconsistent'
         POP   PRINT

H_TrTbl DC          C'0123456789ABCDEF'

H_MVC1   MVC   0(0,R1),@H_MaskArea      Move readable results

H_Scale  EQU   *
         DC    C'K'             Kilo (/10**3)
         DC    C'M'             Mega (/10**6)
         DC    C'G'             Giga (/10**9)
         DC    C'T'             Tera (/10**12)
         DC    C'P'             Peta (/10**15)
         DC    C'E'             Eta  (/10**18)
         DC    C'Z'             Zetta (/10**21)
         DC    C'Y'             Yotta (/10**24)
         DC    C'?'             Hope we never get here

         LTORG

H_SubTask_Hdgs        EQU   *
H_SubTask_Hdg1        DC    C' Subtask Statistics:'
H_SubTask_Hdg2        DC    C'  SubTask    Volume         CPU       --L+
               SPACE OK--       -LSPACE Bad--'
H_SubTask_Hdg3        DC    C'   Number     Count        Time        Co+
               unt   Wait        Count   Wait'

H_SubTask_Hdg_Lens    DC    AL2(L'H_SubTask_Hdg1)
                      DC    AL2(L'H_SubTask_Hdg2)
                      DC    AL2(L'H_SubTask_Hdg3)
H_SubTask_Hdg_Count   EQU   (*-H_SubTask_Hdg_Lens)/2


H_SubTask_Line        EQU   *
                      DC    C'     '
H_SubTask_Line_Nbr    DC    X'40202120'
                      DC    C'   '
H_SubTask_Line_TotVol DC    X'4020206B202120'
                      DC    C'     '
H_SubTask_Line_CPU    DC    X'4021204B202020'
                      DC    C'      '
H_SubTask_Line_Vol_OK DC    X'4020206B202120'
H_SubTask_Line_Wait_OK DC   X'4021204B202020'
                      DC    C'      '
H_SubTask_Line_Vol_Bad DC   X'4020206B202120'
H_SubTask_Line_Wait_Bad DC  X'4021204B202020'
H_SubTask_Line_Len    EQU   *-H_SubTask_Line

H_LSPACE_Msgs EQU *
           DC    XL2'0407'
           DC    AL1(L'H_Msg0407)
H_Msg0407  DC    C'LSPACE-I/O TIMEOUT ERROR'
           DC    XL2'0400'
           DC    AL1(L'H_Msg0400)
H_Msg0400  DC    C'LSPACE-PERMANENT I/O ERROR'
           DC    XL2'0800'
           DC    AL1(L'H_Msg0800)
H_Msg0800  DC    C'LSPACE-NON_STANDARD OS VOLUME'
           DC    XL2'0C01'
           DC    AL1(L'H_Msg0C01)
H_Msg0C01  DC    C'LSPACE-UCBVTOC IS ZERO'
           DC    XL2'0C02'
           DC    AL1(L'H_Msg0C02)
H_Msg0C02  DC    C'LSPACE-UCB NOT READY'
           DC    XL2'1485'
           DC    AL1(L'H_Msg1485)
H_Msg1485  DC    C'&PGMNAME - LSPACE ESTAE invoked'
           DC    XL2'0000'
           DC    AL1(L'H_Msg0000)
H_Msg0000  DC    C'&PGMNAME - Unknown LSPACE error'

H_MsgU522A DC    C'&PGMNAME - MaxLWait ('
H_MsgU522B DC    C' secs) exceeded.'

H_Literals_End  DS  0H

@H_Dynam                  DSECT Dynamic storage for H00010
                          DS    18F     O/S Save area
@H_31Bit_Stack_Ptr        DS    AL4     A(Local 31-bit Stack)
@H_24Bit_Stack_Ptr        DS    AL4     A(Local 24-bit Stack)
@H_VolTbl_Ptr             DS    AL4     A(VolTbl)
@H_LSPACE_Avg_Ptr         DS    AL4     A(Avg LSPACE Wait microsecs)
@H_STIMERM_Adj_Ptr        DS    AL4     A(STIMERM Adjustment Factor)
@H_Totals_Line_Ptr        DS    AL4     A(Totals Line)
@H_Stats_Line_Ptr         DS    AL4     A(1st SubTask Title line)
@H_SMS_Anomaly_Ptr        DS    AL4     A(SMS Anomaly Line)
@H_MaxLWait               DS    HL2     Max LSPACE Wait time

@H_Current_VolTbl_Ent     DS    AL4     A(Current VolTbl_Ent)

@H_UCBTBYT4               DS    XL(L'UCBTBYT4)  UCB Type for TRKCALC
@H_BytesPerTrack          DS    FL4     Bytes/trk, from TRKCALC

@H_STIMERM_ID             DS    AL4     STIMERM Id
@H_STIMERM_Exit_Parms_Ptr DS    AL4     A(Parms for STIMERM Exit)
@H_STIMERM_Exit_Parms     DS    2AL4    Parms for STIMERM Exit
                          DS    0D      Alignment
@H_LSPACE_Wait_Max        DS    FL4     Max LSPACE Wait Time (sec)
@H_LSPACE_Start           DS    DL8     TOD of LSPACE start
                          ORG   @H_LSPACE_Start
@H_LSPACE_Wait            DS    DL8     Actual LSPACE Wait time (usec)
                          ORG   ,

@H_DBLWD                  DS    D          Doubleword work area
@H_Total_VTOCTrk          DS    DBL8
@H_Total_DSCBs            DS    DBL8
@H_Total_FreeDSCBs        DS    DBL8
@H_Total_VolSize          DS    DBL8
@H_Total_Extents          DS    DBL8
@H_Total_FreeTracks       DS    DBL8
@H_Total_FreeBytes        DS    DBL8
@H_Total_FreeCyls         DS    DBL8
@H_Total_FragIndex        DS    DBL8
@H_Largest_FreeTracks     DS    DBL8
@H_Largest_FreeCyls       DS    DBL8
@H_WaitTime_Total         DS    D       Total Wait Time (in usec)
@H_Total_Vols_Proc        DS    FL4     Nbr volumes processed
@H_Total_Vols_OK          DS    FL4     Nbr volumes processed OK
@H_Total_LSPACE_Wait_OK   DS    DL8     Total good LSPACE Wait (usec)
@H_Total_LSPACE_Wait_Bad  DS    DL8     Total bad LSPACE Wait (usec)
                          DS    0F      Alignment
@H_ESTAE_RMask            DS    HL2     ESTAE Register Mask
@H_ESTAE_Regs             DS    16FL4   Registers for ESTAE Retry
@H_ESTAE_Retry            DS    AL4     A(ESTAE Retry routine)
                          DS    X       Flag Byte
@H_ESTAE_Issued           EQU   *-1,X'80' 1... .... ESTAE established
@H_VolTbl_Complete        EQU   *-1,X'40' .1.. .... All VolTbl_Ents OK
@H_OW48527                EQU   *-1,X'20' ..1. .... APAR OW48527 on
                          ORG   ,

                          DS    0F      Alignment
@H_LSPACE                 DS    CL(H_LSPACE_Length) LSPACE Macro

@H_VolSize                DS    DBL8    Volume Bytes (Used in %Free)
@H_TotDSCB                DS    DBL8    Volume Total DSCBs
@H_MaskArea               DS    CL8     ED Mask area
@H_Scale                  DS    C       Scaling factor

@H_Macro                  DS    0F      Alignment
@H_ESTAE                  DS    CL(H_ESTAE_Length)  ESTAE Macro area
                          ORG   @H_Macro
@H6_ESTAE                 DS    CL(H6_ESTAE_Length) STIMERM Exit ESTAE
@H6_Debug_Save            DS    4FL4    Save registers around WTOs
                          ORG   @H_Macro
@H_STIMERM_Set            DS    CL(H_STIMERM_Set_Length)  STIMERM
                          ORG   @H_Macro
@H_STIMERM_Can            DS    CL(H_STIMERM_Cancel_Length)  STIMERM
                          ORG   @H_Macro
@H_TIME                   DS    CL(H_TIME_Length) TIME Macro area
                          DS    0D
@H_TIME_Area              DS    XL16    Data returned by TIME
                          ORG   @H_Macro
@H_TRKCALC                TRKCALC MF=L  Track balance calcs
                          ORG   ,

@H_Parms                  DS    0F      Parms for called rtns
@H_Parms_Std              DS    3AL4     Standard 3 parms
@H_Parms_Extra            EQU   *        Extra parms
                          ORG   ,

                          DS    0D      Alignment
@H_Dynam_Length           EQU   *-@H_Dynam Length of Sub-Task Dynamic

&PGMNAME CSECT

         DROP  ,

         POP   USING                    Restore USING environment
         TITLE 'I00010: Sort Table'

         PUSH  USING

I00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: I00010                                                 *
*                                                                     *
*  Abstract  : Sort data in VolTbl depending on the parameters        *
*              passed.                                                *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(8-byte name of sort field)                 *
*                        A(1-byte containing sort direction (A/D))    *
*  Outputs   : R15: 0                                                 *
*                                                                     *
*  Notes     : N/A                                                    *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1998/09/22 SDDA030 - V2.1                              *
*                                 - Excluded Stats lines from being   *
*                                   sorted                            *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*              2000/01/19 SDDA030 - V2.11                             *
*                                 - Received parms as pointers.       *
*                                 - Able to sort Ascending or Descend-*
*                                   ing.                              *
*              2000/05/23 SDDA030 - V2.12                             *
*                                 - Moved table of offsets from F00010*
*                                   to here.                          *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - Added FREEB to table of offsets.  *
*                                 - Pointed numeric fields to the     *
*                                   appropriate sort fields in VolTbl.*
*                                 - Removed sort by column nbr.       *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Added VOLSIZE to table of offsets.*
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*                                 - Fixed bug causing unending WAIT   *
*                                   when STATS and SORT specified     *
*                                 - WAIT for all detail lines to be   *
*                                   populated before sorting (doh!)   *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,I_Literals           Point to our literals
         USING (I_Literals,I_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@I_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@I_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @I_Dynam,R13             Assign a base
         L     R15,@I_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@I_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@I_24Bit_Stack_Ptr_Ptr Save it


         ICM   R9,B'1111',@_VolTbl_Ptr  A(Volume table)
         JZ    I00100                   None, don't sort it
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries
         CHI   R10,1                    More than 1
         JNH   I00100                   No, skip sort

         L     R14,12(0,R1)             Get A(Name of sort field)
         LA    R15,I_TBLOFF             and A(Table of offsets)
I00020   DS    0H
         CLI   0(R15),C' '              End of table?
         JE    I80010                   Yes, error (sort fld not found)
         CLC   0(8,R14),0(R15)          Name, is it ours?
         JE    I00030                   Yes, skip

         AHI   R15,12                   No, point to next entry
         J     I00020                   and try again
I00030   DS    0H
         LH    R14,8(0,R15)             Offset of sort field
         LH    R15,10(0,R15)            Length of sort field

         L     R1,@I_Dynam+4            Get A(HSA)
         L     R1,24(0,R1)              Get original R1
         L     R1,16(0,R1)              A(Sort direction)
         CLI   0(R1),C'D'               Descending sort?
         JE    I00040                   Yes, skip
         LHI   R3,13                    No, use BNH for ascending sort
         J     I00050                   and skip
I00040   DS    0H
         LHI   R3,11                    Use BNL for descending sort
I00050   DS    0H
         SLL   R3,4                     Put mask in high nibble

         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R9),X'40' All details done?
         JO    I00050C                  Yes, skip
         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R9) No, wait for it
I00050C  DS    0H

         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry
         AHI   R10,-1                   Adjust Loop count
I00060   DS    0H
         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R9),L'VolTbl_Ent_Detai+
               l_Line
         JNO   I00060C                  No, skip it
         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R9),L'VolTbl_Ent_SMS_Line
         JNO   I00070                   True Detail line, skip
I00060C  DS    0H
         AHI   R9,VolTbl_Ent_Len        No, A(Next entry)
         BRCT  R10,I00060               and check again
         J     I00100                   Nothing, skip sort

I00070   DS    0H
         LR    R4,R9                    Get A(entry)
         LR    R5,R10                   Get inner loop count
         LA    R6,VolTbl_Ent_Len(0,R4)  A(Next entry)
I00080   DS    0H
         TM    VolTbl_Ent_Detail_Line-VolTbl_Ent(R6),L'VolTbl_Ent_Detai+
               l_Line
         JNO   I00090                   Skip non-detail line
         TM    VolTbl_Ent_SMS_Line-VolTbl_Ent(R6),L'VolTbl_Ent_SMS_Line
         JO    I00090                   Skip SMS Anomaly msg

         LA    R7,0(R4,R14)             Point to
         LA    R8,0(R6,R14)              sort fields
         EX    R15,I0EX1                Compare entries
         EX    R3,I0EX2                 Branch if in sequence

         STM   R14,R1,@I_TempSave       Save MVCL registers
         LA    R0,@I_WK1                A(Temporary area)
         LHI   R1,L'@I_WK1              Its length
         LR    R14,R4                   A(Entry out of sequence)
         LHI   R15,VolTbl_Ent_Len       Its length
         MVCL  R0,R14                   Save entry
         LR    R0,R4                    A(Entry to be switched)
         LHI   R1,VolTbl_Ent_Len        Its length
         LR    R14,R6                   A(Entry out of sequence)
         LHI   R15,VolTbl_Ent_Len       Its length
         MVCL  R0,R14                   Save entry
         LR    R0,R6                    A(Entry to be switched)
         LHI   R1,VolTbl_Ent_Len        Its length
         LA    R14,@I_WK1               A(Temporary area)
         LHI   R15,L'@I_WK1             Its length
         MVCL  R0,R14                   Save entry
         LM    R14,R1,@I_TempSave       Restore MVCL registers

I00090   DS    0H
         AHI   R6,VolTbl_Ent_Len        A(next entry)
         BRCT  R5,I00080                Sort all entries
         AHI   R9,VolTbl_Ent_Len        Reset start entry nbr
         BRCT  R10,I00060                And do it all again

I00100   DS    0H
         LA    R15,0                    Clear return code
         J     I90010                   and exit

I80010   DS    0H
*-------------------------------------------------------------------*
*    Sort field not found                                           *
*-------------------------------------------------------------------*
         LA    R15,4                    Sort failed
         J     I90010                   and exit

I90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@I_Dynam              A(Local storage)
         L     R2,@I_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

I_Literals  DS  0H

I0EX1    CLC   0(0,R7),0(R8)            Compare entries
I0EX2    JNOP  I00090                   Set to BNH/BNL for A/D sort


         LTORG

I_TBLOFF EQU   *
         DC    CL8'VOL'
         DC    AL2(VolTbl_Ent_Volser-VolTbl_Ent) Start of VOL
         DC    AL2(L'VolTbl_Ent_Volser)         Len of VOL

         DC    CL8'UCB'
         DC    AL2(VolTbl_Ent_UCBCopy+UCBCHAN-UCBOB-VolTbl_Ent) UCB
         DC    AL2(L'UCBCHAN)                   Length of UCB

         DC    CL8'DEVT'
         DC    AL2(VolTbl_Ent_DevType-VolTbl_Ent) Start of Device Type
         DC    AL2(L'VolTbl_Ent_DevType)        Len of Device type

         DC    CL8'ATTR'
         DC    AL2(VolTbl_Ent_Attrib-VolTbl_Ent) Start of Mnt Attr
         DC    AL2(L'VolTbl_Ent_Attrib)         Len of Mnt Attr

         DC    CL8'FREET'
         DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent) Free Trk
         DC    AL2(L'VolTbl_Ent_Sort_FreeTrk)   Len of Free Trks

         DC    CL8'FREEC'
         DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent) Free Cyl
         DC    AL2(L'VolTbl_Ent_Sort_FreeCyl)   Len of Free Cyl

         DC    CL8'FREEP'
         DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent) Free % of Vol
         DC    AL2(L'VolTbl_Ent_FreePct)        Len of Free % of Vol

         DC    CL8'FREEB'
         DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent) Free Bytes
         DC    AL2(L'VolTbl_Ent_Sort_FreeBytes)   Len of Free Bytes

         DC    CL8'FREEE'
         DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent) Nbr Extents
         DC    AL2(L'VolTbl_Ent_Sort_FreeExt)   Len of nbr Extents

         DC    CL8'LARGET'
         DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent) Larg Trk
         DC    AL2(L'VolTbl_Ent_Sort_LargTrk)   Len of Larg Trks

         DC    CL8'LARGEC'
         DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent) Larg Cyl
         DC    AL2(L'VolTbl_Ent_Sort_LargCyl)   Len of Larg Cyl

         DC    CL8'VTRK'
         DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent) VTOC Trk
         DC    AL2(L'VolTbl_Ent_Sort_VTOCTrk)   Len of VTOC Trks

         DC    CL8'VFREED'
         DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent) Free DSCBs
         DC    AL2(L'VolTbl_Ent_Sort_FreeDSCB)  Len of Free DSCBs

         DC    CL8'VFREEP'
         DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent) Start of Free %
         DC    AL2(L'VolTbl_Ent_VTOCFree)       Len of Free %

         DC    CL8'VIX'
         DC    AL2(VolTbl_Ent_VTOCIX-VolTbl_Ent) Start of VTOC IX Stat
         DC    AL2(L'VolTbl_Ent_VTOCIX)         Len of VTOC IS Stat

         DC    CL8'FRAG'
         DC    AL2(VolTbl_Ent_Frag_Indx-VolTbl_Ent) Frag Index
         DC    AL2(L'VolTbl_Ent_Frag_Indx)      Len of Frag Index

         DC    CL8'VOLSIZE'
         DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent) Volume size
         DC    AL2(L'VolTbl_Ent_Sort_VolSize)   Len of volume size

         DC    CL8'STORGRP'
         DC    AL2(VolTbl_Ent_SMS_StorGrp-VolTbl_Ent) Stor Group
         DC    AL2(L'VolTbl_Ent_SMS_StorGrp)    Len of Stor Group

         DC    CL8'SMSSTAT'
         DC    AL2(VolTbl_Ent_SMS_Status-VolTbl_Ent) SMS Status
         DC    AL2(L'VolTbl_Ent_SMS_Status)    Len of SMS Status

         DC    CL8'CHPIDS'
         DC    AL2(VolTbl_Ent_CHPIDs-VolTbl_Ent) Start of CHPIDs
         DC    AL2(L'VolTbl_Ent_CHPIDs)         Len of CHPIDs

         DC    CL8' '
         DC    HL2'-1'                         End of table
         DC    AL2(0)

I_Literals_End  DS  0H


@I_Dynam                  DSECT        Dynamic area for I00000
                          DS    18F     O/S Style save area
@I_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@I_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@I_TempSave               DS    4FL4    Temporary save area (for MVCLs)
@I_WK1                    DS    CL(VolTbl_Ent_Len) Work area
                          DS    0D         Alignment
@I_Dynam_Length           EQU   *-@I_Dynam  Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'J00010: EDIF/BRIF'

         PUSH  USING

J00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: J00010                                                 *
*                                                                     *
*  Abstract  : EDIF/BRIF invocation and associated service routines.  *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15 = 0                                                *
*                                                                     *
*  Notes     : N/A                                                    *
*                                                                     *
*  History:    2001/02/26 SDDA030 - V2.14                             *
*                                 - New                               *
*              2002/02/12 SDDA030 - V2.16                             *
*                                 - Added pop-up panel to BRIF when   *
*                                   SORT command entered with no or   *
*                                   invalid operands.                 *
*              2002/06/11 SDDA030 - V2.18                             *
*                                   WAIT for VolTbl_Ent to be populated
*                                   before outputting                 *
*              2004/10/15 SDDA030 - V2.22                             *
*                                 - Resequenced labels                *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,J_Literals           Point to our literals
         USING (J_Literals,J_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@J_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@J_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @J_Dynam,R13             Assign a base
         L     R15,@J_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@J_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@J_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    Set up our record length for EDIF/BRIF                         *
*-------------------------------------------------------------------*
         LHI   R15,VolTbl_Ent_Display_Len Max len to display
         ST    R15,@J_ISPF_LRECL        Save it

*-------------------------------------------------------------------*
*    Set up the parms to be passed to the EDIF/BRIF routines        *
*-------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic storage)
         ST    R15,@J_ISPF_Rtn_Parms    Save the address
         L     R15,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Ptr)
         ST    R15,@J_ISPF_Rtn_Parms+4  Save the address
         L     R15,@J_24Bit_Stack_Ptr_Ptr A(24-bit Stack Ptr)
         ST    R15,@J_ISPF_Rtn_Parms+8  Save the address
         LA    R15,@J_EDIF_Prev_Rec_Nbr A(EDIF Record Number field)
         ST    R15,@J_ISPF_Rtn_Parms+12 Save the address
         LA    R15,@J_ISPF_Rtn_Parms    A(Parms)
         ST    R15,@J_ISPF_Rtn_Parms_Ptr Save the address

*-------------------------------------------------------------------*
*    Set up EDIF Parms ...                                          *
*-------------------------------------------------------------------*
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF  Do we want EDIF?
         JZ    J00020                   No, go do BRIF

         LA    R15,=CL8'EDIF'           A(EDIF)
         ST    R15,@J_ISPF_Parms        Save it
         LA    R15,J_Data_Name          A(Data-name)
         ST    R15,@J_ISPF_Parms+4      Save it
         LA    R15,=CL8'TEXT'           A(Profile name)
         ST    R15,@J_ISPF_Parms+8      Save it
         LA    R15,=C'F '               A(record-format)
         ST    R15,@J_ISPF_Parms+12     Save it
         LA    R15,@J_ISPF_LRECL        A(record length)
         ST    R15,@J_ISPF_Parms+16     Save it
         LA    R15,=AL4(JA0010)         A(Read Routine)
         ST    R15,@J_ISPF_Parms+20     Save it
         LA    R15,=AL4(JB0010)         A(Write Routine)
         ST    R15,@J_ISPF_Parms+24     Save it
         LA    R15,=AL4(0)              No Cmd Routine
         ST    R15,@J_ISPF_Parms+28     Save it
         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr
         ST    R15,@J_ISPF_Parms+32     Save it
         OI    @J_ISPF_Parms+32,X'80'   Flag as last parm

         XC    @J_EDIF_Prev_Rec_Nbr,@J_EDIF_Prev_Rec_Nbr

         J     J00040                   Go invoke EDIF

J00020   DS    0H
*-------------------------------------------------------------------*
*    ... or BRIF parms ...                                          *
*-------------------------------------------------------------------*
         LA    R15,=CL8'BRIF'           A(BRIF)
         ST    R15,@J_ISPF_Parms        Save it
         LA    R15,J_Data_Name          A(Data-name)
         ST    R15,@J_ISPF_Parms+4      Save it
         LA    R15,=C'F '               A(record-format)
         ST    R15,@J_ISPF_Parms+8      Save it
         LA    R15,@J_ISPF_LRECL        A(record length)
         ST    R15,@J_ISPF_Parms+12     Save it
         LA    R15,=AL4(JA0010)         A(Read Routine)
         ST    R15,@J_ISPF_Parms+16     Save it
         LA    R15,=AL4(JC0010)         A(Cmd Routine)
         ST    R15,@J_ISPF_Parms+20     Save it
         LA    R15,@J_ISPF_Rtn_Parms_Ptr Point to routine parmlist ptr
         ST    R15,@J_ISPF_Parms+24     Save it
         OI    @J_ISPF_Parms+24,X'80'   Flag as last parm

         J     J00040                   Go invoke BRIF

J00040   DS    0H
*-------------------------------------------------------------------*
*    ... and invoke EDIF or BRIF                                    *
*-------------------------------------------------------------------*
         LA    R1,@J_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Invoke EDIF or BRIF

         LA    R15,0                    Clear return code
         LA    R0,0                     and reason code
         J     J90010                   and exit


J90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LA    R1,@J_Dynam              A(Local storage)
         L     R2,@J_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LA    R15,0                    Clear return code
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


J_Literals  DS  0H
J_Data_Name EQU *
            DC C'&PGMNAME'
            DC X'00'
            DC C'&VERSION'
            DC C' '

         LTORG

J_Literals_End  DS  0H


@J_Dynam                  DSECT        Dynamic area for J00000
                          DS    18F     O/S Style save area
@J_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@J_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@J_DBLWD                  DS    D       Work area
@J_ISPF_LRECL             DS    XL4     Record length for EDIF/BRIF
@J_EDIF_Prev_Rec_Nbr      DS    FL4     Last rec nbr passed to EDIF
@J_ISPF_Parms             DS    9AL4    Parms for EDIF/BRIF
@J_ISPF_Rtn_Parms_Ptr     DS    AL4     A(Parms for EDIF/BRIF Routines)
@J_ISPF_Rtn_Parms         DS    4AL4    Parms for EDIF/BRIF Routines
                          DS    0D      Alignment
@J_Dynam_Length           EQU   *-@J_Dynam  Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING



JA0010   DS    0H

         PUSH  USING                    Save USING environment

*-------------------------------------------------------------------*
*                                                                   *
*    EDIF/BRIF Read Routine                                         *
*     Input: R1 ---> A(Record pointer)                              *
*                    A(Length of record read)                       *
*                    A(Request Code)                                *
*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *
*                                            A(31-bit Stack Ptr)    *
*                                            A(24-bit Stack Ptr)    *
*                                            A(EDIF Rec Nbr fld)    *
*                                                                   *
*     Output: R15:  0 - Record returned                             *
*                   8 - EOF                                         *
*                                                                   *
*-------------------------------------------------------------------*

         BAKR  R14,0                    Save callers registers
         LARL  R11,JA_Literals          Point to our literals
         USING (JA_Literals,JA_Literals_End),R11 Tell the assembler

         L     R12,12(0,R1)             Get A(Parmlist pointer)
         L     R12,0(0,R12)             Get A(Parmlist)
         L     R12,0(0,R12)             Get A(@_Dynam)
         USING @_Dynam,R12              Assign a base

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,12(0,R1)              Get A(Parmlist pointer)
         L     R2,0(0,R2)               Get A(Parmlist)
         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)
         L     R2,0(0,R2)               Get A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@JA_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@JA_Dynam_Length      Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         LR    R13,R1                   Load dynam base
         USING @JA_Dynam,R13            Assign a base
         MVC   4(4,R13),=C'F1SA'        Init save area

         EREG  R0,R3                    Restore callers registers

         L     R14,12(0,R1)             A(Parmlist Ptr)
         L     R14,0(0,R14)             A(Parmlist)
         L     R15,4(0,R14)             A(31-bit Stack Ptr)
         ST    R15,@JA_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R14)             A(24-bit Stack Ptr)
         ST    R15,@JA_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    Get the record number requested (BRIF), or retrieve it from    *
*   our variable (EDIF)                                             *
*-------------------------------------------------------------------*
         L     R3,8(0,R1)               Get A(record number)
         L     R3,0(0,R3)               Get record number
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Is this BRIF?
         JO    JA0020                   Yes, skip
         L     R15,12(0,R1)             No, A(Parms Ptr)
         L     R15,0(0,R15)             A(Parms)
         L     R15,12(0,R15)            A(Prev EDIF Record number)
         L     R3,0(0,R15)              Prev EDIF Record number
         AHI   R3,1                     Bump it
         ST    R3,0(0,R15)              and save it

JA0020   DS    0H
*-------------------------------------------------------------------*
*    Run through the table, looking for our record                  *
*-------------------------------------------------------------------*
         L     R9,@_VolTbl_Ptr          A(Volume Table)
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Nbr entries
         AHI   R9,VolTbl_Ent-VolTbl     and point to first
         USING VolTbl_Ent,R9            Assign a base
         LA    R4,0                     Clear record count
JA0030   DS    0H
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line A Hdg?
         JNO   JA0040                   No, skip
         TM    @_No_Headings,L'@_No_Headings Yes, do we want them?
         JO    JA0090                   No, skip it
         J     JA0070                   Yes, check it out
JA0040   DS    0H
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line
         JNO   JA0050                   No, skip
         TM    @_No_Details,L'@_No_Details Yes, do we want them?
         JO    JA0090                   No, skip it
         J     JA0070                   Yes, check it out
JA0050   DS    0H
         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line
         JNO   JA0060                   No, skip
         TM    @_No_Totals,L'@_No_Totals Yes, do we want them?
         JO    JA0090                   No, skip it
         J     JA0070                   Yes, check it out
JA0060   DS    0H
         TM    @_Statistics,L'@_Statistics Do we want stats?
         JNO   JA0090                   No, skip it
JA0070   DS    0H
         LA    R8,VolTbl_Ent            Save A(Entry)
         AHI   R4,1                     Bump record count
         CR    R4,R3                    Is this ours?
         JL    JA0090                   No, skip it
         TM    @_Statistics,L'@_Statistics Yes, Stats line?
         JNO   JA0080                   No, skip
         STM   R0,R1,@JA_Temp_Save      Yes, save our registers

         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@JA_Parms_Std        Save it
         L     R15,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@JA_Parms_Std+4      Save it
         L     R15,@JA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@JA_Parms_Std+8      Save it
         LA    R15,VolTbl_Ent           A(Table entry)
         ST    R15,@JA_Parms_V00010     Save it

         LA    R1,@JA_Parms             Point to the parmlist
         BRAS  R14,V00010               Process stats line
         LM    R0,R1,@JA_Temp_Save      Restore our registers
JA0080   DS    0H
         TM    VolTbl_Ent_ECB,X'40'     Entry populated?
         JO    JA0100                   Yes, OK
         STM   R0,R1,@JA_Temp_Save      Yes, save our registers
         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it
         LM    R0,R1,@JA_Temp_Save      Restore our registers
         J     JA0100                   and skip
JA0090   DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,JA0030

*-------------------------------------------------------------------*
*    We have reached the end of the table before finding our        *
*   record - set the EOF return code, and, if this is BRIF, the     *
*   pointer to the last valid record, and the record number.        *
*-------------------------------------------------------------------*
         LA    R15,8                  EOF
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Is this EDIF?
         JO    JA0110                 Yes, exit

         LR    R9,R8                   A(Last valid entry)
         L     R14,8(0,R1)            A(Record count)
         ST    R4,0(0,R14)            update it for BRIF
         LA    R15,8                  EOF
         J     JA0110                 and skip

JA0100   DS    0H
         LA    R15,0                    found our record
         J     JA0110                   and skip

JA0110   DS    0H
*-------------------------------------------------------------------*
*    ... and update the record pointer (R9).                        *
*-------------------------------------------------------------------*
         AHI   R9,VolTbl_Ent_Display-VolTbl_Ent   Readable bits

         L     R14,0(0,R1)            A(Record pointer)
         ST    R9,0(0,R14)            update it
         J     JA9010                 and exit

JA9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@JA_Dynam             A(Local storage)
         L     R2,@JA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         PR    ,                        and return

JA_Literals  DS  0H

         LTORG

JA_Literals_End  DS  0H


@JA_Dynam                 DSECT
                          DS    18F     O/S style save area
@JA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)
@JA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)
@JA_Temp_Save             DS    2FL4    Save area around V00010 call

@JA_Parms                 DS    0F      Parms for called rtns
@JA_Parms_Std             DS    3AL4     Standard 3 parms
@JA_Parms_Extra           EQU   *        Extra parms
@JA_Parms_V00010          DS    AL4         for V00010
                          ORG   ,
                          DS    0D
@JA_Dynam_Length          EQU   *-@JA_Dynam


&PGMNAME CSECT
         DROP  ,                        Free base registers
         POP   USING


JB0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    EDIF Write Routine                                             *
*     Input: R1 ---> A(Record pointer)                              *
*                    A(Length of record read)                       *
*                    A(Change Flags)                                *
*                    A(Request Code)                                *
*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *
*                                            A(31-bit Stack Ptr)    *
*                                            A(24-bit Stack Ptr)    *
*                                            A(A word for our use)  *
*                                                                   *
*-------------------------------------------------------------------*

         PUSH  USING                    Save USING environment
         DROP  ,                        Free base registers

         BAKR  R14,0                    Save callers registers
         LARL  R11,JB_Literals          Point to our literals
         USING (JB_Literals,JB_Literals_End),R11 Tell the assembler

         L     R12,16(0,R1)             Get A(ParmList Ptr)
         L     R12,0(0,R12)             Get A(ParmList)
         L     R12,0(0,R12)             Get A(@_Dynam)
         USING @_Dynam,R12              Assign a base

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,16(0,R1)              Get A(Parmlist Ptr)
         L     R2,0(0,R2)               Get A(Parmlist)
         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)
         L     R2,0(0,R2)               Get A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@JB_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@JB_Dynam_Length      Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Set up our save area, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         LR    R13,R1                   Load dynam base
         USING @JB_Dynam,R13            Assign a base
         MVC   4(4,R13),=C'F1SA'        Init save area

         EREG  R0,R3                    Restore callers registers

         L     R14,16(0,R1)             A(Parmlist Ptr)
         L     R14,0(0,R14)             A(Parmlist)
         L     R15,4(0,R14)             A(31-bit Stack)
         ST    R15,@JB_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R14)             A(24-bit Stack)
         ST    R15,@JB_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    If this is the last (or only) write request, set an ISPF       *
*    message to say the data wasn't saved ...                       *
*-------------------------------------------------------------------*
         L     R15,12(0,R1)             A(Request code)
         L     R15,0(0,R15)             Get it
         CHI   R15,2                    Last write request?
         JE    JB0020                   Yes, issue message
         CHI   R15,3                    Maybe, Last (and only)?
         JE    JB0020                   Yes, skip

         LA    R15,0                    No, clear return code
         J     JB9010                   and exit

JB0020   DS    0H
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@JB_ISPF_Parms       Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@JB_ISPF_Parms+12 Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@JB_ISPF_Parms+4     Save it
         LA    R15,JB_NoSave_SMsg       Short message
         ST    R15,@JB_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'JB_NoSave_SMsg)     Length of message
         ST    R15,@JB_ISPF_Parms+16 Save it
         OI    @JB_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@JB_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@JB_ISPF_Parms+4     Save it
         LA    R15,JB_NoSave_LMsg       Short message
         ST    R15,@JB_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'JB_NoSave_LMsg)     Length of message
         ST    R15,@JB_ISPF_Parms+16 Save it
         OI    @JB_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@JB_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@JB_ISPF_Parms       Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@JB_ISPF_Parms+4     Save it
         OI    @JB_ISPF_Parms+4,X'80' Mark end of list
         LA    R1,@JB_ISPF_Parms        Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

*-------------------------------------------------------------------*
*    ... and exit                                                   *
*-------------------------------------------------------------------*

         LA    R15,0                    Clear return code
         J     JB9010                   and exit

JB9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@JB_Dynam             A(Local storage)
         L     R2,@JB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         PR    ,                        and return


JB_Literals  DS  0H

JB_NoSave_SMsg     DC   C'SAVE disabled'
JB_NoSave_LMsg     DC   C'Use CREATE or REPLACE to save the data'

         LTORG

JB_Literals_End  DS  0H


@JB_Dynam                 DSECT
                          DS    18F     O/S style save area
@JB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)
@JB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)
@JB_ISPF_Parms            DS    5AL4    Parm list for ISPF
                          DS    0D
@JB_Dynam_Length          EQU   *-@JB_Dynam


&PGMNAME CSECT
         DROP  ,                        Free base registers
         POP   USING


JC0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    BRIF Command Routine                                           *
*     Input: R1 ---> A(Function Code)                               *
*                    A(Parms Ptr): A(Parms): A(@_Dynam)             *
*                                            A(31-bit Stack Ptr)    *
*                                            A(24-bit Stack Ptr)    *
*                                            A(A word for our use)  *
*                                                                   *
*-------------------------------------------------------------------*

         PUSH  USING                    Save USING environment
         DROP  ,                        Free base registers

         BAKR  R14,0                    Save callers registers
         LARL  R11,JC_Literals          Point to our literals
         USING (JC_Literals,JC_Literals_End),R11 Tell the assembler

         L     R12,4(0,R1)              Get A(Parmlist Ptr)
         L     R12,0(0,R12)             Get A(ParmList)
         L     R12,0(0,R12)             Get A(@_Dynam)
         USING @_Dynam,R12              Assign a base

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               Get A(Parmlist Ptr)
         L     R2,0(0,R2)               Get A(Parmlist)
         L     R2,4(0,R2)               Get A(31-bit Stack Ptr)
         L     R2,0(0,R2)               Get A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@JC_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@JC_Dynam_Length      Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Set up our save area, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         LR    R13,R1                   Load dynam base
         USING @JC_Dynam,R13            Assign a base
         MVC   4(4,R13),=C'F1SA'        Init save area

         EREG  R0,R3                    Restore callers registers

         L     R14,4(0,R1)              A(Parmlist Ptr)
         L     R14,0(0,R14)             A(Parmlist)
         L     R15,4(0,R14)             A(31-bit Stack)
         ST    R15,@JC_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R14)             A(24-bit Stack)
         ST    R15,@JC_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    Check out the function code from BRIF ...                      *
*-------------------------------------------------------------------*
         L     R15,0(0,R1)              Get A(Function code)
         L     R15,0(0,R15)             Get it
         CHI   R15,20                   Unknown command?
         JNE   JC0030                   No, let recursive browse work

*-------------------------------------------------------------------*
*    ... and go check it out                                        *
*-------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@JC_Parms_Std        Save it
         L     R15,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@JC_Parms_Std+4      Save it
         L     R15,@JC_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@JC_Parms_Std+8      Save it

         LA    R1,@JC_Parms             Point to the parmlist
         BRAS  R14,L00010               Process command

         TM    @_ReDisplay,L'@_ReDisplay Display mode change?
         JO    JC0020                   Yes, set rc and exit
         LTR   R15,R15                  Did we process the command?
         JNZ   JC0030                   No, skip
         LA    R15,0                    Yes, normal completion
         J     JC9010                   and exit

JC0020   DS    0H
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@JC_ISPF_Parms       Save it
         LA    R15,=CL8'ZCMD'           Variable name
         ST    R15,@JC_ISPF_Parms+4     Save it
         LA    R15,JC_Blanks            A(blank string)
         ST    R15,@JC_ISPF_Parms+8     Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@JC_ISPF_Parms+12    Save it
         LA    R15,=AL4(L'JC_Blanks)    Length of blank string
         ST    R15,@JC_ISPF_Parms+16    Save it
         OI    @JC_ISPF_Parms+16,X'80'  Flag end of list
         LA    R1,@JC_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'VPUT'           ISPF Function
         ST    R15,@JC_ISPF_Parms       Save it
         LA    R15,=CL8'ZCMD'           A(Variable name)
         ST    R15,@JC_ISPF_Parms+4     Save it
         LA    R15,=CL8'ASIS'           A(Variable name)
         ST    R15,@JC_ISPF_Parms+8     Save it
         OI    @JC_ISPF_Parms+8,X'80'   Flag end of list
         LA    R1,@JC_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LHI   R15,20                   Re-display requested, exit
         J     JC9010                   and exit

JC0030   DS    0H
         LHI   R15,4                    Unknown command, let BRIF do it
         J     JC9010                   and exit

JC9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@JC_Dynam             A(Local storage)
         L     R2,@JC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         PR    ,                        and return

JC_Literals  DS  0H

JC_Blanks    DC  C' '

         LTORG

JC_Literals_End  DS  0H


@JC_Dynam                 DSECT
                          DS    18F     O/S style save area
@JC_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)
@JC_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)
@JC_ISPF_Parms            DS    5AL4    ISPF parms

@JC_Parms                 DS    0F      Parms for called rtns
@JC_Parms_Std             DS    3AL4     Standard 3 parms
@JC_Parms_Extra           EQU   *        Extra parms
                          ORG   ,

                          DS    0D
@JC_Dynam_Length          EQU   *-@JC_Dynam

&PGMNAME CSECT
         DROP  ,                        Free base registers
         POP   USING
         TITLE 'K00010: ISPF(S) Display'

         PUSH  USING

K00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : K00010                                                 *
*                                                                     *
*  Abstract  : Display the results via the ISPF SPACE Panel           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0: OK                                             *
*                   4: Panel not found                                *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2002/02/12 SDDA030 - V2.16                             *
*                                 - New (originally part of G00010)   *
*                                 - Used Dynamic displays (rather than*
*                                   TBDISPL) for ISPF(S).             *
*                                 - Added LEFT/RIGHT processing for   *
*                                   ISPF(S).                          *
*                                 - Added sort prompt pop-up panel in *
*                                   ISPF(B).                          *
*              2002/06/11 SDDA030 - V2.18                             *
*                                   WAIT for VolTbl_Ent to be populated
*                                   before outputting                 *
*              2004/10/15 SDDA030 - V2.22                             *
*                                 - Resequenced labels                *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Added code to display number when *
*                                   cursor on numeric fld, and ENTER. *
*                                 - Used standardised calling sequence*
*                                 - Changed 'Line x of y' to 'Line x'.*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,K_Literals           Point to our literals
         USING (K_Literals,K_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@K_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@K_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @K_Dynam,R13             Assign a base
         L     R15,@K_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@K_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@K_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@K_Parms_Std         Save it
         L     R15,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@K_Parms_Std+4       Save it
         L     R15,@K_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@K_Parms_Std+8       Save it

*-------------------------------------------------------------------*
*    Check to see that our panel exists, and that it has an         *
*   appropriate Dynamic area in it.                                 *
*-------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,K_ISPF_PQUERY_Names  A(Variable names)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_ISPF_PQUERY_Values A(Variable storage)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,K_ISPF_PQUERY_Types  A(Variable types)
         ST    R15,@K_ISPF_Parms+12     Save it
         LA    R15,K_ISPF_PQUERY_Lens   A(Variable lengths)
         ST    R15,@K_ISPF_Parms+16     Save it
         LA    R15,=CL8'LIST'           Variable types
         ST    R15,@K_ISPF_Parms+20     Save it
         OI    @K_ISPF_Parms+20,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go check out panel

         LA    R15,=CL8'PQUERY'         ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'&PNLNAME'       A(Panel name)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,=CL8'DATA    '       A(Area name)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,K_SPCDYNTY           A(Area Type variable name)
         ST    R15,@K_ISPF_Parms+12     Save it
         LA    R15,K_SPCDYNWI           A(Width variable name)
         ST    R15,@K_ISPF_Parms+16     Save it
         LA    R15,K_SPCDYNDE           A(Depth variable name)
         ST    R15,@K_ISPF_Parms+20     Save it
         LA    R15,K_SPCDYNRO           A(Starting Row Number name)
         ST    R15,@K_ISPF_Parms+24     Save it
         LA    R15,K_SPCDYNCO           A(Starting Column number name)
         ST    R15,@K_ISPF_Parms+28     Save it
         OI    @K_ISPF_Parms+28,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go check out panel
         LTR   R15,R15                  All OK?
         JNZ   K80010                   No, error and exit

         CLC   =CL8'DYNAMIC',@K_ISPF_SPCDYNTN_Value  Dynamic?
         JNE   K80010                   No, error and exit
         ICM   R15,B'1111',@K_ISPF_SPCDYNWI_Value  Width OK?
         JZ    K80010                   No, error and exit
         ST    R15,@K_ISPF_Dyn_Area_Width Yes, save it
         ICM   R15,B'1111',@K_ISPF_SPCDYNDE_Value  Depth OK?
         JZ    K80010                   No, error and exit
         ST    R15,@K_ISPF_Dyn_Area_Depth Yes, save it
         ICM   R15,B'1111',@K_ISPF_SPCDYNRO_Value  Starting Row OK?
         JZ    K80010                   No, error and exit
         AHI   R15,-1                   Yes, relative to 0
         ST    R15,@K_ISPF_Dyn_Area_Row and save it
         ICM   R15,B'1111',@K_ISPF_SPCDYNCO_Value  Starting column OK?
         JZ    K80010                   No, error and exit
         AHI   R15,-1                   Yes, relative to 0
         ST    R15,@K_ISPF_Dyn_Area_Column and save it

*---------------------------------------------------------------------*
*     The panel seems OK, get some storage for the Dynamic Area ...   *
*---------------------------------------------------------------------*
         L     R1,@K_ISPF_Dyn_Area_Width Get area width
         M     R0,@K_ISPF_Dyn_Area_Depth Get total length

         ST    R1,@K_ISPF_Dyn_Area_Len  Save it
         LR    R0,R1                    in proper register

         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=(0),                  this long                     +
               STACK=(R2)                using this stack

         ST    R1,@K_ISPF_Dyn_Area_Ptr  Save A(Our storage)

*---------------------------------------------------------------------*
*     ... define it to ISPF ...                                       *
*---------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'DATA'           Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         L     R15,@K_ISPF_Dyn_Area_Ptr Point to it
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=CL8'CHAR'           Character data
         ST    R15,@K_ISPF_Parms+12     Save it
         L     R15,@K_ISPF_Dyn_Area_Len Length of diaplay area
         ST    R15,@K_ISPF_Parms+20     Save it
         LA    R15,@K_ISPF_Parms+20     Point to it
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*     ... and init some variables.                                    *
*---------------------------------------------------------------------*
         LA    R15,VolTbl_Ent_DevType-VolTbl_Ent_Display Set our
         ST    R15,@K_VolTbl_Ent_Offset  offset

         LA    R15,0                    Current top of display
         ST    R15,@K_VolTbl_Ent_Display_Line Save it

         LHI   R15,VolTbl_Ent_Display_Len Get max display len
         S     R15,@K_ISPF_Dyn_Area_Width  Max offset within display
         A     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)
         ST    R15,@K_VolTbl_Ent_Offset_Max Save it

         L     R15,@_VolTbl_Ptr         A(Volume Table)
         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get nbr entries
         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it

         LA    R15,0                    Number of heading lines
         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines and save it
         ST    R15,@K_VolTbl_Hdg_Lines  here too

         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force the area
         MVC   @K_VolTbl_Ent_Offset_Prev,=FL4'-1'  to be populated

*---------------------------------------------------------------------*
*     Set the EX length of each line of data to be copied to the      *
*    dynamic area                                                     *
*---------------------------------------------------------------------*
         L     R15,@K_ISPF_Dyn_Area_Width Get area width
         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Len
         AHI   R15,-1                   EX length of data
         ST    R15,@K_VolTbl_Ent_MVC_Len Save it

*---------------------------------------------------------------------*
*   Produce Heading 0, if required ...                                *
*---------------------------------------------------------------------*
         TM    @_No_Headings,L'@_No_Headings  Headings wanted?
         JO    K00050                   No, skip

         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'HDG0'           Point to variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         L     R15,@_VolTbl_Ptr         A(Volume Table)
         LA    R15,VolTbl_Ent-VolTbl(R15) Point to first heading
         LA    R15,VolTbl_Ent_Display-VolTbl_Ent(R15) Readable data
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@K_ISPF_Parms+12     Save it
         LHI   R15,VolTbl_Ent_Display_Len Get max display len
         ST    R15,@K_DBLWD             Save it
         LA    R15,@K_DBLWD             A(record length)
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*---------------------------------------------------------------------*
*   ... and count the number of heading lines in the table.           *
*---------------------------------------------------------------------*
         LA    R14,0                    Nbr hdg lines in VolTbl
         LA    R15,0                    Nbr hdg lines in ISPF area

         L     R9,@_VolTbl_Ptr          A(Volume Table)
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries
         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry
         USING VolTbl_Ent,R9            and assign a base
K00020   DS    0H
         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1
         JO    K00030                   Yes, skip
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line
         JNO   K00040                   Not a hdg line, all done
         AHI   R15,1                    Bump hdgs in ISPF area
K00030   DS    0H
         AHI   R14,1                    Bump hdgs in VolTbl

         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,K00020               and continue

         DROP  R9                       Free VolTbl_Ent base
K00040   DS    0H
         C     R15,@K_ISPF_Dyn_Area_Depth Is Dyn Area deep enough?
         JNL   K80010                   No, use BRIF instead

         ST    R15,@K_ISPF_Dyn_Area_Hdg_Lines Save it
         ST    R14,@K_VolTbl_Hdg_Lines  Save nbr hdgs in VolTbl

         L     R15,@K_VolTbl_Ent_Display_Line_Max Get max display line
         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines
         ST    R15,@K_VolTbl_Ent_Display_Line_Max Save it

K00050   DS    0H
*---------------------------------------------------------------------*
*    VDEFINE FLIN, used in the 'Line x' display                       *
*---------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'FLIN'           Variable name (Curr line nbr)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_FLIN              Point to it
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=CL8'CHAR'           Character data
         ST    R15,@K_ISPF_Parms+12     Save it
         LA    R15,L'@K_FLIN            Length of variable
         ST    R15,@K_ISPF_Parms+20     Save it
         LA    R15,@K_ISPF_Parms+20     Point to it
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

K00060   DS    0H
*---------------------------------------------------------------------*
*         Populate the table.                                         *
*                                                                     *
*     Verify that the display line and offset are within our limits.  *
*    Note that @K_VolTbl_Ent_Display_Line is relative to the 1st      *
*    non-heading line in VolTbl.                                      *
*    If they aren't, adjust them.                                     *
*---------------------------------------------------------------------*
         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Get line nbr
         JNM   K00070                       0 or greater, OK
         LA    R15,0                        Fix it
K00070   DS    0H
         C     R15,@K_VolTbl_Ent_Display_Line_Max Too big?
         JNH   K00080                       No, OK
         L     R15,@K_VolTbl_Ent_Display_Line_Max Yes, reset it
K00080   DS    0H
         ST    R15,@K_VolTbl_Ent_Display_Line Save it

         L     R15,@K_VolTbl_Ent_Offset     Get offset
         C     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) small?
         JNL   K00090                       No, OK
         L     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)
K00090   DS    0H
         C     R15,@K_VolTbl_Ent_Offset_Max Too big?
         JNH   K00100                   No, OK
         L     R15,@K_VolTbl_Ent_Offset_Max Yes, reset it
K00100   DS    0H
         ST    R15,@K_VolTbl_Ent_Offset Save it

*---------------------------------------------------------------------*
*     If the display line and the offset have not changed, we can     *
*    just redisplay                                                   *
*---------------------------------------------------------------------*
         CLC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+
               ne
         JNE   K00110                   Display line changed
         CLC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset
         JE    K00260                   Nothing changed, skip

K00110   DS    0H
*---------------------------------------------------------------------*
*     If we need to re-generate the headings (because of a LEFT/RIGHT *
*    scroll), do it now                                               *
*---------------------------------------------------------------------*
         TM    @_No_Headings,L'@_No_Headings  Are we doing headings?
         JO    K00140                   No, skip
         L     R15,@K_VolTbl_Ent_Offset Yes, get offset
         C     R15,@K_VolTbl_Ent_Offset_Prev Same as last time?
         JE    K00140                   Yes, skip

         L     R3,@K_ISPF_Dyn_Area_Ptr  A(data for dynamic area)

         L     R9,@_VolTbl_Ptr          A(Volume Table)
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries
         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry
         USING VolTbl_Ent,R9            and assign a base

K00120   DS    0H
         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1
         JO    K00130                   Heading 0, skip
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line
         JZ    K00140                   Not a heading line, skip

         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+
               isplay
         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3)
         LA    R15,VolTbl_Ent_Display   A(Start of source)
         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)
         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved
         EX    R14,K_MVC                Move the data
         A     R3,@K_ISPF_Dyn_Area_Width A(Next output area pointer)

K00130   DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,K00120               and continue

K00140   DS    0H
*--------------------------------------------------------------------*
*     Calculate the address of the 1st line of data in the dynamic   *
*    area                                                            *
*--------------------------------------------------------------------*
         L     R15,@K_ISPF_Dyn_Area_Hdg_Lines Nbr heading lines
         M     R14,@K_ISPF_Dyn_Area_Width times length of line
         A     R15,@K_ISPF_Dyn_Area_Ptr Point to  it
         LR    R3,R15                   with the proper register

*--------------------------------------------------------------------*
*     If we are at the top of the table, insert our 'Top of Data'    *
*    line.                                                           *
*--------------------------------------------------------------------*
         ICM   R15,B'1111',@K_VolTbl_Ent_Display_Line Curr display line
         JNZ   K00150                   Not at top, skip

         MVI   0(R3),C'*'               A line of asterisks
         LR    R15,R3                   Point to it
         LA    R1,1(0,R3)               A(Target area
         L     R14,@K_ISPF_Dyn_Area_Width Get width
         AHI   R14,2                    EX Length
         EX    R14,K_MVC                All asterisks

         L     R14,@K_ISPF_Dyn_Area_Width Get width
         LA    R15,13                   Length of literal
         SR    R14,R15                  Center our
         SRL   R14,1                     message
         LA    R1,0(R3,R14)             Point to start
         S     R1,=FL4'1'                of output area
         LA    R14,13                   Length of literal
         AHI   R14,-1                   EX length
         LA    R15,=CL13' Top of data ' A(Literal)
         EX    R14,K_MVC                Move top of data text

         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer
         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate
         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max
         CR    R3,R15                   Filled it up?
         JNL   K00260                  Yes, go display

K00150   DS    0H
*--------------------------------------------------------------------*
*     Point to the 1st VolTbl_Ent line to be output ...              *
*--------------------------------------------------------------------*
         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number
         L     R5,=FL4'-1'              Clear entry counter

         L     R15,@K_VolTbl_Hdg_Lines   Nbr hdg lines in VolTbl
         MHI   R15,VolTbl_Ent_Len        * length of 1 entry

         L     R9,@_VolTbl_Ptr          A(Volume Table)
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries
         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry
         AR    R9,R15                   Point to our entry
         S     R10,@K_VolTbl_Hdg_Lines  Nbr lines left in table
         JNP   K00250                   None, skip

K00170   DS    0H
*--------------------------------------------------------------------*
*     Find the entry (we count in R5) that corresponds to the        *
*    entry we want (in R4)                                           *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?
         JNO   K00180                   No, skip
         TM    @_No_Details,L'@_No_Details Yes, do we want it?
         JO    K00240                   No, skip it
         J     K00200                   Yes, process it
K00180   DS    0H

         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Detail?
         JNO   K00190                   No, skip
         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?
         JO    K00240                   No, skip it
         J     K00200                   Yes, process it
K00190   DS    0H
         TM    @_Statistics,L'@_Statistics Do we want stats?
         JNO   K00240                   No, skip it

         LA    R15,VolTbl_Ent           A(Table entry)
         ST    R15,@K_Parms_V00010      Save it

         LA    R1,@K_Parms              A(Parm list)
         BRAS  R14,V00010               Go process stats line
K00200   DS    0H
         AHI   R5,1                     Bump counter
         CR    R4,R5                    Ours?
         JH    K00240                   Not yet, skip
         TM    VolTbl_Ent_ECB,X'40'     Is it populated?
         JO    K00210                   Yes, OK
         WAIT  ECB=VolTbl_Ent_ECB       No, WAIT for it

K00210 DS     0H
*--------------------------------------------------------------------*
*     Move the VolTbl_Ent data to the dynamic display area.          *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Stats_Line,L'VolTbl_Ent_Stats_Line Stats?
         JNO   K00220                   No, OK

         LR    R1,R3                    A(Target area)
         LA    R15,VolTbl_Ent_Display   A(Source)
         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)
         A     R15,@K_VolTbl_Ent_Offset Plus offset
         L     R14,@K_ISPF_Dyn_Area_Width Get length to move
         AHI   R14,-1                   EX length
         EX    R14,K_MVC                Move the data
         J     K00230                   and skip

K00220   DS    0H
         MVC   0(VolTbl_Ent_DevType-VolTbl_Ent_Display,R3),VolTbl_Ent_D+
               isplay
         LA    R1,VolTbl_Ent_DevType-VolTbl_Ent_Display(0,R3) A(Target)
         LA    R15,VolTbl_Ent_Display   A(Start of source)
         A     R15,@K_VolTbl_Ent_Offset A(Start of our data)
         L     R14,@K_VolTbl_Ent_MVC_Len EX len of data to be moved
         EX    R14,K_MVC                Move the data

K00230   DS    0H
*--------------------------------------------------------------------*
*     Bump the output pointer, and, if there is still room, ...      *
*--------------------------------------------------------------------*
         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer
         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate
         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max
         CR    R3,R15                   Filled it up?
         JNL   K00260                  Yes, go display

K00240   DS    0H
*--------------------------------------------------------------------*
*     ... process the next entry                                     *
*--------------------------------------------------------------------*
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,K00170               and continue

K00250   DS    0H
*--------------------------------------------------------------------*
*     Add our 'Bottom of data' line.                                 *
*--------------------------------------------------------------------*
         MVI   0(R3),C'*'               A line of asterisks
         LR    R15,R3                   Point to it
         LA    R1,1(0,R3)               A(Target area
         L     R14,@K_ISPF_Dyn_Area_Width Get width
         AHI   R14,-2                   EX len
         EX    R14,K_MVC                All asterisks

         L     R14,@K_ISPF_Dyn_Area_Width Get width
         LA    R15,16                   Length of literal
         SR    R14,R15                  Center our
         SRL   R14,1                     message
         LA    R1,0(R3,R14)             Point to start
         S     R1,=FL4'1'                of output area
         LA    R14,16                   Length of literal
         AHI   R14,-1                   EX length
         LA    R15,=CL16' Bottom of data ' A(Literal)
         EX    R14,K_MVC                Move bottom of data text

*--------------------------------------------------------------------*
*     And clear out the rest of the display area                     *
*--------------------------------------------------------------------*
         A     R3,@K_ISPF_Dyn_Area_Width Bump output pointer
         L     R15,@K_ISPF_Dyn_Area_Ptr Calculate
         A     R15,@K_ISPF_Dyn_Area_Len  Dyn area max
         CR    R3,R15                   Filled it up?
         JNL   K00260                  Yes, go display

         LR    R0,R3                    No, A(Start of area to clear)
         LR    R1,R15                   Calculate length
         SR    R1,R0                     to clear
         LA    R14,0                    No sending address
         LA    R15,C' '                 Pad character
         SLL   R15,24                    of blank
         MVCL  R0,R14                   Clear remainder if dynamic area

K00260   DS    0H
*--------------------------------------------------------------------*
*     Save the current start line and offset ...                     *
*--------------------------------------------------------------------*
         MVC   @K_VolTbl_Ent_Display_Line_Prev,@K_VolTbl_Ent_Display_Li+
               ne
         MVC   @K_VolTbl_Ent_Offset_Prev,@K_VolTbl_Ent_Offset

*--------------------------------------------------------------------*
*     ... fill in the variable containing the 1st line number ...    *
*--------------------------------------------------------------------*
         L     R15,@K_VolTbl_Ent_Display_Line Get FLIN
         AHI   R15,1                    Relative to 1
         CVD   R15,@K_DBLWD             Pack it
         MVC   @K_FLIN-1(L'@K_FLIN+1),=X'402020202120'  Move mask
         ED    @K_FLIN-1(L'@K_FLIN+1),@K_DBLWD+5

*--------------------------------------------------------------------*
*     ... and display our panel                                      *
*--------------------------------------------------------------------*
         LA    R15,=CL8'DISPLAY'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'&PNLNAME'       A(Panel name)
         ST    R15,@K_ISPF_Parms+4      Save it
         OI    @K_ISPF_Parms+4,X'80'    Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go display table
         CHI   R15,8                    END or RETURN?
         JNL   K00720                   Yes, just get out

*--------------------------------------------------------------------*
*     If the user entered CANCEL, we are done.                       *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ZCMD'           Variable we want
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_ISPF_VCOPY_Lens   A(Length Address)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Variable)
         ST    R15,@K_ISPF_Parms+12     Save it
         OI    @K_ISPF_Parms+12,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go get the variable

         LTR   R15,R15                  Did we get it?
         JNZ   K00300                   No, skip check for CANCEL

         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Get ZCMD length
         JZ    K00300                   Nothing, skip
         CHI   R14,3                    Could it be CANcel?
         JL    K00270                   No, skip
         CHI   R14,6                    Maybe, check again
         JH    K00270                   Not CANCEL, skip
         ICM   R15,B'1111',@K_ISPF_VCOPY_Var_Ptr A(ZCMD)
         JZ    K00300                   Nothing, skip
         LA    R1,@K_DBLWD              A(Work area)
         AHI   R14,-1                   EX Len
         EX    R14,K_MVC                Move to work area
         OC    @K_DBLWD,=CL8' '         Uppercase it
         EX    R14,K_CLC1               Check it out
         JE    K00720                   CANCEL, just exit

K00270   DS    0H
*--------------------------------------------------------------------*
*     Check out what happened. First check the command for something *
*    we recognize ...                                                *
*--------------------------------------------------------------------*
         LA    R1,@K_Parms              A(Parm list)
         BRAS  R14,L00010               Check out command

         TM    @_ReDisplay,L'@_ReDisplay Change display mode?
         JO    K00280                   Yes, skip
         LTR   R15,R15                  No, did it work?
         JNZ   K00700                   No, unknown command
         J     K00290                   Unknown command, skip

K00280   DS    0H
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ZCMD'           Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,K_Blanks             A(blank string)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@K_ISPF_Parms+12     Save it
         LA    R15,=AL4(L'K_Blanks)     Length of blank string
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'VPUT'           ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ZCMD'           A(Variable name)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,=CL8'ASIS'           A(Variable name)
         ST    R15,@K_ISPF_Parms+8      Save it
         OI    @K_ISPF_Parms+8,X'80'    Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LHI   R15,20                   Change display mode, set rc
         J     K90010                   and exit

K00290   DS    0H
*--------------------------------------------------------------------*
*     We have processed the command, so clear ZCMD ...               *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VREPLACE'       ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ZCMD'           Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,=AL4(0)              Length of variable
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,0                    Null value
         ST    R15,@K_ISPF_Parms+12     Save it
         OI    @K_ISPF_Parms+12,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

*--------------------------------------------------------------------*
*     ... and force a refresh of the table display area.             *
*--------------------------------------------------------------------*
         MVC   @K_VolTbl_Ent_Display_Line_Prev,=FL4'-1' Force tbl refr

K00300   DS    0H
*--------------------------------------------------------------------*
*     Check for scroll request:                                      *
*       ZVERB    = UP, DOWN, LEFT, or RIGHT                          *
*       ZSCROLLN = scroll amount                                     *
*       ZSCROLLA = PAGE, CSR, MAX, etc.                              *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,K_ISPF_VCOPY_Scroll_Names   A(Variable Names)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_ISPF_VCOPY_Scroll_Lens   A(Lengths)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_ISPF_VCOPY_Scroll_Ptrs   A(Addresses)
         ST    R15,@K_ISPF_Parms+12     Save it
         OI    @K_ISPF_Parms+12,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go get variables

         CHI   R15,8                    Did we get any?
         JH    K00710                   No, just re-display

         NI    @K_Scroll_UP,X'FF'-L'@K_Scroll_UP  Off our flag
         NI    @K_Scroll_DOWN,X'FF'-L'@K_Scroll_DOWN  Off our flag
         NI    @K_Scroll_LEFT,X'FF'-L'@K_Scroll_LEFT  Off our flag
         NI    @K_Scroll_RIGHT,X'FF'-L'@K_Scroll_RIGHT  Off our flag
         NI    @K_Scroll_MAX,X'FF'-L'@K_Scroll_MAX  Off our flag

         ICM   R14,B'1111',@K_ISPF_VCOPY_ZVERB_Len Len of ZVERB
         JZ    K00500                   Nothing, go check expand
         ICM   R15,B'1111',@K_ISPF_VCOPY_ZVERB_Ptr A(ZVERB)
         JZ    K00500                   Nothing, check expand

         CHI   R14,2                    Could it be UP?
         JNE   K00310                   No, skip
         CLC   =C'UP',0(R15)            Could be, is it?
         JNE   K00710                   No, ignore it
         OI    @K_Scroll_UP,L'@K_Scroll_UP  Yes, say so
         J     K00340                   and check ZSCROLLN
K00310   DS    0H

         CHI   R14,4                    Could it be DOWN or LEFT?
         JNE   K00330                   No, skip
         CLC   =C'DOWN',0(R15)          Could be, is it DOWN?
         JNE   K00320                   No, go check LEFT
         OI    @K_Scroll_DOWN,L'@K_Scroll_DOWN  Yes, say so
         J     K00340                   and check ZSCROLLN
K00320   DS    0H
         CLC   =C'LEFT',0(R15)          Is it LEFT?
         JNE   K00710                   No, ignore it
         OI    @K_Scroll_LEFT,L'@K_Scroll_LEFT  Yes, say so
         J     K00340                   and check ZSCROLLN
K00330   DS    0H
         CHI   R14,5                    Could it be RIGHT?
         JNE   K00710                   No, ignore it
         CLC   =C'RIGHT',0(R15)         Could be, is it?
         JNE   K00710                   No, ignore it
         OI    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Yes, say so
         J     K00340                   and check ZSCROLLN

K00340   DS    0H
*--------------------------------------------------------------------*
*     We have a scroll command, check ZSCROLLA for MAX               *
*--------------------------------------------------------------------*
         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Len Len of ZSCROLLA
         JZ    K00350                   Nothing, check ZSCROLLN
         CHI   R14,3                    Could it be MAX?
         JNE   K00350                   No, check ZSCROLLN
         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)
         JZ    K00350                   Nothing, check ZSCROLLN
         CLC   =C'MAX',0(R1)            Is it MAX?
         JNE   K00350                   No, skip
         OI    @K_Scroll_MAX,L'@K_Scroll_MAX Yes, set our flag

K00350   DS    0H
*--------------------------------------------------------------------*
*     Set a flag if the user entered an explicit scroll amount       *
*    (eg, DOWN 16). We can determine this if ZSCROLLN = ZSCROLLA     *
*--------------------------------------------------------------------*
         NI    @K_Scroll_Explicit,X'FF'-L'@K_Scroll_Explicit
         ICM   R15,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len ZSCROLLN Length
         JZ    K00360                   Nothing, skip
         C     R15,@K_ISPF_VCOPY_ZSCROLLA_Len Same as ZSCROLLA?
         JNE   K00360                   No, skip
         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr Yes, A(ZSCROLLN)
         JZ    K00360                   Nothing, skip
         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLA_Ptr A(ZSCROLLA)
         JZ    K00360                   Nothing, skip
         AHI   R15,-1                   EX length
         EX    R15,K_CLC                Same value?
         JNE   K00360                   No, skip
         OI    @K_Scroll_Explicit,L'@K_Scroll_Explicit Yes, set flag

K00360   DS    0H
*--------------------------------------------------------------------*
*     Get ZSCROLLN (defaulting to 0 )                                *
*--------------------------------------------------------------------*
         LA    R15,0                    Set our default

         ICM   R14,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Len Len of ZSCROLLN
         JZ    K00370                   Nothing, just re-display
         ICM   R1,B'1111',@K_ISPF_VCOPY_ZSCROLLN_Ptr A(ZSCROLLN)
         JZ    K00370                   Nothing, ignore it
         AHI   R14,-1                   EX len
         EX    R14,K_PACK               Pack it
         CVB   R15,@K_DBLWD             Binarize it

K00370   DS    0H
         TM    @K_Scroll_RIGHT,L'@K_Scroll_RIGHT  Horizontal?
         JO    K00430                   Yes, skip
         TM    @K_Scroll_LEFT,L'@K_Scroll_LEFT No, check again
         JO    K00460                   Yes, skip
         TM    @K_Scroll_DOWN,L'@K_Scroll_DOWN No, scroll DOWN?
         JO    K00390                   Yes, skip

*--------------------------------------------------------------------*
*     Scroll UP                                                      *
*--------------------------------------------------------------------*
         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  UP MAX?
         JO    K00380                   Yes, set to top
         L     R14,@K_VolTbl_Ent_Display_Line Get current line number
         SR    R14,R15                  Back up the scroll amount
         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?
         JO    K00420                   Yes, all done
*        A     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings
         J     K00420                   and skip
K00380   DS    0H
         LA    R14,0                    UP MAX, reset line number
         J     K00420                   and skip

K00390   DS    0H
*--------------------------------------------------------------------*
*     Scroll DOWN                                                    *
*--------------------------------------------------------------------*
         TM    @K_Scroll_MAX,L'@K_Scroll_MAX  DOWN MAX?
         JO    K00400                   Yes, skip
         ICM   R14,B'1111',@K_VolTbl_Ent_Display_Line No, curr line nbr
         JP    K00390C                  OK, skip
         AHI   R14,-1                   Account for Top of Data line
K00390C  DS    0H
         AR    R14,R15                  Line number
         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?
         JO    K00420                   Yes, all done
         S     R14,@K_ISPF_Dyn_Area_Hdg_Lines No, adjust for headings
         J     K00420                   and skip

K00400   DS    0H
*--------------------------------------------------------------------*
*     Scroll DOWN MAX - get the last visible line, and use it        *
*    instead of @K_ISPF_Dyn_Area_Depth                               *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'SSCSPCLV'       A(Variable Names)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_ISPF_VCOPY_Lens   A(Lengths)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_ISPF_VCOPY_Ptrs   A(Addresses)
         ST    R15,@K_ISPF_Parms+12     Save it
         OI    @K_ISPF_Parms+12,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go display table

         L     R0,@K_ISPF_Dyn_Area_Depth Init our depth
         LTR   R15,R15                  Did it work?
         JNZ   K00410                   No, skip

         ICM   R14,B'1111',@K_ISPF_VCOPY_Var_Len Len of SSCSPCLV
         JZ    K00410                   Nothing, skip
         ICM   R1,B'1111',@K_ISPF_VCOPY_Var_Ptr A(SSCSPCLV)
         JZ    K00410                   Nothing, ignore it
         AHI   R14,-1                   EX len
         EX    R14,K_PACK               Pack it
         CVB   R0,@K_DBLWD              Binarize it
K00410   DS    0H
         L     R14,@K_VolTbl_Ent_Display_Line_Max Get max display line
         SR    R14,R0                   Back up a screen
         A     R14,@K_ISPF_Dyn_Area_Hdg_Lines Adjust for heading lines
         AHI   R14,1                    Make Bottom of Data visible
         J     K00420                   and skip

K00420   DS    0H
*--------------------------------------------------------------------*
*     Vertical Scroll, save updated line number, and skip            *
*--------------------------------------------------------------------*
         ST    R14,@K_VolTbl_Ent_Display_Line Save new line number
         J     K00710                   Go re-display

K00430   DS    0H
*--------------------------------------------------------------------*
*     Scroll RIGHT                                                   *
*--------------------------------------------------------------------*
         TM    @K_Scroll_Max,L'@K_Scroll_Max  RIGHT MAX?
         JNO   K00440                   No, skip
         L     R14,@K_VolTbl_Ent_Offset_Max Yes, get max offset
         J     K00490                   and skip
K00440   DS    0H
         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?
         JO    K00450                   Yes, skip
         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Adj scrl
         JP    K00450                   OK, skip
         L     R15,@K_ISPF_Dyn_Area_Width cursor in non-scroll area,
         S     R15,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Width
K00450   DS    0H
         L     R14,@K_VolTbl_Ent_Offset Get current offset
         AR    R14,R15                  Adjust offset
         J     K00490                   and skip

K00460   DS    0H
*--------------------------------------------------------------------*
*     Scroll LEFT                                                    *
*--------------------------------------------------------------------*
         TM    @K_Scroll_Max,L'@K_Scroll_Max  LEFT MAX?
         JO    K00480                   Yes, skip

         TM    @K_Scroll_Explicit,L'@K_Scroll_Explicit Explicit nbr?
         JO    K00470                   Yes, skip
         L     R0,@K_ISPF_Dyn_Area_Width Get width of
         S     R0,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) scrl area
         CR    R15,R0                   Too far left?
         JNH   K00470                   No, OK
         LR    R15,R0                   Yes, set to 1 screens worth
K00470   DS    0H
         L     R14,@K_VolTbl_Ent_Offset Get current offset
         SR    R14,R15                  Adjust it
         J     K00490                   and skip
K00480   DS    0H
         L     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display) Set min

K00490   DS    0H
*--------------------------------------------------------------------*
*     Horizontal scroll - save new offset                            *
*--------------------------------------------------------------------*
         ST    R14,@K_VolTbl_Ent_Offset Yes, save new offset
         J     K00710                   and redisplay

K00500   DS    0H
*--------------------------------------------------------------------*
*     Not a scroll command -  see if the cursor is in the DATA       *
*    field, and on a numeric field. If so, the value of the field is *
*    displayed. This will allow the user to see the actual values    *
*    for fields we have scaled to fit in our display.                *
*                                                                    *
*    Get ZSCREENW (screen width)                                     *
*        ZSCREENC (cursor position ((row# * ZSCREENW) + col#)))      *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,K_ISPF_VCOPY_Cursor_Names   A(Variable Names)
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_ISPF_VCOPY_Cursor_Lens   A(Lengths)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_ISPF_VCOPY_Cursor_Ptrs   A(Addresses)
         ST    R15,@K_ISPF_Parms+12     Save it
         OI    @K_ISPF_Parms+12,X'80'   Flag last parm
         LA    R1,@K_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go get variables

         LTR   R15,R15                  Did we?
         JNZ   K00710                   No, just re-display

*--------------------------------------------------------------------*
*     Get the cursor row and column (on the screen) ...              *
*--------------------------------------------------------------------*
         ICM   R15,B'1111',@K_ISPF_ZSCREENC_Len Get ZSCREENC length
         JNP   K00710                   Nothing, just re-display
         AHI   R15,-1                   EX length
         ICM   R1,B'1111',@K_ISPF_ZSCREENC_Ptr Get A(ZSCREENC)
         JZ    K00710                   Nothing, just re-display
         EX    R15,K_PACK               PACK it
         CVB   R15,@K_DBLWD             Cursor position in screen

         ICM   R14,B'1111',@K_ISPF_ZSCREENW_Len Get ZSCREENW length
         JZ    K00710                   Nothing, just re-display
         ICM   R1,B'1111',@K_ISPF_ZSCREENW_Ptr Get A(ZSCREENW)
         JZ    K00710                   Nothing, just re-display
         AHI   R14,-1                   EX length
         EX    R14,K_PACK               PACK it
         CVB   R1,@K_DBLWD              Screen width

         LA    R14,0                    Clear high-order register
         DR    R14,R1                   R14: Col, R15: Row

*--------------------------------------------------------------------*
*     ... and see if it is within the DATA field                     *
*--------------------------------------------------------------------*
         S     R15,@K_ISPF_Dyn_Area_Row  Relative row in DATA
         JM    K00710                   Before start of DATA, exit
         C     R15,@K_ISPF_Dyn_Area_Depth Really within DATA?
         JNL   K00710                   No, just redisplay

         S     R14,@K_ISPF_Dyn_Area_Column Relative column of DATA
         JM    K00710                   To the left of DATA, exit
         C     R0,@K_ISPF_Dyn_Area_Width Really within DATA?
         JNL   K00710                   No, just redisplay

         S     R15,@K_ISPF_Dyn_Area_Hdg_Lines minus heading lines
         JM    K00710                   Cursor on a heading line
         ICM   R4,B'1111',@K_VolTbl_Ent_Display_Line Get line number
         JNZ   K00510                   Not 0, OK
         AHI   R15,-1                   Adjust for 'Top of Data'
         JM    K00710                   Cursor on 'Top of Data'
K00510   DS    0H
         AR    R4,R15                   R4 = Cursor row
         L     R5,=FL4'-1'              Clear entry counter

         L     R9,@_VolTbl_Ptr          A(Volume Table)
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Get nbr entries
         AHI   R9,VolTbl_Ent-VolTbl     Point to first entry

K00520   DS    0H
*--------------------------------------------------------------------*
*     Find the entry (we count in R5) that corresponds to the        *
*    entry we want (in R4)                                           *
*--------------------------------------------------------------------*
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?
         JNO   K00530                   No, skip
         TM    @_No_Details,L'@_No_Details Yes, do we want it?
         JO    K00550                   No, skip it
         J     K00540                   Yes, count it
K00530   DS    0H
         TM    VolTbl_Ent_Total_Line,L'VolTbl_Ent_Total_Line Total?
         JNO   K00550                   No, skip it
         TM    @_No_Totals,L'@_No_Totals Yes, do we want it?
         JO    K00550                   No, skip it
K00540   DS    0H
         AHI   R5,1                     Bump counter
         CR    R4,R5                    Ours?
         JNH   K00560                   Yup, skip
K00550   DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry)
         BRCT  R10,K00520               and continue
         J     K00710                   Not on a row, ignore it

K00560   DS    0H
         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line Anomaly msg?
         JO    K00710                   Yes, ignore it

         TM    VolTbl_Ent_LSPACE_Fail,L'VolTbl_Ent_LSPACE_Fail Data?
         JO    K00710                   No, ignore it

*--------------------------------------------------------------------*
*     It looks like the cursor is on a line in our table - see if    *
*    it is also within a numeric field                               *
*--------------------------------------------------------------------*
         C     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)
         JL    K00710                   Cursor in line prefix

         A     R14,@K_VolTbl_Ent_Offset  Get offset within VolTbl_Ent
         S     R14,=AL4(VolTbl_Ent_DevType-VolTbl_Ent_Display)
         LA    R15,K_Expand_Tbl         A(Table of offsets)
K00570   DS    0H
         CH    R14,0(0,R15)             Our field?
         JL    K00580                   No, skip
         CH    R14,2(0,R15)             Maybe, is it?
         JNH   K00590                   Yes, skip
K00580   DS    0H
         AHI   R15,K_Expand_Ent_Len     Bump our pointer
         CLC   =HL2'0',0(R15)           End of table?
         JNE   K00570                   No, keep checking
         J     K00710                   Yes, just redisplay
K00590   DS    0H
         LH    R14,4(0,R15)             Offset of FP field
         LD    R2,VolTbl_Ent(R14)       Get floating point value
*--------------------------------------------------------------------*
*     If this is a percent (length of output area = 4), and thus the *
*    only type of field with fractions) ...                          *
*--------------------------------------------------------------------*
         LH    R0,2(0,R15)              A(End of output field) + 1
         SH    R0,0(0,R15)              Less A(Start of output field)
         CHI   R0,4                     Is this a percent?
         JNE   K00630                   No, skip

*--------------------------------------------------------------------*
*     ... format it                                                  *
*--------------------------------------------------------------------*
         MDB   R2,=DBL8'10000000000000' 13-digit fraction
         CGDBR R0,B'0101',R2            Convert to fixed, round to 0
         CVDG  R0,@K_QuadWord           Pack it
         MVC   @K_Expand_Number(17),=X'4021204B202020202020202020202020+
               20'                      Move mask
         LA    R1,@K_Expand_Number+2    A(Start of significance)
         EDMK  @K_Expand_Number(17),@K_QuadWord+8 Unpack it
         ST    R1,@K_Expand_NumStart    Save A(Start of number)
         LA    R1,@K_Expand_Number+16   A(last possible 0
K00600   DS    0H
         CLI   0(R1),C'0'               Trailing 0?
         JNE   K00610                   No, found the end
         BRCT  R1,K00600                Yes, check prev byte
K00610   DS    0H
         CLI   0(R1),C'.'               Back to the decimal point?
         JNE   K00620                   No, OK
         AHI   R1,2                     Yes, set to 2 decimal places
K00620   DS    0H
         ST    R1,@K_Expand_NumEnd      Save A(end of number)
         J     K00670                   and skip

K00630   DS    0H
*--------------------------------------------------------------------*
*     Not a percent, we don't have to worry about decimal points.    *
*    Format it in 2 groups of 15 decimal digits (max for ED/UNPK),   *
*    unintuitively doing the rightmost group first.                  *
*--------------------------------------------------------------------*
         CGDBR R0,B'0101',R2            Convert to fixed, round to 0
         CVDG  R0,@K_QuadWord           Pack it
         LA    R15,@K_Expand_Number+L'@K_Expand_Number A(End of output)
K00640   DS    0H
         AHI   R15,-20                  Move mask
         MVC   0(20,R15),=X'402020206B2020206B2020206B2020206B202120'
         LG    R0,@K_QuadWord           Get high dblwd
         LTGR  R0,R0                    Anything in it?
         JZ    K00650                   No, OK
         MVI   1(R15),X'21'             Yes, turn on significance
K00650   DS    0H
         LA    R1,19(0,R15)             Init A(1st significant field)
         EDMK  0(20,R15),@K_QuadWord+8  Edit in data
         LG    R0,@K_QuadWord           Get high dblwd
         LTGR  R0,R0                    Anything in it?
         JZ    K00660                   No, all done
         SLLG  R0,R0,4                  Yes, make room for sign
         STG   R0,@K_QuadWord+8         Save it
         OI    @K_Quadword+15,X'0F'     Set sign
         SLG   R0,R0                    and clear
         STG   R0,@K_QuadWord             high dblwd
         MVI   0(R15),C','              Move separator
         CLI   1(R15),C' '              Significant 0 missed?
         JNE   K00640                   No, OK
         MVI   1(R15),C'0'              Yes, set it
         J     K00640                   Go process it
K00660   DS    0H
         ST    R1,@K_Expand_NumStart    Save start of significance
         LA    R1,@K_Expand_Number+L'@K_Expand_Number-1 A(End)
         ST    R1,@K_Expand_NumEnd      Save it

K00670   DS    0H
*--------------------------------------------------------------------*
*     Set up the SMSG ...                                            *
*--------------------------------------------------------------------*
         MVI   @K_Expand_ZEDSMSG,C' '
         MVC   @K_Expand_ZEDSMSG+1(L'@K_Expand_ZEDSMSG-1),@K_Expand_ZED+
               SMSG
         L     R1,@K_Expand_NumStart    A(Start of number)
         L     R15,@K_Expand_NumEnd     A(End)
         SR    R15,R1                   Get EX length of number
         CHI   R15,L'@K_Expand_ZEDSMSG  Too long for SMSG?
         JL    K00680                   No, OK
         LA    R1,=C'>>>>>>>>'          Yes, Indicate number too big
         LA    R15,7                    EX Length
K00680   DS    0H
         LA    R14,@K_Expand_ZEDSMSG    A(SMSG)
         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)
         LA    R0,1(0,R15)              Real length
         ST    R0,@K_Expand_ZEDSMSG_Len Save it

*--------------------------------------------------------------------*
*     ... and LMSG                                                   *
*--------------------------------------------------------------------*
         MVC   @K_Expand_ZEDLMSG(L'K_Expand_ZEDLMSG_Pfx),K_Expand_ZEDLM+
               SG_Pfx
         LA    R14,@K_Expand_ZEDLMSG+L'K_Expand_ZEDLMSG_Pfx
         L     R1,@K_Expand_NumStart    A(Source)
         L     R15,@K_Expand_NumEnd     Calculate
         SR    R15,R1                    length
         EX    R15,K_K00680_MVC         MVC   0(0,R14),0(R1)
         AHI   R15,L'K_Expand_ZEDLMSG_Pfx+1 Len of LMSG
         ST    R15,@K_Expand_ZEDLMSG_Len Save it

*--------------------------------------------------------------------*
*     Tell ISPF about the messages, and re-display                   *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@K_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_Expand_ZEDSMSG    A(Short Message)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_Expand_ZEDSMSG_Len Length of message
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,@K_Expand_ZEDLMSG    A(Long message)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,@K_Expand_ZEDLMSG_Len Length of message
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@K_ISPF_Parms+4      Save it
         OI    @K_ISPF_Parms+4,X'80'    Mark end of list
         LA    R1,@K_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         J     K00710                   And redisplay

K00700   DS    0H
*--------------------------------------------------------------------*
*     Unrecognized ZCMD - Issue messages ...                         *
*--------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@K_ISPF_Parms+12     Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,K_Bad_ZCMD_SMsg      A(Short Message)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'K_Bad_ZCMD_SMsg) Length of variable
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@K_ISPF_Parms+4      Save it
         LA    R15,K_Bad_ZCMD_LMsg      A(Long message)
         ST    R15,@K_ISPF_Parms+8      Save it
         LA    R15,=AL4(L'K_Bad_ZCMD_LMsg) Length of message
         ST    R15,@K_ISPF_Parms+16     Save it
         OI    @K_ISPF_Parms+16,X'80'   Flag end of list
         LA    R1,@K_ISPF_Parms         A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@K_ISPF_Parms        Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@K_ISPF_Parms+4      Save it
         OI    @K_ISPF_Parms+4,X'80'    Mark end of list
         LA    R1,@K_ISPF_Parms         Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         J     K00710                   And redisplay

K00710   DS    0H
*--------------------------------------------------------------------*
*     ... and re-display the table.                                  *
*--------------------------------------------------------------------*
         J     K00060                   and start again

K00720   DS    0H
*--------------------------------------------------------------------*
*     All done, clear our return code, and exit                      *
*--------------------------------------------------------------------*
         LA    R15,0                    Clear the return code
         J     K90010                   and exit


K80010   DS    0H
*--------------------------------------------------------------------*
*     Panel not found, set return code, and exit                     *
*--------------------------------------------------------------------*
         LA    R15,4                    Set return code
         J     K90010                   and exit

K90010   DS    0H
*---------------------------------------------------------------------*
*   Free up our Dynamic area storage                                  *
*---------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         ICM   R1,B'1111',@K_ISPF_Dyn_Area_Ptr
         JZ    K90020                   None, skip
         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack
K90020   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LA    R1,@K_Dynam              A(Local storage)
         L     R2,@K_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

K_Literals  DS  0H

K_MVC    MVC   0(0,R1),0(R15)           Move data to dynamic area
K_PACK   PACK  @K_DBLWD,0(0,R1)         Pack it
K_CLC    CLC   0(0,R1),0(R14)           Compare ZSCROLLN and ZSCROLLA
K_CLC1   CLC   @K_DBLWD(0),=C'CANCEL'   Check ZCMD for CANCEL
K_BLANKS DC    C' '

K_Bad_ZCMD_SMsg DC C'Invalid Command'
K_Bad_ZCMD_LMsg DC C'Valid commands are: SORT, UP, DOWN, LEFT, RIGHT, E+
               ND, RETURN, and CANCEL'

K_ISPF_PQUERY_Names DC C'('            PQUERY Variable Names
K_SPCDYNTY          DC CL8'SPCDYNTY',CL1' ' Type of Dyn area
K_SPCDYNWI          DC CL8'SPCDYNWI',CL1' ' Width
K_SPCDYNDE          DC CL8'SPCDYNDE',CL1' ' Depth
K_SPCDYNRO          DC CL8'SSCDYNRO',CL1' ' Starting Row
K_SPCDYNCO          DC CL8'SSCDYNCO',CL1' ' Starting Column
                    DC C')'
K_ISPF_PQUERY_Types DC CL8'CHAR'       Type of Dynamic area
                    DC CL8'FIXED'      Width
                    DC CL8'FIXED'      Depth
                    DC CL8'FIXED'      Starting Row
                    DC CL8'FIXED'      Starting Column
K_ISPF_PQUERY_Lens  DC FL4'8'          Length of Type
                    DC FL4'4'          Length of Width
                    DC FL4'4'          Length of Depth
                    DC FL4'4'          Length of Starting Row
                    DC FL4'4'          Length of Starting Column

K_ISPF_VCOPY_Scroll_Names DC C'(ZVERB,ZSCROLLN,ZSCROLLA)'
K_ISPF_VCOPY_Cursor_Names DC C'(ZSCREENW ZSCREENC)'

K_K00680_MVC           MVC   0(0,R14),0(R1)

K_Expand_Tbl           EQU   *
K_Expand_Ent           EQU   *
                       DC    AL2(VolTbl_Ent_FreeTrk-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_FreeTrk+L'VolTbl_Ent_FreeTr+
               k-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreeTrk-VolTbl_Ent)
K_Expand_Ent_Len       EQU   *-K_Expand_Ent
                       DC    AL2(VolTbl_Ent_FreeCyl-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_FreeCyl+L'VolTbl_Ent_FreeCy+
               l-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreeCyl-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_FreeBytes-VolTbl_Ent_Displa+
               y)
                       DC    AL2(VolTbl_Ent_FreeBytes+L'VolTbl_Ent_Free+
               Bytes-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreeBytes-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_FreePct-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_FreePct+L'VolTbl_Ent_FreePc+
               t-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreePct-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_FreeExt-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_FreeExt+L'VolTbl_Ent_FreeEx+
               t-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreeExt-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_LargTrk-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_LargTrk+L'VolTbl_Ent_LargTr+
               k-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_LargTrk-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_LargCyl-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_LargCyl+L'VolTbl_Ent_LargCy+
               l-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_LargCyl-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_VTOCTrk-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_VTOCTrk+L'VolTbl_Ent_VTOCTr+
               k-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_VTOCTrk-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_FreeDSCB-VolTbl_Ent_Display+
               )
                       DC    AL2(VolTbl_Ent_FreeDSCB+L'VolTbl_Ent_FreeD+
               SCB-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_FreeDSCB-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_VTOCFree-VolTbl_Ent_Display+
               )
                       DC    AL2(VolTbl_Ent_VTOCFree+L'VolTbl_Ent_VTOCF+
               ree-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_VTOCFree-VolTbl_Ent)

                       DC    AL2(VolTbl_Ent_VolSize-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_VolSize+L'VolTbl_Ent_VolSiz+
               e-VolTbl_Ent_Display)
                       DC    AL2(VolTbl_Ent_Sort_VolSize-VolTbl_Ent)

                       DC    AL2(0)
                       DC    AL2(0)
                       DC    AL2(0)

K_Expand_ZEDLMSG_Pfx   DC    C'The unrounded, unscaled value is '

         LTORG

K_Literals_End  DS  0H


@K_Dynam                  DSECT        Dynamic area for K
                          DS    18F     O/S style save area
@K_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@K_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@K_DBLWD                  DS    D       Work area
@K_QuadWord               DS    PL16    Work area
@K_ISPF_Parms             DS    8AL4    ISPF Parm list

@K_ISPF_Dyn_Area_Width    DS    FL4     Panel Dynam Area Width
@K_ISPF_Dyn_Area_Depth    DS    FL4     Panel Dynam Area Depth
@K_ISPF_Dyn_Area_Row      DS    FL4     Panel Dynam Area Start Row
@K_ISPF_Dyn_Area_Column   DS    FL4     Panel Dynam Area Start Column
@K_ISPF_Dyn_Area_Ptr      DS    AL4     A(Storage for dynamic area)
@K_ISPF_Dyn_Area_Len      DS    FL4     Length of dynamic area

                          DS    C
@K_FLIN                   DS    CL5     Line x

@K_VolTbl_Ent_MVC_Len     DS    FL4     EX len of MVC from VolTbl_Ent

@K_VolTbl_Ent_Display_Line DS   FL4     Current top of display
@K_VolTbl_Ent_Offset      DS    FL4     Offset for LEFT/RIGHT
@K_VolTbl_Ent_Display_Line_Max DS FL4   Max value of display line
@K_VolTbl_Ent_Offset_Max  DS    FL4     Max Offset for LEFT/RIGHT
@K_VolTbl_Ent_Display_Line_Prev DS FL4  Previous top of display
@K_VolTbl_Ent_Offset_Prev DS    FL4     Previous Offset for LEFT/RIGHT
@K_ISPF_Dyn_Area_Hdg_Lines DS   FL4     Nbr of hdg lines in display
@K_VolTbl_Hdg_Lines       DS    FL4     Nbr of hdg lines in VolTbl

                          DS    X       Flag byte
@K_Scroll_MAX             EQU   *-1,X'80' 1... .... Scroll MAX
@K_Scroll_Explicit        EQU   *-1,X'40' .1.. .... Explicit Scroll amt
@K_Scroll_UP              EQU   *-1,X'08' .... 1... Scroll UP
@K_Scroll_DOWN            EQU   *-1,X'04' .... .1.. Scroll DOWN
@K_Scroll_LEFT            EQU   *-1,X'02' .... ..1. Scroll LEFT
@K_Scroll_RIGHT           EQU   *-1,X'01' .... ...1 Scroll RIGHT


@K_Expand_Number          DS    XL40
@K_Expand_NumStart        DS    AL4
@K_Expand_NumEnd          DS    AL4

@K_Expand_ZEDSMSG         DS    CL24
@K_Expand_ZEDSMSG_Len     DS    FL4     Length
@K_Expand_ZEDLMSG         DS    CL(L'K_Expand_ZEDLMSG_Pfx+L'@K_Expand_N+
               umber)
@K_Expand_ZEDLMSG_Len     DS    FL4     Length

@K_ISPF_VCOPY_Ptrs        DS    0F      Pointer to var from VCOPY
@K_ISPF_VCOPY_Var_Ptr     DS    AL4     A(VCOPYed variable)
                          ORG   @K_ISPF_VCOPY_Ptrs
@K_ISPF_VCOPY_Scroll_Ptrs DS    0F      Pointers to vars from VCOPY
@K_ISPF_VCOPY_ZVERB_Ptr   DS    AL4      A(ZVERB)
@K_ISPF_VCOPY_ZSCROLLN_Ptr DS   AL4      A(ZSCROLLN)
@K_ISPF_VCOPY_ZSCROLLA_Ptr DS   AL4      A(ZSCROLLA)
                          ORG   @K_ISPF_VCOPY_Ptrs
@K_ISPF_PQUERY_Values     DS    0F     Value areas for PQUERY vars
@K_ISPF_SPCDYNTN_Value    DS    CL8     Type of area
@K_ISPF_SPCDYNWI_Value    DS    FL4     Area width
@K_ISPF_SPCDYNDE_Value    DS    FL4     Area depth
@K_ISPF_SPCDYNRO_Value    DS    FL4     Starting Row
@K_ISPF_SPCDYNCO_Value    DS    FL4     Starting Column
                          ORG   @K_ISPF_VCOPY_Ptrs
@K_ISPF_VCOPY_Cursor_Ptrs DS    0F      Pointers to vars from VCOPY
@K_ISPF_ZSCREENW_Ptr      DS    AL4      A(ZSCREENW)
@K_ISPF_ZSCREENC_Ptr      DS    AL4      A(ZSCREENC)
                          ORG ,

@K_ISPF_VCOPY_Lens        DS    0F      Length of var from VCOPY
@K_ISPF_VCOPY_Var_Len     DS    AL4     Len of VCOPYed variable
                          ORG   @K_ISPF_VCOPY_Lens
@K_ISPF_VCOPY_Scroll_Lens DS    0F      Lengths of vars from VCOPY
@K_ISPF_VCOPY_ZVERB_Len   DS    FL4      ZVERB Length
@K_ISPF_VCOPY_ZSCROLLN_Len DS   FL4      ZSCROLLN Length
@K_ISPF_VCOPY_ZSCROLLA_Len DS   FL4      ZSCROLLA Length
                          ORG   @K_ISPF_VCOPY_Lens
@K_ISPF_VCOPY_Cursor_Lens DS    0F      Lengths of vars from VCOPY
@K_ISPF_ZSCREENW_Len      DS    FL4      ZSCREENW Length
@K_ISPF_ZSCREENC_Len      DS    FL4      ZSCREENC Length
                          ORG   ,

@K_Parms                  DS    0F      Parms for called rtns
@K_Parms_Std              DS    3AL4     Standard 3 parms
@K_Parms_Extra            EQU   *        Extra parms
@K_Parms_V00010           DS    AL4        for V00010
                          ORG   ,

                          DS    0D
@K_Dynam_Length           EQU   *-@K_Dynam

&PGMNAME CSECT
         DROP  ,                        Free base registers
         POP   USING
         TITLE 'L00010: Identify line command under ISPF'

         PUSH  USING

L00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : L00010                                                 *
*                                                                     *
*  Abstract  : Process primary command entered in ISPF (S)pace or     *
*              (B)rowse mode.                                         *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0: Command processed OK                           *
*                   4: Display mode change requested                  *
*                   8: Unrecognized command                           *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2002/02/12 SDDA030 - V2.16                             *
*                                   New                               *
*              2003/10/07 SDDA030 - V2.21                             *
*                                   Added line commands:              *
*                                    - ISPF(x) to change display mode *
*                                    - OUTPUT to write table to a file*
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,L_Literals           Point to our literals
         USING (L_Literals,L_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@L_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@L_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @L_Dynam,R13             Assign a base
         L     R15,@L_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@L_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@L_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    Get ZCMD                                                       *
*-------------------------------------------------------------------*
         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@L_ISPF_Parms        Save it
         LA    R15,=CL8'ZCMD'           Variable we want
         ST    R15,@L_ISPF_Parms+4      Save it
         LA    R15,@L_ZCMD_Length       A(Length Address)
         ST    R15,@L_ISPF_Parms+8      Save it
         LA    R15,@L_ZCMD_Ptr          A(Variable name)
         ST    R15,@L_ISPF_Parms+12     Save it
         OI    @L_ISPF_Parms+12,X'80'   Flag last parm
         LA    R1,@L_ISPF_Parms         A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go get the variable

         LTR   R15,R15                  Did we get it?
         JNZ   L00140                   No, pretend all is OK

*-------------------------------------------------------------------*
*    See if we recognize the command. First, uppercase it ...       *
*-------------------------------------------------------------------*
         ICM   R14,B'1111',@L_ZCMD_Length Get len of ZCMD
         JZ    L00140                   Nothing, all done
         ICM   R15,B'1111',@L_ZCMD_Ptr  OK, point to ZCMD
         JZ    L00140                   Nothing (huh?), exit
         MVI   @L_Prim_Cmd,C' '         Clear
         MVC   @L_Prim_Cmd+1(L'@L_Prim_Cmd-1),@L_Prim_Cmd command area
         AHI   R14,-1                   EX length
         EX    R14,L_OC                 Uppercase it
         AHI   R14,1                    Restore real length

*-------------------------------------------------------------------*
*    ... and search our table for the command                       *
*-------------------------------------------------------------------*
         LR    R0,R14                   Set up length register
         LR    R1,R15                   and pointer register

         LA    R15,0                    Clear length register
         LA    R14,L_Command_Table      A(Commands we know about)
L00020   DS    0H
         ICM   R2,B'1111',0(R14)        A(Processing routine)
         JZ    L00160                   End-of-table, unknown command
         IC    R15,4(0,R14)             Get cmd len from table
         CR    R0,R15                   Could it be ours?
         JNH   L00030                   No, try next
         EX    R15,L_CLC                Could be, is it?
         JNE   L00030                   No, try next table entry
         LA    R2,1(0,R15)              Maybe, get real length of cmd
         CR    R0,R2                    Is that all there is?
         JNH   L00040                   Yes, found our entry
         AR    R2,R1                    No, point to last char of cmd
         CLI   0(R2),C' '               Followed by a space?
         JE    L00040                   Yes, this is our command
L00030   DS    0H
         LA    R14,6(R14,R15)           A(Next entry)
         J     L00020                   and check it out

L00040   DS    0H
*-------------------------------------------------------------------*
*    We have found our command entry, so now we set up the          *
*   registers for the processing routine:                           *
*        R1 = A(1st non-blank after the command)                    *
*        R0 = length of data remaining in ZCMD                      *
*-------------------------------------------------------------------*
         AR    R0,R1                    A(char past end of ZCMD)
         AR    R1,R15                   A(last char of command)
L00050   DS    0H
         AHI   R1,1                     A(next char)
         CR    R1,R0                    Gone too far?
         JNL   L00060                   Yep, skip
         CLI   0(R1),C' '               No, a space?
         JE    L00050                   Yes, keep going
L00060   DS    0H
         SR    R0,R1                    Length of data remaining

*-------------------------------------------------------------------*
*    Go process our command                                         *
*-------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@L_Rtn_Parms         Save it
         L     R15,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@L_Rtn_Parms+4       Save it
         L     R15,@L_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@L_Rtn_Parms+8       Save it
         ST    R1,@L_Rtn_Parms+12       Save A(Command)
         ST    R0,@L_Rtn_Parms+16       Save Len of Command

         LA    R1,@L_Rtn_Parms          A(Parm list)
         L     R15,0(0,R14)             A(processing routine)
         BASR  R14,R15                  go do it

         J     L00140                   and skip

L00140   DS    0H
         LA    R15,0                    Clear return code
         J     L90010                   and exit

L00160   DS    0H
         LA    R15,8                    Unrecognized command
         J     L90010                   and exit


L90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@L_Dynam              A(Local storage)
         L     R2,@L_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore regs other than R15
         BSM   0,R14                    and return

L_Literals  DS  0H

L_Command_Table EQU  *
L_Cmd_Proc  DC  AL4(LA0010)             Command processor
L_Cmd_Len   DC  AL1(3)                  Command length (EX len)
L_Cmd       DC  C'SORT'                 Command Name

            DC  AL4(LB0010A)
            DC  AL1(6)
            DC  C'ISPF(S)'

            DC  AL4(LB0010B)
            DC  AL1(6)
            DC  C'ISPF(E)'

            DC  AL4(LB0010C)
            DC  AL1(6)
            DC  C'ISPF(B)'

            DC  AL4(LB0010D)
            DC  AL1(6)
            DC  C'ISPF(N)'

            DC  AL4(LC0010)
            DC  AL1(5)
            DC  C'OUTPUT'

            DC  AL4(0)                  End-of-Table marker

L_OC     OC    @L_Prim_Cmd(0),0(R15)    Uppercase command
L_CLC    CLC   @L_Prim_Cmd(0),5(R14)    Check for command in table

         LTORG

L_Literals_End  DS  0H


@L_Dynam                  DSECT
                          DS    18F    O/S style save area
@L_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@L_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)
@L_Prim_Cmd               DS    CL80   Copy of line command
@L_ZCMD_Ptr               DS    AL4    A(ZCMD)
@L_ZCMD_Length            DS    FL4    Length of ZCMD
@L_ISPF_Parms             DS    5AL4   ISPF Parm List
@L_Rtn_Parms              DS    5AL4   Cmd processing routine parms
                          DS    0D
@L_Dynam_Length           EQU   *-@L_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING

         TITLE 'LA0010: Process SORT Primary Command'

         PUSH  USING

LA0010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : LA0010                                                 *
*                                                                     *
*  Abstract  : Process SORT primary command                           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(operands of the SORT command)              *
*                        Length of operands                           *
*  Outputs   : R15: 0                                                 *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2002/02/12 SDDA030 - V2.16                             *
*                                   New                               *
*              2003/10/07 SDDA030 - V2.21                             *
*                                   New, originally in L0010          *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,LA_Literals          Point to our literals
         USING (LA_Literals,LA_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@LA_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@LA_Dynam_Length       Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @LA_Dynam,R13            Assign a base
         L     R15,@LA_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@LA_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@LA_24Bit_Stack_Ptr_Ptr Save it

*---------------------------------------------------------------------*
*   Initialize our flags, and get the operand length and addr         *
*---------------------------------------------------------------------*
         NI    @LA_Cmd_Prompted,X'FF'-L'@LA_Cmd_Prompted

         L     R0,16(0,R1)              Get operand length
         L     R1,12(0,R1)              Get A(Operands)

LA0020   DS    0H
*---------------------------------------------------------------------*
*   Initialize our sort fields ...                                    *
*---------------------------------------------------------------------*
         MVC   @LA_I00010_Sort_Field,=CL8' ' Clear sort field
         MVI   @LA_I00010_Sort_Dir,C' ' and direction

*---------------------------------------------------------------------*
*   Check to see what we have as operands                             *
*---------------------------------------------------------------------*
         LTR   R14,R0                   Get the length
         JZ    LA0100                   No operands, skip
         LR    R15,R1                   OK, point to it (them)

LA0050   DS    0H
         CLI   0(R15),C' '              End of field?
         JE    LA0060                   Yes, skip
         AHI   R15,1                    Bump input pointer
         BRCT  R14,LA0050               and check out next
LA0060   DS    0H
         LR    R3,R15                   A(Byte past end-of-field)
         SR    R3,R1                    Length of field
         JNP   LA0100                   Nothing, skip
         C     R3,=AL4(L'@LA_I00010_Sort_Field) Too long?
         JNH   LA0070                   No, skip
         L     R3,=AL4(L'@LA_I00010_Sort_Field) Yes, use max length
LA0070   DS    0H
         AHI   R3,-1                    EX length
         EX    R3,LA_OC                 Save it

*-------------------------------------------------------------------*
*    Extract the sort direction                                     *
*-------------------------------------------------------------------*
         LTR   R14,R14                  Anything left?
         JZ    LA0100                   No, all done
LA0080   DS    0H
         CLI   0(R15),C' '              Leading space?
         JNE   LA0090                   No, skip
         AHI   R15,1                    Yes, bump pointer
         BRCT  R14,LA0080               and check next
         J     LA0100                   All done, skip
LA0090   DS    0H
         OC    @LA_I00010_Sort_Dir,0(R15) Save Sort direction

LA0100   DS    0H
*-------------------------------------------------------------------*
*    If we don't have a sort field, and we have prompted, just      *
*   exit without sorting                                            *
*-------------------------------------------------------------------*
         CLI   @LA_I00010_Sort_Field,C' ' Any sort field?
         JNE   LA0110                   Yes, go sort
         TM    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted Did we prompt?
         JZ    LA0120                   No, go prompt now
         J     LA9010                   Yes, exit

LA0110   DS    0H
*-------------------------------------------------------------------*
*    Invoke the sort routine                                        *
*-------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@LA_Parms_Std        Save it
         L     R15,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@LA_Parms_Std+4      Save it
         L     R15,@LA_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@LA_Parms_Std+8      Save it
         LA    R15,@LA_I00010_Sort_Field A(Offset)
         ST    R15,@LA_Parms_I00010     Save it
         LA    R15,@LA_I00010_Sort_Dir  A(Sort Direction)
         ST    R15,@LA_Parms_I00010+4   Save it

         LA    R1,@LA_Parms             A(Parms)
         BRAS  R14,I00010               Go sort

         LTR   R15,R15                  Did it work?
         JZ    LA9010                   Yes, exit

LA0120   DS    0H
*-------------------------------------------------------------------*
*    SORT was entered with no operands, or the sort failed (because *
*   of an invalid sort field) - if we can, pop up a panel prompting *
*   for the sort field and direction.                               *
*-------------------------------------------------------------------*
         CLI   LA_Prompt_Panel,C' '     Any prompt panel?
         JE    LA0130                   No, just get out

         LA    R15,=CL8'PQUERY'         ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         LA    R15,LA_Prompt_Panel      A(Panel name)
         ST    R15,@LA_ISPF_Parms+4     Save it
         LA    R15,LA_Prompt_Panel      A(Dummy area name)
         ST    R15,@LA_ISPF_Parms+8     Save it
         LA    R15,@LA_ISPF_Parms+16    A(Return area)
         ST    R15,@LA_ISPF_Parms+12    Save it
         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm
         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go check out panel
         CHI   R15,8                    Was the panel found?
         JH    LA0130                   No, just exit

         LA    R15,=CL8'ADDPOP'         ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         OI    @LA_ISPF_Parms,X'80'     Flag last parm
         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Set pop-up environment

         LA    R15,=CL8'DISPLAY'        ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         LA    R15,LA_Prompt_Panel      A(Panel name)
         ST    R15,@LA_ISPF_Parms+4     Save it
         OI    @LA_ISPF_Parms+4,X'80'   Flag last parm
         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Display pop-up prompt
         LR    R3,R15                   Save our return code

         LA    R15,=CL8'REMPOP'         ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         OI    @LA_ISPF_Parms,X'80'     Flag last parm
         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Reset pop-up environment

         CHI   R3,8                     How did we do?
         JH    LA0130                   Not good, skip
         JE    LA0140                   END, RETURN, etc.

         OI    @LA_Cmd_Prompted,L'@LA_Cmd_Prompted We have prompted

         LA    R15,=CL8'VCOPY'          ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         LA    R15,=CL8'ZCMD'           Variable we want
         ST    R15,@LA_ISPF_Parms+4     Save it
         LA    R15,@LA_ISPF_VCOPY_Lens  A(Length Address)
         ST    R15,@LA_ISPF_Parms+8     Save it
         LA    R15,@LA_ISPF_VCOPY_Ptrs  A(Variable)
         ST    R15,@LA_ISPF_Parms+12    Save it
         OI    @LA_ISPF_Parms+12,X'80'  Flag last parm
         LA    R1,@LA_ISPF_Parms        A(ISPF Parms)
         L     R15,@_ISPLINK            A(ISPF routine)
         BASR  R14,R15                  Go get the variable

         LTR   R15,R15                  Did we get it?
         JNZ   LA0130                   No, exit

*-------------------------------------------------------------------*
*    The popup seemed to work; if the 1st word is SORT, point past  *
*   it                                                              *
*-------------------------------------------------------------------*
         ICM   R0,B'1111',@LA_ISPF_VCOPY_Lens Get ZCMD length
         JZ    LA0130                   Nothing, skip
         ICM   R1,B'1111',@LA_ISPF_VCOPY_Ptrs A(ZCMD)
         JZ    LA0130                   Nothing, skip

         CHI   R0,5                     Room enough for 'SORT '?
         JNH   LA0128                   No, skip
         CLC   =C'SORT ',0(R1)          Yes, is it?
         JNE   LA0128                   No, skip
         AR    R0,R1                    Yes, point past end of string
         AHI   R1,5                     and point past 'SORT '
LA0122   DS    0H
         CLI   0(R1),C' '               Start of operand?
         JNE   LA0124                   Yes, skip
         AHI   R1,1                     No, bump pointer
         CR    R1,R0                    Any string left?
         JL    LA0122                   Yes, keep checking
LA0124   DS    0H
         SR    R0,R1                    Set up new length
LA0128   DS    0H

         J     LA0020                   and start again

LA0130   DS    0H
*-------------------------------------------------------------------*
*    The sort failed, and we are not prompting, so set the ISPF     *
*   messages                                                        *
*-------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@LA_ISPF_Parms+12 Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@LA_ISPF_Parms+4     Save it
         LA    R15,LA_Sort_Fail_SMsg    Short message
         ST    R15,@LA_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LA_Sort_Fail_SMsg) Length of message
         ST    R15,@LA_ISPF_Parms+16 Save it
         OI    @LA_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LA_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@LA_ISPF_Parms+4     Save it
         LA    R15,LA_Sort_Fail_LMsg    Long message
         ST    R15,@LA_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LA_Sort_Fail_LMsg) Length of message
         ST    R15,@LA_ISPF_Parms+16 Save it
         OI    @LA_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LA_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@LA_ISPF_Parms       Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@LA_ISPF_Parms+4     Save it
         OI    @LA_ISPF_Parms+4,X'80' Mark end of list
         LA    R1,@LA_ISPF_Parms        Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         J     LA0150                   and exit with error

LA0140   DS    0H
         LA    R15,0                    Clear return code
         J     LA9010                   and exit

LA0150   DS    0H
         LA    R15,4                    No Sort done
         J     LA9010                   and exit

LA0160   DS    0H
         LA    R15,8                    ZCMD other than SORT
         J     LA9010                   and exit


LA9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@LA_Dynam             A(Local storage)
         L     R2,@LA_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore regs other than R15
         BSM   0,R14                    and return

LA_Literals DS  0H

LA_OC    OC    @LA_I00010_Sort_Field(0),0(R1) Move Sort Field Name

LA_Sort_Fail_SMsg     DC  C'Sort failed'
LA_Sort_Fail_LMsg     DC  C'Invalid SORT field'

LA_Prompt_Panel DC   CL8'&SORT_Prompt_Popup_Panel'

         LTORG

LA_Literals_End DS  0H


@LA_Dynam                 DSECT
                          DS    18F     O/S style save area
@LA_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)
@LA_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)
@LA_DBLWD                 DS    D       Work area
                          DS    X       Flag Byte
@LA_Cmd_Prompted          EQU   *-1,X'80' 1... .... SORT from prompt
                          DS    0F      Alignment
@LA_Macros                EQU   *
@LA_ISPF_Parms            DS    5AL4    ISPF Parm List
@LA_ISPF_VCOPY_Lens       DS    AL4     ZCMD Length pointer
@LA_ISPF_VCOPY_Ptrs       DS    AL4     ZCMD Data Ptr
@LA_ZCMD_Ptr              DS    AL4     A(ZCMD)
@LA_ZCMD_Length           DS    FL4     Length of ZCMD
                          ORG   @LA_Macros
@LA_I00010_Sort_Field     DS    CL8     Sort Field Name/Offset
@LA_I00010_Sort_Dir       DS    C       Sort Direction
                          ORG   ,

@LA_Parms                 DS    0F      Parms for called rtns
@LA_Parms_Std             DS    3AL4     Standard 3 parms
@LA_Parms_Extra           EQU   *         Extra parms
@LA_Parms_I00010          DS    2AL4         for I00010
                          ORG   ,
                          DS    0D
@LA_Dynam_Length          EQU   *-@LA_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING

         TITLE 'LB0010: Process ISPF(x) line command'

         PUSH  USING

LB0010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : LB0010                                                 *
*                                                                     *
*  Abstract  : Change display type to ISPF(x) - SPACE display         *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(operands of the command)                   *
*                        Length of operands                           *
*  Outputs   : R15: 4                                                 *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2003/10/07 SDDA030 - V2.16                             *
*                                   New                               *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

LB0010A  DS    0H
         STM   R14,R12,12(R13)          Save callers registers
         LA    R4,0                     R4=0: ISPF(S)
         J     LB0020
LB0010B  DS    0H
         STM   R14,R12,12(R13)          Save callers registers
         LHI   R4,4                     R4=4: ISPF(E)
         J     LB0020
LB0010C  DS    0H
         STM   R14,R12,12(R13)          Save callers registers
         LHI   R4,8                     R4=8: ISPF(B)
         J     LB0020
LB0010D  DS    0H
         STM   R14,R12,12(R13)          Save callers registers
         LHI   R4,12                    R4=12: ISPF(N)
         J     LB0020
LB0020   DS    0H
         LARL  R11,LB_Literals          Point to our literals
         USING (LB_Literals,LB_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@LB_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@LB_Dynam_Length       Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @LB_Dynam,R13            Assign a base
         L     R15,@LB_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@LB_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@LB_24Bit_Stack_Ptr_Ptr Save it

*---------------------------------------------------------------------*
*   Go process the command, based on the contents of R4               *
*---------------------------------------------------------------------*

LB0030   DS    0H
*---------------------------------------------------------------------*
*   ISPF(S) requested - if not already active, reset flags            *
*---------------------------------------------------------------------*
         LTR   R4,R4                    R4 = 0 (ISPF(S)?)
         JNZ   LB0040                   No, skip
         TM    @_ISPF_SPACE,L'@_ISPF_SPACE Already active?
         JO    LB8010                   Yes, error
         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF    No, reset
         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF
         OI    @_ISPF_SPACE,L'@_ISPF_SPACE           flags
         J     LB0070                   and skip

LB0040   DS    0H
*---------------------------------------------------------------------*
*   ISPF(E) requested - if not already active, reset flags            *
*---------------------------------------------------------------------*
         CHI   R4,4                     R4 = 4 (ISPF(E)?)
         JNE   LB0050                   No, skip
         TM    @_ISPF_EDIF,L'@_ISPF_EDIF Already in EDIF?
         JO    LB8010                   Yes, error
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset
         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF     ISPF
         OI    @_ISPF_EDIF,L'@_ISPF_EDIF            flags
         J     LB0070                   and skip

LB0050   DS    0H
*---------------------------------------------------------------------*
*   ISPF(B) requested - if not already active, reset flags            *
*---------------------------------------------------------------------*
         CHI   R4,8                     R4 = 8 (ISPF(B)?)
         JNE   LB0060                   No, skip
         TM    @_ISPF_BRIF,L'@_ISPF_BRIF Already in BRIF?
         JO    LB8010                   Yes, error
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE  No, reset
         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF     ISPF
         OI    @_ISPF_BRIF,L'@_ISPF_BRIF            flags
         J     LB0070                   and skip

LB0060   DS    0H
*---------------------------------------------------------------------*
*   ISPF(N) requested - reset all the ISPF flags                      *
*---------------------------------------------------------------------*
         CHI   R4,12                    R4 = 12 (ISPF(N)?)
         JNE   LB0080                   No, ignore it
         NI    @_ISPF_SPACE,X'FF'-L'@_ISPF_SPACE
         NI    @_ISPF_EDIF,X'FF'-L'@_ISPF_EDIF
         NI    @_ISPF_BRIF,X'FF'-L'@_ISPF_BRIF
         NI    @_ISPF_Explicit,X'FF'-L'@_ISPF_Explicit
         J     LB0070                   and skip

LB0070   DS    0H
*---------------------------------------------------------------------*
*   Turn on the re-display requested flag ...                         *
*---------------------------------------------------------------------*
         OI    @_ReDisplay,L'@_ReDisplay Say we need a redisplay

LB0080   DS    0H
*---------------------------------------------------------------------*
*   ... and exit                                                      *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     LB9010                   and exit

LB8010   DS    0H
*-------------------------------------------------------------------*
*    The requested display mode is already active - define ISPF     *
*   messages, and exit                                              *
*-------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@LB_ISPF_Parms       Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@LB_ISPF_Parms+12 Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@LB_ISPF_Parms+4     Save it
         LA    R15,LB_Curr_Act_SMsg     Short message
         ST    R15,@LB_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LB_Curr_Act_SMsg) Length of message
         ST    R15,@LB_ISPF_Parms+16 Save it
         OI    @LB_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LB_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@LB_ISPF_Parms+4     Save it
         LA    R15,LB_Curr_Act_LMsg     Long message
         ST    R15,@LB_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LB_Curr_Act_LMsg) Length of message
         ST    R15,@LB_ISPF_Parms+16 Save it
         OI    @LB_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LB_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@LB_ISPF_Parms       Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@LB_ISPF_Parms+4     Save it
         OI    @LB_ISPF_Parms+4,X'80' Mark end of list
         LA    R1,@LB_ISPF_Parms        Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         LA    R15,0                    Clear return code
         J     LB9010                   and exit

LB9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@LB_Dynam             A(Local storage)
         L     R2,@LB_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore regs other than R15
         BSM   0,R14                    and return

LB_Literals DS  0H

LB_Curr_Act_SMsg     DC  C'Currently active'
LB_Curr_Act_LMsg     DC  C'Requested display mode already active'

         LTORG

LB_Literals_End DS  0H


@LB_Dynam                 DSECT
                          DS    18F     O/S style save area
@LB_31Bit_Stack_Ptr_Ptr   DS    AL4     A(31-bit Stack Ptr)
@LB_24Bit_Stack_Ptr_Ptr   DS    AL4     A(24-bit Stack Ptr)
@LB_ISPF_Parms            DS    5AL4    ISPF Parm List
                          DS    0D
@LB_Dynam_Length          EQU   *-@LB_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING

         TITLE 'LC0010: Process OUTPUT Primary Command'

         PUSH  USING

LC0010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : LC0010                                                 *
*                                                                     *
*  Abstract  : Process OUTPUT primary command                         *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(line command operands)                     *
*                        Length of operands                           *
*  Outputs   : R15: 0                                                 *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2003/10/07 SDDA030 - V2.21                             *
*                                   New                               *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*                                                                     *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,LC_Literals          Point to our literals
         USING (LC_Literals,LC_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@LC_Dynam_Length,     this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@LC_Dynam_Length       Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @LC_Dynam,R13            Assign a base
         L     R15,@LC_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@LC_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@LC_24Bit_Stack_Ptr_Ptr Save it


*-------------------------------------------------------------------*
*    This option is not yet supported                               *
*-------------------------------------------------------------------*
         LA    R15,=CL8'VDEFINE'        ISPF Function
         ST    R15,@LC_ISPF_Parms       Save it
         LA    R15,=CL8'CHAR'           Character variables
         ST    R15,@LC_ISPF_Parms+12 Save it

         LA    R15,=CL8'ZEDSMSG'        Variable name
         ST    R15,@LC_ISPF_Parms+4     Save it
         LA    R15,LC_Unsupport_SMsg    Short message
         ST    R15,@LC_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LC_Unsupport_SMsg) Length of message
         ST    R15,@LC_ISPF_Parms+16 Save it
         OI    @LC_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LC_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'ZEDLMSG'        Variable name
         ST    R15,@LC_ISPF_Parms+4     Save it
         LA    R15,LC_Unsupport_LMsg    Long message
         ST    R15,@LC_ISPF_Parms+8     Save it
         LA    R15,=AL4(L'LC_Unsupport_LMsg) Length of message
         ST    R15,@LC_ISPF_Parms+16 Save it
         OI    @LC_ISPF_Parms+16,X'80' Flag end of list
         LA    R1,@LC_ISPF_Parms        A(Parmlist)
         L     R15,@_ISPLINK            A(ISPF Interface)
         BASR  R14,R15                  Go do it

         LA    R15,=CL8'SETMSG'         Yes, ISPF Function
         ST    R15,@LC_ISPF_Parms       Save it
         LA    R15,=CL8'ISRZ001'        A(Message ID)
         ST    R15,@LC_ISPF_Parms+4     Save it
         OI    @LC_ISPF_Parms+4,X'80' Mark end of list
         LA    R1,@LC_ISPF_Parms        Point to ISPF parms
         L     R15,@_ISPLINK            A(Interface routine)
         BASR  R14,R15                  Go do it

         LA    R15,0                    Clear return code
         J     LC9010                   and exit


LC9010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@LC_Dynam             A(Local storage)
         L     R2,@LC_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore regs other than R15
         BSM   0,R14                    and return

LC_Literals DS  0H

LC_Unsupport_SMsg     DC   C'Unsupported'
LC_Unsupport_LMsg     DC   C'This command is not yet implemented'


         LTORG

LC_Literals_End DS  0H


@LC_Dynam                 DSECT
                          DS    18F    O/S style save area
@LC_31Bit_Stack_Ptr_Ptr   DS    AL4    A(31-bit Stack Ptr)
@LC_24Bit_Stack_Ptr_Ptr   DS    AL4    A(24-bit Stack Ptr)
                          DS    0F     Alignment
@LC_ISPF_Parms            DS    5AL4   ISPF Parm List
@LC_ISPF_VCOPY_Lens       DS    FL4    ZCMD Length
@LC_ISPF_VCOPY_Ptrs       DS    AL4    ZCMD Address
@LC_ZCMD_Ptr              DS    AL4    A(ZCMD)
@LC_ZCMD_Length           DS    FL4    Length of ZCMD
                          DS    0D
@LC_Dynam_Length          EQU   *-@LC_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'S00010: WAIT for subtasks to complete'

         PUSH  USING

S00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : S00010                                                 *
*                                                                     *
*  Abstract  : WAIT for subtasks to complete, DETACH them, and free   *
*              SubTask_Area                                           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0:                                                *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    2003/10/07 SDDA030 - V2.21                             *
*                                   New.                              *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,S_Literals           Point to our literals
         USING (S_Literals,S_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@S_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@S_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @S_Dynam,R13             Assign a base
         L     R15,@S_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@S_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@S_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    If there is a Subtask_Area ...                                 *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@_SubTask_Area_Ptr Get A(SubTask Area)
         JZ    S00100                  None, exit quick smart
         ICM   R0,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R1)
         JZ    S00100                  None, go free it

*-------------------------------------------------------------------*
*    ... get an area for our ECB list                               *
*-------------------------------------------------------------------*
         MHI   R0,4                     (# ents * len of ECB ptr)

         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit stack Ptr)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=(0),                  this long                     +
               STACK=(R2)                using this stack

         ST    R1,@S_ECBLIST_Ptr       Save it

S00020   DS    0H
*-------------------------------------------------------------------*
*    Build our ECBLIST, containing a pointer to each ECB that has   *
*   not yet been POSTed. If the ECB has been POSTed, DETACH the TCB,*
*   unless we have already done so.                                 *
*-------------------------------------------------------------------*
         ICM   R15,B'1111',@_SubTask_Area_Ptr A(SubTask Area)
         JZ    S00100                  None, all done
         ICM   R14,B'1111',SubTask_Area_Hdr_Count-SubTask_Area_Hdr(R15)
         JZ    S00100                  None, exit
         AHI   R15,SubTask_Area_Hdr_Length A(1st SubTask Entry)
         ICM   R1,B'1111',@S_ECBLIST_Ptr A(Our ECBLIST)
         JZ    S00100                  None, all done
S00030   DS    0H
         TM    SubTask_Area_Ent_ECB-SubTask_Area_Ent(R15),X'40' POSTed?
         JO    S00040                  Yes, go DETACH TCB
         ST    R15,0(0,R1)             No, Add to ECBLIST
         AHI   R1,4                    Bump ECBLIST Ptr
         J     S00050                  and skip
S00040   DS    0H
         ICM   R0,B'1111',SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)
         JZ    S00050                  No TCB, skip
         STM   R14,R1,@S_RSave         Save our registers
         LA    R1,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)
         DETACH (1),                    Yes, DETACH it                 +
               STAE=NO                   without invoking ESTAE Rtn
         LM    R14,R1,@S_RSave         Restore our registers
         LA    R0,0                    Clear TCB pointer
         ST    R0,SubTask_Area_Ent_TCB-SubTask_Area_Ent(R15)
S00050   DS    0H
         AHI   R15,SubTask_Area_Ent_Length A(Stuff for next TCB)
         BRCT  R14,S00030              and check it out

*-------------------------------------------------------------------*
*    If there are any ECBs not yet POSTed ...                       *
*-------------------------------------------------------------------*
         L     R0,@S_ECBLIST_Ptr       A(ECBLIST)
         CR    R0,R1                   Anything in it?
         JE    S00100                  No, we're all done

*-------------------------------------------------------------------*
*    ... WAIT for them to complete ...                              *
*-------------------------------------------------------------------*
         AHI   R1,-4                   Yes, back up to A(last ECB)
         OI    0(R1),X'80'             Flag it as last
         SLR   R1,R0                   Calculate nbr
         SRL   R1,2                     of ECBS in
         AHI   R1,1                     list
         LR    R0,R1                   In proper register
         L     R1,@S_ECBLIST_Ptr       A(ECB list)
         WAIT  (R0),ECBLIST=(R1)       Wait for our subtasks

*-------------------------------------------------------------------*
*    ... and do it all again                                        *
*-------------------------------------------------------------------*
         J     S00020                  and do it all again

S00100   DS    0H
*-------------------------------------------------------------------*
*    We're all done here, so free up the ECBLIST, if required ...   *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@S_ECBLIST_Ptr A(ECBLIST)
         JZ    S00110                  None, skip

         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK POP,                  Free the ECBLIST               +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

S00110   DS    0H
*-------------------------------------------------------------------*
*    ... and the SubTask_Area, if required ...                      *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@_SubTask_Area_Ptr A(SubTask Area)
         JZ    S00120                  Nothing, skip
         L     R0,SubTask_Area_Hdr_Len-SubTask_Area_Hdr(0,R1) Length

         BASR  R2,0
         USING (*,S00120_End-1),R2
         STORAGE RELEASE,               Free the SubTask Area          +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
S00120_End DS  0H
         DROP  R2

         LA    R0,0                     Clear work reg
         ST    R0,@_SubTask_Area_Ptr    No more SubTask Area

S00120   DS    0H
*-------------------------------------------------------------------*
*    ... and exit.                                                  *
*-------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     S90010                   and exit

S90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@S_Dynam              A(Local storage)
         L     R2,@S_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore callers regs
         BSM   0,R14                    and return

S_Literals  DS  0H

         LTORG

S_Literals_End  DS  0H


@S_Dynam                  DSECT
@S_SaveArea               DS    18F    O/S style save area
@S_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@S_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)

@S_ECBLIST_Ptr            DS    AL4    A(ECBLIST)
@S_RSave                  DS    4FL4   Temp reg save area

                          DS    0D
@S_Dynam_Length           EQU   *-@S_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'T00010: Return SMS Storgrp'

         PUSH  USING

T00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : T00010                                                 *
*                                                                     *
*  Abstract  : Return pointers to the STORGRP name and SMS Status     *
*              for a volser                                           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(Volser)                                    *
*                        A(VLD Anchor)                                *
*  Outputs   : R15: 0: STORGRP found                                  *
*                   4: STORGRP not found (??)                         *
*                   8: SMS not active                                 *
*              R0    : A(SMS Status)                                  *
*              R1    : A(STORGRP Len, Name)                           *
*                                                                     *
*  Notes     : To try to reduce the number of times we have to call   *
*              SMS, whenever we ask SMS about the StorGrp for a       *
*              volume, we also ask for all the volsers in that        *
*              StorGrp. We chain these VLDs (Volume Definitions), and *
*              search them for the volser before asking SMS for the   *
*              StorGrp.                                               *
*              If A(Volser) is 0, all in-storage VLDs, chained off    *
*              VLD Anchor, are freed.                                 *
*              The IEFSSREQs to SMS are modelled on those found in    *
*              SHOWMVS (Thanks Gilbert/Roland).                       *
*              We clobber the VLDPID field and the next 2 bytes with: *
*               0-3 A(Next VLD)                                       *
*               4-7 Length of VLD                                     *
*               8-9 SMS System number                                 *
*                                                                     *
*  History:    2002/03/11 SDDA030 - V2.17                             *
*                                 - New                               *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Corrected bug getting correct SMS *
*                                   status (we make an additional     *
*                                   call to SMS to get the system-ids)*
*              2004/10/15 SDDA030 - V2.22                             *
*                                 - Corrected bug where we overlayed  *
*                                   the SMS System number with the    *
*                                   length of the VLD.                *
*                                 - Resequenced labels                *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,T_Literals           Point to our literals
         USING (T_Literals,T_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@T_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@T_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @T_Dynam,R13             Assign a base
         L     R15,@T_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@T_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@T_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    If we have a volser ...                                        *
*-------------------------------------------------------------------*
         ICM   R3,B'1111',12(R1)       Get A(Volser)
         JZ    T00130                  None, free VLDs

*-------------------------------------------------------------------*
*    ... check the existing VLDs for the volser                     *
*-------------------------------------------------------------------*
         L     R1,16(0,R1)             A(VLD Chain Anchor)
         AHI   R1,-(VLDPID-VLD)        Pretend we are a VLD Ptr
         NI    @T_Volser_in_VLD,X'FF'-L'@T_Volser_in_VLD Off flag
         LHI   R15,-1                  We have no
         STH   R15,@T_SMS_SYSNum        no SMS System nbr
         J     T00050                  and run chain
T00020   DS    0H
         ICM   R14,B'1111',VLDPCNT-VLD(R1) Number vols
         JNP   T00050                  None, try next VLD
         LA    R15,VLDEF-VLD(0,R1)     OK, point to 1st
T00030   DS    0H
         CLC   =HL2'6',VLDVSLEN-VLDEF(R15)  Right length for a volser?
         JNE   T00040                  No, skip this entry
         CLC   VLDVSER-VLDEF(L'VLDVSER,R15),0(R3)
         JE    T00110                  Found our volser, skip
T00040   DS    0H
         A     R15,VLDPLEN-VLD(0,R1)   A(Next VLD)
         BRCT  R14,T00030              and check it out
         TM    @T_Volser_in_VLD,L'@T_Volser_in_VLD Should it be here?
         JNO   T00050                  Not necessarily, OK
         DC    H'0'                    It should be, ABEND
T00050   DS    0H
         ICM   R15,B'1111',VLDPID-VLD(R1) A(Next VLD)
         JZ    T00060                  None, skip
         LR    R1,R15                  Load up proper register
         MVC   @T_SMS_SYSNum,VLDPID+8-VLD(R1) Save SMS Sys 'number'
         J     T00020                  and check it out

T00060   DS    0H
*-------------------------------------------------------------------*
*    We couldn't find the volser in our in-storage VLDs (meaning    *
*   that this is the 1st volser we have come across in this         *
*   STORGRP), so go get the STORGRP name from SMS.                  *
*-------------------------------------------------------------------*
         ST    R1,@T_Last_VLD_Ptr      Save A(Last VLD)
         LH    R15,@T_SMS_SYSNum       Get SMS system 'number'
         CHI   R15,-1                  Do we have one?
         JNE   T00100                  Yes, OK

*-------------------------------------------------------------------*
*    This is the 1st VLD we are getting - before we do so, get the  *
*   base configuration data (we have to know our system 'number' to *
*   get the correct SMS status for the volumes).                    *
*-------------------------------------------------------------------*
         L     R15,CVTPTR              Point to CVT
         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table
         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension
         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB
         JZ    T00100                  SMS unavailable, skip

         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB
         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length
         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it
         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function
         L     R15,CVTPTR              Point to CVT
         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table
         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension
         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB
         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it

         LA    R15,@T_SMS_SSSA         SSSA Work Area
         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB

         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA
         LHI   R15,L'@T_SMS_SSSA       Get its length
         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA
         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it
         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version
         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function
         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF

         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1CON Return Config

         LHI   R15,L'@T_SMS_BCD                Len of Config Data
         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it
         LA    R15,@T_SMS_BCD                  A(Config Data)
         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address

         LA    R15,@T_SMS_SSOB         A(SSOB)
         ST    R15,@T_SMS_SSOB_Ptr     Save the address
         LA    R1,@T_SMS_SSOB_Ptr      Point to the address

         IEFSSREQ                      Call SMS

         LTR   R15,R15                 SMS active?
         JNZ   T00100                  No, exit quick smart

         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC
         JNZ   T00100                  Not good, skip SMS stuff

*-------------------------------------------------------------------*
*    We now have an IGDBCD, which is not documented or distributed  *
*   by IBM. From SHOWMVS, we know that this data will contain our   *
*   system ID (assuming, of course, we're SMSd). Rather than define *
*   our own DSECT for this area, we search it for our system-id; if *
*   we find it, we save our system 'number'.                        *
*-------------------------------------------------------------------*
         L     R1,CVTPTR                A(CVT)
         LA    R1,CVTSNAME-CVT(R1)      A(Our System name)
         LA    R15,@T_SMS_BCD           Point to config data
         LHI   R14,L'@T_SMS_BCD-(L'CVTSNAME-1) Len of config data
T00070   DS    0H
         CLC   0(L'CVTSNAME,R1),0(R15)  Found our system?
         JE    T00080                   Yes, skip
         LA    R15,1(0,R15)             Not yet, bump pointer
         BRCT  R14,T00070               and keep checking
         J     T80010                   Not good, exit with error
T00080   DS    0H
         LA    R14,@T_SMS_BCD           A(Start of area)
         LR    R0,R15                   Save A(Our name)
T00090   DS    0H
         AHI   R15,-L'CVTSNAME          Back up to prev system
         CR    R15,R14                  Too far?
         JL    T80010                   Yes, we're lost
         TRT   0(L'CVTSNAME,R15),T_TRT  A valid sysname?
         JZ    T00090                   Yes, check prev

         AHI   R0,-L'CVTSNAME           Offset of last good name
         SR    R0,R15                   offset to our sysname
         SRDL  R0,32                    into correct register
         LA    R15,L'CVTSNAME           Len of 1 system name
         DR    R0,R15                   Calc system 'number'
         STH   R1,@T_SMS_SYSNum         Save it

T00100   DS    0H
         L     R15,CVTPTR              Point to CVT
         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table
         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension
         ICM   R15,B'1111',JESSMSIB-JESPEXT(R15) SMS SSIB
         JZ    T80010                  SMS unavailable, skip

         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB
         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length
         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it
         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function
         L     R15,CVTPTR              Point to CVT
         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table
         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension
         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB
         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it

         LA    R15,@T_SMS_SSSA         SSSA Work Area
         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB

         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA
         LHI   R15,L'@T_SMS_SSSA       Get its length
         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA
         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it
         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version
         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function
         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF

         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1VOL Return VLD
         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct
         MVI   @T_SMS_SSSA+SSSA1NML+1-IEFSSSA,L'UCBVOLI  Volser Len
         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'UCBVOLI),0(R3)

         LHI   R15,L'@T_SMS_VLD                Len of VLD
         ST    R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Save it
         LA    R15,@T_SMS_VLD                  Point VLD
         ST    R15,@T_SMS_SSSA+SSSA1PTR-IEFSSSA Save the address

         LA    R15,@T_SMS_SSOB         A(SSOB)
         ST    R15,@T_SMS_SSOB_Ptr     Save the address
         LA    R1,@T_SMS_SSOB_Ptr      Point to the address

         IEFSSREQ                      Call SMS

         LTR   R15,R15                 SMS active?
         JNZ   T80010                  No, exit quick smart

         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC
         JNZ   T80020                  Not good, skip SMS stuff

*-------------------------------------------------------------------*
*    We have the SMS Storgrp for this volser, so now make another   *
*   request to SMS for all volsers in this STORGRP.                 *
*-------------------------------------------------------------------*
         XC    @T_SMS_SSOB,@T_SMS_SSOB Clear the SSOB
         MVI   @T_SMS_SSOB+SSOBLEN+1-SSOB,SSOBHSIZ Set length
         MVC   @T_SMS_SSOB+SSOBID-SSOB(L'SSOBID),=C'SSOB' ID it
         MVI   @T_SMS_SSOB+SSOBFUNC+1-SSOB,SSOBSSMS Function
         L     R15,CVTPTR              Point to CVT
         L     R15,CVTJESCT-CVTMAP(,R15) JES Communication Table
         L     R15,JESCTEXT-JESCT(,R15)  JESCT Extension
         L     R15,JESSMSIB-JESPEXT(R15) SMS SSIB
         ST    R15,@T_SMS_SSOB+SSOBSSIB-SSOB Save it

         LA    R15,@T_SMS_SSSA         SSSA Work Area
         ST    R15,@T_SMS_SSOB+SSOBINDV-SSOB Update SSOB

         XC    @T_SMS_SSSA,@T_SMS_SSSA Clear SSSA
         LHI   R15,L'@T_SMS_SSSA       Get its length
         STH   R15,@T_SMS_SSSA+SSSALEN-IEFSSSA Update SSSA
         MVC   @T_SMS_SSSA+SSSAID-IEFSSSA(L'SSSAID),=C'SSSA' ID it
         MVI   @T_SMS_SSSA+SSSAVER+1-IEFSSSA,SSOBSSVR Version
         MVI   @T_SMS_SSSA+SSSASFN+1-IEFSSSA,SSSAACTV Sub-Function
         MVI   @T_SMS_SSSA+SSSAIFLG-IEFSSSA,SSSANAUT Non-APF

         MVI   @T_SMS_SSSA+SSSA1TYP-IEFSSSA,SSSA1SGV Return VLDs
         MVI   @T_SMS_SSSA+SSSA1CNT+3-IEFSSSA,1   1 construct
         MVC   @T_SMS_SSSA+SSSA1NML-IEFSSSA(L'SSSA1NML),@T_SMS_VLD+VLDS+
               GLEN-VLD               Len of StorGrp Name
         MVC   @T_SMS_SSSA+SSSA1NAM-IEFSSSA(L'SSSA1NAM),@T_SMS_VLD+VLDS+
               TGRP-VLD               StorGrp Name

         LA    R15,@T_SMS_SSOB         A(SSOB)
         ST    R15,@T_SMS_SSOB_Ptr     Save the address
         LA    R1,@T_SMS_SSOB_Ptr      Point to the address

         IEFSSREQ                      Call SMS

         LTR   R15,R15                 SMS active?
         JNZ   T80010                  No, exit quick smart

         ICM   R15,B'1111',@T_SMS_SSOB+SSOBRETN-SSOB Check RC
         JNZ   T80020                  Not good, skip SMS stuff

*-------------------------------------------------------------------*
*    Chain the new VLD to the others (note that we use the ID field *
*   (VLDPID) for this) ...                                          *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@T_SMS_SSSA+SSSA1PTR-IEFSSSA A(Returned VLD)
         JZ    T80020                  Nothing, not good
         L     R15,@T_Last_VLD_Ptr     OK, A(Last VLD)
         ST    R1,VLDPID-VLD(0,R15)    Chain this one

*-------------------------------------------------------------------*
*    ... set up our fields in the new VLD ...                       *
*-------------------------------------------------------------------*
         LA    R15,0                   Clear forward pointer ...
         ST    R15,VLDPID-VLD(0,R1)     ... in the VLD
         L     R15,@T_SMS_SSSA+SSSA1LEN-IEFSSSA Len of VLD
         ST    R15,VLDPID+4-VLD(R1)    Save length (for FREEMAIN)
         MVC   VLDPID+8-VLD(L'@T_SMS_SYSNum,R1),@T_SMS_SYSNum

*-------------------------------------------------------------------*
*    ... and go check it out.                                       *
*-------------------------------------------------------------------*
         OI    @T_Volser_in_VLD,L'@T_Volser_in_VLD It should be here
         J     T00020                  And check it out

T00110   DS    0H
*-------------------------------------------------------------------*
*    We have found our volser in the VLD, set up our return         *
*   pointers, and exit. At this point, R15 points to the VLDEF      *
*   for our volume.                                                 *
*-------------------------------------------------------------------*
         LA    R0,0                          Assume no SMS Status
         LH    R1,@T_SMS_SYSNum              Get SMS System 'number'
         LTR   R1,R1                         Any?
         JM    T00120                        No, unknown SMS Status
         MHI   R1,L'VLDSSTAT                 r1 = Offset within status
         LR    R0,R15                        A(Volume array)
         A     R0,VLDSYSOF-VLDEF(R15)        A(Status fields)
         AR    R0,R1                         A(Status on our system)

T00120   DS    0H
         LA    R1,VLDSGLEN-VLDEF(R15)        A(Storage group length)

         LA    R15,0                         Clear return code
         J     T90010                        and exit

T00130   DS    0H
*-------------------------------------------------------------------*
*    We have been passed a Volser pointer of 0 - by convention,     *
*   this is a request that we free any VLDs that have been gotten   *
*   for us                                                          *
*-------------------------------------------------------------------*
         ICM   R4,B'1111',16(R1)        VLD Chain Anchor
         JZ    T00150                   Nothing, OK
T00140   DS    0H
         LR    R1,R4                    A(Storage to free)
         L     R0,VLDPID+4-VLD(0,R1)    Length to free
         L     R4,VLDPID-VLD(0,R4)      Rescue forward pointer
         BASR  R2,0
         USING (*,T00140_End-1),R2
         STORAGE RELEASE,               Free the old table             +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
T00140_End DS  0H
         DROP  R2

         LTR   R4,R4                    Is there another one?
         JNZ   T00140                   Yes, go free it

T00150   DS    0H
         LA    R0,0                     No SMS Status
         LA    R1,0                     No STORGRP
         LA    R15,0                    All OK
         J     T90010                   and exit

T80010   DS    0H
*-------------------------------------------------------------------*
*    SMS unavailable, set RC and exit                               *
*-------------------------------------------------------------------*
         LA    R1,0                     No SMS StorGrp
         LA    R0,0                      or status
         LA    R15,8                    SMS not available
         J     T90010                   and exit

T80020   DS    0H
*-------------------------------------------------------------------*
*    SSOBRETN not 0 on return from SSREQ                            *
*-------------------------------------------------------------------*
         LA    R1,0                     No SMS StorGrp
         LA    R0,0                      or status
         LA    R15,4                    STORGRP not found
         J     T90010                   and exit

T90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         L     R14,4(0,R13)             A(HSA)
         STM   R15,R1,16(R14)           Save rc, A(status), A(STORGRP)

         LA    R1,@T_Dynam              A(Local storage)
         L     R2,@T_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack


*-------------------------------------------------------------------*
*    ... and return to caller (note that we updated the callers     *
*   savearea:   +16: Return Code       R15                          *
*               +20: A(SMS Status)     R0                           *
*               +24: A(SMS STORGRP)    R1                           *
*-------------------------------------------------------------------*
         LM    R14,R12,12(R13)          Restore callers regs
         BSM   0,R14                    and return

T_Literals  DS  0H

T_TRT    DC    256XL1'FF'
         ORG   T_TRT+C' '
         DC    X'00'
         ORG   T_TRT+C'$'
         DC    X'00'
         ORG   T_TRT+C'#'
         DC    X'00'
         ORG   T_TRT+C'@'
         DC    X'00'
         ORG   T_TRT+C'A'
         DC    9XL1'00'
         ORG   T_TRT+C'J'
         DC    9XL1'00'
         ORG   T_TRT+C'S'
         DC    8XL1'00'
         ORG   T_TRT+C'0'
         DC    10XL1'00'
         ORG

         LTORG

T_Literals_End  DS  0H


@T_Dynam                  DSECT
                          DS    18F    O/S style save area
@T_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@T_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)

@T_Last_VLD_Ptr           DS    AL4    A(Last VLD)
@T_SMS_SSOB_Ptr           DS    AL4    A(SSOB)
@T_SMS_SYSNum             DS    HL2    SMS System Number
@T_SMS_SSOB               DS    XL(SSOBHSIZ) SSOB
@T_SMS_SSSA               DS    XL(SSSALN+SSSA1LN)  SSSA (HDR)
                          DS    X      Flag Byte
@T_Volser_in_VLD          EQU   *-1,X'80' 1... .... VLD has Volser
                          DS    0D
@T_SMS_VLD                DS    XL((VLDEND-VLD)+(VLDEND2-VLDSYSDT))
                          ORG   @T_SMS_VLD
@T_SMS_BCD                DS    XL6144  SMS Config Data
                          ORG   ,

                          DS    0D
@T_Dynam_Length           EQU   *-@T_Dynam


&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'U00010: Write to output file'

         PUSH  USING

U00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: U00010                                                 *
*                                                                     *
*  Abstract  : This subroutine manages output DCBs, and writes data   *
*              to them.                                               *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(DDName)                                    *
*                        A(Data)                                      *
*                        A(Length of Data)                            *
*                        A(ASA Ctl Char) or 0                         *
*  Outputs   : R15: 0 = OK                                            *
*                   8 = Error (DCB not OPEN, etc.)                    *
*                                                                     *
*  Operation : If A(DDNAME) = 0                                       *
*                CLOSE all OPEN DCBs                                  *
*                Free DCB storage                                     *
*              Else                                                   *
*                Find DCB for DDName                                  *
*                If DCB not found                                     *
*                  If any data to write                               *
*                    Create and OPEN DCB                              *
*                  EndIf                                              *
*                EndIf                                                *
*                If DCB OPEN                                          *
*                  If no data to write                                *
*                    CLOSE DCB                                        *
*                  Else                                               *
*                    Write Data                                       *
*                  EndIf                                              *
*                EndIf                                                *
*              EndIf                                                  *
*              Return to caller                                       *
*                                                                     *
*  Notes     : Once an OUTFILE is OPEN, it will remain OPEN until     *
*               the SPACE program terminates, to cope with the fol-   *
*               lowing batch scenario:                                *
*                  SPACE .... OUTFILE(X)                              *
*                  SPACE .... OUTFILE(Y)                              *
*                  SPACE .... OUTFILE(X)                              *
*                                                                     *
*  History:    2003/10/07 SDDA030 - V2.21                             *
*                                   New.                              *
*                                   This code was extracted from X0010*
*                                   and generalized, so it could be   *
*                                   used for all output files, includ-*
*                                   ing SYSPRINT.                     *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*                                 - Used separate 24-bit stack for    *
*                                   DCBs, PUT code, etc.              *
*              ____/__/__ ______                                      *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,U_Literals           Point to our literals
         USING (U_Literals,U_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@U_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@U_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @U_Dynam,R13             Assign a base
         L     R15,@U_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@U_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@U_24Bit_Stack_Ptr_Ptr Save it

*-------------------------------------------------------------------*
*    Save our parms                                                 *
*-------------------------------------------------------------------*
        L     R15,12(0,R1)              A(DDName)
        ST    R15,@U_DDName_Ptr         OK, save it

        L     R15,16(0,R1)              A(Data)
        ST    R15,@U_Data_Ptr           Save it

        L     R15,20(0,R1)              A(Data Length)
        ST    R15,@U_Data_Len_Ptr       Save it

        TM    20(R1),X'80'              Was that the last parm?
        BO    U00020                    Yes, skip
        L     R15,24(R1)                A(ASA Character) or 0
        ST    R15,@U_ASA_Char_Ptr       Save it

U00020  DS    0H
*-------------------------------------------------------------------*
*    By convention, if the address of the DDName is 0, we CLOSE all *
*   OPEN DCBs, and free up their storage.                           *
*-------------------------------------------------------------------*
        ICM   R15,B'1111',@U_DDName_Ptr A(DDName)
        JNZ   U00100                    Something there, OK

*-------------------------------------------------------------------*
*    CLOSE the DCBs ...                                             *
*-------------------------------------------------------------------*
         ICM   R3,B'1111',@_OutFile_Chain_Ptr  A(First OUTFile DCB)
         JZ    U00050                   None, exit
U00030   DS    0H
         LA    R15,4+L'@_OutFile_DDName(0,R3) A(DCB)
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it OPEN?
         JNO   U00040                   No, skip CLOSE
         MVC   @U_CLOSE,U_CLOSE         Yes, Move CLOSE Parms
         CLOSE ((15)),MODE=31,MF=(E,@U_CLOSE) and CLOSE it
U00040   DS    0H
         ICM   R3,B'1111',0(R3)         A(next DCB)
         JNZ   U00030                   Got one, close it too

U00050   DS    0H
*-------------------------------------------------------------------*
*    ... free the stack ...                                         *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         JZ    U00080                   None, skip
         SSCSTACK TERM,                 Free the stack area            +
               STACK=(1)                 this one

U00080   DS    0H
         LA    R15,0                    Clear
         ST    R15,@_OutFile_PUT_Code    Code pointer
         ST    R15,@_OutFile_Chain_Ptr   and DCB pointer

*-------------------------------------------------------------------*
*    ... and exit.                                                  *
*-------------------------------------------------------------------*
         LA    R15,0                    All done, clear return code
         J     U90010                    and exit

U00100   DS    0H
*-------------------------------------------------------------------*
*    ... search the chain of OUTFIL DCBs to see if we can find our  *
*   DDName                                                          *
*-------------------------------------------------------------------*
         LA    R15,@_OutFile_Chain_Ptr  A(Ptr to start of chain)
         L     R14,@U_DDName_Ptr        A(Our DDName)
         J     U00120                   and start running it
U00110   DS    0H
         CLC   0(L'@_OutFile_DDName,R14),4(R15)  Yes, is it ours?
         JNE   U00120                   No, skip
         AHI   R15,4+L'@_OutFile_DDName Yes, point to the DCB
         ST    R15,@U_DCB_Ptr           Save it
         J     U00280                   and use it
U00120   DS    0H
         LR    R3,R15                   Save A(this DCB area)
         ICM   R15,B'1111',0(R3)        Point to next
         JNZ   U00110                   Got one, check it out

*-------------------------------------------------------------------*
*    If we have anything to do ...                                  *
*-------------------------------------------------------------------*
         ICM   R15,B'1111',@U_Data_Ptr  Any data?
         JZ    U00390                   No, exit quick smart
         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?
         JZ    U00390                   No, get out
         ICM   R15,B'1111',0(R15)       Yes, length = 0?
         JZ    U00390                   Yes, exit now

*-------------------------------------------------------------------*
*    Our DDName is not found, so get an area on the 24-bit Stack    *
*   for our DCB area ...                                            *
*    The format of this area:                                       *
*       0- 3: Forward pointer                                       *
*       4-11: DDName                                                *
*      12-n : DCB                                                   *
*                                                                   *
*    First, however, we move our 24-bit PUT code, if required. PUT  *
*   runs 24-bit because QSAM has trouble using 31-bit PUT for       *
*   DDNames allocated to the terminal - rather than check, we       *
*   blindly run PUT in 24-bit mode all the time.                    *
*-------------------------------------------------------------------*
         ICM   R0,B'1111',@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         JNZ   U00130                   OK, skip

         L     R0,=AL4(@_24Bit_Stack_Length) Length of storage we need
         SSCSTACK INIT,                 Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=24                    below the line

         ST    R1,@_OutFile_24Bit_Stack_Ptr Update A(DCB Stack)

U00130   DS    0H
         ICM   R15,B'1111',@_OutFile_PUT_Code  A(24-bit PUT code)
         JNZ   U00140                  OK, skip

         LA    R0,U00400_End-U00400    Length of storage we need
         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=(R0),                 this long                     +
               STACK=(R2)                using this stack

         ST    R1,@_OutFile_PUT_Code   Save A(Storage)
         LR    R0,R1                   Set Target address
         LHI   R1,U00400_End-U00400    Set Target length
         BASR  R14,0                   Set Source
         AHI   R14,U00400-*              address
         LR    R15,R1                  and Source length
         MVCL  R0,R14                  Move PUT code

U00140   DS    0H
         LHI   R0,4+L'@_OutFile_DDName+U_OUTFILE_DCB_Length
         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=(R0),                 this long                     +
               STACK=(R2)                using this stack

*-------------------------------------------------------------------*
*    ... chain it to the previous DCB area (pointed to by R3) ...   *
*-------------------------------------------------------------------*
         ST    R1,0(0,R3)               Chain it

*-------------------------------------------------------------------*
*    ... and initialize it.                                         *
*-------------------------------------------------------------------*
         XC    0(4,R1),0(R1)          Clear Ptr to next DCB area
         L     R15,@U_DDName_Ptr      A(DDName)
         MVC   4(L'@_OutFile_DDName,R1),0(R15)  Set DDName
         LA    R15,4+L'@_OutFile_DDName(0,R1) Point to DCB
         MVC   0(U_OUTFILE_DCB_Length,R15),U_OUTFILE_DCB Move DCB
         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R15),4(R1)  Move DDName
         ST    R15,@U_DCB_Ptr         Save A(DCB)

*-------------------------------------------------------------------*
*    Get the JFCB. First, find the TIOT entry ...                   *
*-------------------------------------------------------------------*
         L     R15,CVTPTR(0,0)          A(CVT)
         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)
         L     R15,0(0,R15)             A(Current TCB)
         L     R15,TCBTIO-TCB(R15)      A(TIOT)
         L     R14,@U_DDName_Ptr        A(DDName)
         AHI   R15,TIOENTRY-TIOT1       A(1st entry in TIOT)
U00150   DS    0H
         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?
         JE    U80010                   Yes, DDName not found
         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),0(R14) Ours?
         JE    U00160                   Found our entry, skip
         LA    R0,0                     Clear work reg
         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length
         AR    R15,R0                   Point to next entry
         J     U00150                   and check it out

U00160   DS    0H
*-------------------------------------------------------------------*
*    ... and then get the JFCB address from the SWA                 *
*-------------------------------------------------------------------*
         XC    @U_SWAEPAX,@U_SWAEPAX    Clear SWAEPA
         MVC   @U_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)
         LA    R15,@U_SWAEPAX           A(EPA)
         ST    R15,@U_EPA_Ptr           Save the address
         MVC   @U_SWAREQ,U_SWAREQ       Move L-Form of macro
         SWAREQ FCODE=RL,               Read Locate                    +
               EPA=@U_EPA_Ptr,           using the EPA at this addr    +
               UNAUTH=YES,               not being authoriZED          +
               MF=(E,@U_SWAREQ)          keep ourselves re-entrant
         LTR   R15,R15                  Check return code
         JNZ   U80010                   Not good, skip

         L     R4,@U_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)
         L     R3,@U_DCB_Ptr            Get A(DCB)

*-------------------------------------------------------------------*
*    If this is a new dataset ...                                   *
*-------------------------------------------------------------------*
         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?
         JO    U00170                 Yes, treat it as NEW
         CLI   JFCBIND2-INFMJFCB(R4),0 Any DISP specified?
         JE    U00170                 No, treat it as NEW
         TM    JFCBIND2-INFMJFCB(R4),JFCNEW Yes, DISP=NEW?
         JNO   U00270                 No, use existing DCB stuff

U00170   DS    0H
*-------------------------------------------------------------------*
*    ... set up RECFM, LRECL and BLKSIZE if they were not           *
*   specified. First, set RECFM to FB if it has not been specified. *
*-------------------------------------------------------------------*
         IC    R15,JFCRECFM-INFMJFCB(0,R4) Get RECFM from JFCB
         LTR   R15,R15                Anything?
         JNZ   U00180                 Yes, OK
         LA    R15,DCBRECF+DCBRECBR   No, default to FB

         TM    JFCBTSDM-INFMJFCB(R4),JFCSDS SubSystem Dataset?
         JNO   U00180                 No, OK
         LA    R15,DCBRECCA(0,R15)    Yes, add ASA character
U00180   DS    0H
         STC   R15,DCBRECFM-IHADCB(R3) Set RECFM in DCB

*-------------------------------------------------------------------*
*    Get the LRECL and BLKSIZE from the JFCB ...                    *
*-------------------------------------------------------------------*
         LH    R15,JFCLRECL-INFMJFCB(R4) Get JFCB LRECL
         LH    R14,JFCBLKSI-INFMJFCB(R4) Get JFCB BLKSIZE

*-------------------------------------------------------------------*
*    ... and, if the LRECL hasn't been specified, set it to the     *
*   length of the data to be written (unless this is SYSPRINT, when *
*   the LRECL is set to VolTbl_Ent_Display_Len, to maintain compat- *
*   ibility with previous versions).                                *
*-------------------------------------------------------------------*
         LTR   R15,R15                 Any LRECL?
         JNZ   U00210                  Yes, OK

         L     R15,@U_Data_Len_Ptr     A(Length of data to be written)
         L     R15,0(0,R15)            Get it
         TM    DCBRECFM-IHADCB(R3),DCBRECCC Carriage control?
         JZ    U00200                  No, skip
         AHI   R15,1                   Yes, bump for CC
U00200   DS    0H
         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?
         JO    U00210                  Yes, not RECFM=V
         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?
         JZ    U00210                  No, skip
         AHI   R15,4                   Yes, bump for RDW

U00210   DS    0H
*-------------------------------------------------------------------*
*    If no BLKSIZE specified for RECFM=U, make BLKSIZE = LRECL      *
*-------------------------------------------------------------------*
         LTR   R14,R14                 Any BLKSIZE in the JFCB?
         JNZ   U00220                  Yes, skip
         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?
         JNO   U00220                  No, use SDB
         LR    R14,R15                 Yes, BLKSIZE = LRECL

U00220   DS    0H
*-------------------------------------------------------------------*
*    Check LRECL vs BLKSIZE, and adjust them to fit                 *
*     RECFM=U: LRECL = 0                                            *
*     RECFM=V: BLKSIZE = (n * LRECL) + 4                            *
*     RECFM=F: BLKSIZE = n * LRECL                                  *
*-------------------------------------------------------------------*
         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?
         JNO   U00230                  No, skip
         LA    R15,0                   Yes, clear LRECL
         J     U00260                  and skip
U00230   DS    0H
         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM = V?
         JNO   U00240                  No, skip
         LTR   R14,R14                 Yes, BLKSIZE=0 (SDB)?
         JZ    U00260                  Yes, OK
         TM    DCBRECFM-IHADCB(R3),DCBRECSB Spanned rec?
         JO    U00260                  Yes, OK
         LR    R1,R14                  No, get BLKSIZE
         LA    R0,0                    Clear high-order word
         DR    R0,R15                  BLKSIZE/LRECL
         C     R0,=FL4'4'              Remainder of 4 (BDW)?
         JNL   U00260                  Yes, OK
         LR    R15,R14                 No, LRECL = ...
         S     R15,=FL4'4'                BLKSIZE - 4
         J     U00260                  and skip
U00240   DS    0H
         LTR   R14,R14                 Fixed, BLKSIZE=0 (SDB)?
         JZ    U00260                  Yes, OK
         CR    R14,R15                 No, BLKSIZE > LRECL?
         JNL   U00250                  Yes, OK
         LR    R14,R15                 No, BLKSIZE = LRECL
         J     U00260                  and skip
U00250   DS    0H
         LR    R1,R14                  Get BLKSIZE
         LA    R0,0                    Clear high-order word
         DR    R0,R15                  BLKSIZE/LRECL
         SR    R14,R0                  Adjust BLKSIZE by remainder
         J     U00260                  and skip
U00260   DS    0H
         STH   R15,DCBLRECL-IHADCB(R3) Update DCB LRECL
         STH   R14,DCBBLKSI-IHADCB(R3) Update DCB BLKSIZE

U00270   DS    0H
*-------------------------------------------------------------------*
*    Open the DCB, and exit quick smart if it doesn't               *
*-------------------------------------------------------------------*
         L     R3,@U_DCB_Ptr           Point to our DCB

         MVC   @U_OPEN,U_OPEN             Move OPEN parms
         OPEN  ((3),OUTPUT),MODE=31,MF=(E,@U_OPEN) And OPEN it

         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?
         JNO   U80010                  No, exit with error

U00280   DS    0H
*-------------------------------------------------------------------*
*    We have our DCB - if it is OPEN ...                            *
*-------------------------------------------------------------------*
         LA    R15,0                   Clear return code
         L     R3,@U_DCB_Ptr           Get A(DCB)
         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?
         JNO   U90010                  No, skip

*-------------------------------------------------------------------*
*    ... if we have nothing to do, CLOSE the DCB. Otherwise ...     *
*-------------------------------------------------------------------*
         ICM   R15,B'1111',@U_Data_Ptr  Any data?
         JZ    U00290                   No, close DCB
         ICM   R15,B'1111',@U_Data_Len_Ptr Yes, any length pointer?
         JZ    U00290                   No, close DCB
         ICM   R15,B'1111',0(R15)       Yes, length = 0?
         JNZ   U00300                   NO, OK
U00290   DS    0H
         MVC   @U_CLOSE,U_CLOSE         Move CLOSE Parms
         CLOSE ((3)),MODE=31,MF=(E,@U_CLOSE) and CLOSE our DCB
         J     U00390                   and exit

U00300   DS    0H
*-------------------------------------------------------------------*
*    ... get an area to hold the data we will write. It's length    *
*   is:                                                             *
*    RECFM=U:                                                       *
*       Length of data to be written                                *
*      +1 if the DCB has a Print Ctl Char & A(ASA Char) \= 0        *
*    Otherwise:                                                     *
*       DCBLRECL                                                    *
*-------------------------------------------------------------------*
         LH    R0,DCBLRECL-IHADCB(R3)  Get LRECL

         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM = U?
         JNO   U00310                  No, skip
         L     R15,@U_Data_Len_Ptr     A(Len of data to be written)
         L     R0,0(0,R15)             Get it
         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?
         JZ    U00310                  No, skip
         ICM   R15,B'1111',@U_ASA_Char_Ptr Yes, do we have one?
         JZ    U00310                  No, too bad
         AHI   R0,1                    Yes, bump length
U00310   DS    0H

         ST    R0,@U_OutRec_Len        Save length
         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=(R0),                 this long                     +
               STACK=(R2)                using this stack

         ST    R1,@U_OutRec_Ptr        Save A(Data area)

*-------------------------------------------------------------------*
*    ... move the data passed to us to our output area ...          *
*-------------------------------------------------------------------*
         L     R14,@U_OutRec_Ptr        A(Output Record)
         TM    DCBRECFM-IHADCB(R3),DCBRECU RECFM=U?
         JO    U00320                  Yes, its not RECFM=V
         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?
         JNO   U00320                  No, skip
         LA    R14,4(0,R14)            Yes, bump for RDW
U00320   DS    0H
         TM    DCBRECFM-IHADCB(R3),DCBRECCC CC?
         JZ    U00330                  No, skip
         ICM   R15,B'1111',@U_ASA_Char_Ptr Do we have one?
         JZ    U00330                  No, skip
         MVC   0(1,R14),0(R15)         Yes, move it
         TM    DCBRECFM-IHADCB(R3),DCBRECCM Machine CC?
         JZ    U00265                  No, skip
         TR    0(1,R14),U_ASA_to_Mach  Yes, translate it
U00265   DS    0H
         LA    R14,1(0,R14)            and bump output pointer
U00330   DS    0H
         LR    R0,R14                  A(Output)
         L     R1,@U_OutRec_Ptr        Calculate
         A     R1,@U_OutRec_Len         length of output
         SR    R1,R0                    data left
         L     R14,@U_Data_Ptr         A(Data to be copied)
         L     R15,@U_Data_Len_Ptr     A(Length)
         L     R15,0(0,R15)            Get its length
         O     R15,=XL4'40000000'      Pad character of blank
         MVCL  R0,R14                  Move it

         S     R14,@U_OutRec_Ptr       Length of output record

*-------------------------------------------------------------------*
*    ... if this is a RECFM=U file, update DCBBLKSI, after saving   *
*   it. Otherwise ...                                               *
*-------------------------------------------------------------------*
         TM    DCBRECFM-IHADCB(R3),DCBRECU  RECFM=U?
         JNO   U00350                  No, skip
         LH    R0,DCBBLKSI-IHADCB(R3)  Yes, get max record len
         STH   R0,@U_BLKSIZE           and save it
         CR    R14,R0                  Are we trying to write too much?
         JNH   U00340                  No, OK
         LR    R14,R0                  Yes, write what we can
U00340   DS    0H
         STH   R14,DCBBLKSI-IHADCB(R3) Update it with current length
         J     U00370                  and skip

U00350   DS    0H
*-------------------------------------------------------------------*
*    ... if this is a RECFM=V file, update the RDW                  *
*-------------------------------------------------------------------*
         TM    DCBRECFM-IHADCB(R3),DCBRECV RECFM=V?
         JNO   U00370                  No, OK
         LH    R0,DCBLRECL-IHADCB(R3)  Yes, get LRECL
         CR    R14,R0                  Are we trying to write too much?
         JNH   U00360                  No, OK
         LR    R14,R0                  Yes, write what we can
U00360   DS    0H
         L     R15,@U_OutRec_Ptr       Get A(Output record)
         SLL   R14,16                  Length in high-order byte
         ST    R14,0(0,R15)            Update RDW
         J     U00370                  and skip

U00370   DS    0H
*-------------------------------------------------------------------*
*    Write our data ...                                             *
*-------------------------------------------------------------------*
         L     R1,@U_DCB_Ptr           Point to our DCB
         L     R0,@U_OutRec_Ptr        Point to data to be written
         L     R15,@_OutFile_PUT_Code  Point to our code
         BASR  R14,R15                 Go issue PUT

*-------------------------------------------------------------------*
*    ... and restore DCBBLKSI, if this is RECFM=U                   *
*-------------------------------------------------------------------*
         L     R1,@U_DCB_Ptr           Point to our DCB
         TM    DCBRECFM-IHADCB(R1),DCBRECU  RECFM=U?
         JNO   U00380                  No, skip
         LH    R0,@U_BLKSIZE           Yes, get saved BLKSIZE
         STH   R0,DCBBLKSI-IHADCB(R1)  and restore the DCB

U00380   DS    0H
*-------------------------------------------------------------------*
*    Free the storage we got for our record ...                     *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',@U_OutRec_Ptr A(Output record data area)
         JZ    U00390                   Nothing, skip
         L     R2,@_OutFile_24Bit_Stack_Ptr A(DCB Stack)
         SSCSTACK POP,                  Free the record area           +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

U00390   DS    0H
*-------------------------------------------------------------------*
*    ... clear the return code, and exit.                           *
*-------------------------------------------------------------------*
         LA    R15,0                   Clear return code
         J     U90010                  and exit

*-------------------------------------------------------------------*
*    The following code is moved to storage below-the-line, and     *
*   is executed via a BASR, so it runs AMODE24. This is required if *
*   the DCB to which we are writing happens to be allocated to      *
*   the TSO terminal.                                               *
*                                                                   *
*   Note that R14-R3 are updated by this routine.                   *
*-------------------------------------------------------------------*


U00400   DS    0H
         PUSH  USING                   Save USING environment
         DROP  ,                       Free them all
         USING *,R15                   Assign a base
         LR    R3,R14                  Save return address
         PUT   (1),(0)                 Write record (MACRF=PM)
         LA    R14,X'80'               Set up
         SLL   R14,24                   31-bit
         OR    R14,R3                   return address
         BSM   0,R14                   Back to caller in AMODE31
         DROP  R15                     Free our base
         POP   USING                   Restore USING environment
U00400_End EQU *


U80010   DS    0H
*-------------------------------------------------------------------*
*    We couldn't OPEN the DCB, so exit with a return code           *
*-------------------------------------------------------------------*
         LA    R15,4                   RC = 4
         J     U90010                  and exit

U90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save Return Code

         LA    R1,@U_Dynam              A(Local storage)
         L     R2,@U_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)         Point to it
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore Return Code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

U_Literals  DS  0H

U_ASA_to_Mach DC  256X'09'               Default - space 1 line
              ORG U_ASA_to_Mach+C'0'     Space 2 lines
              DC  X'11'
              ORG U_ASA_to_Mach+C'-'     Space 3 lines
              DC  X'19'
              ORG U_ASA_to_Mach+C'+'     Suppress spacing
              DC  X'01'
              ORG U_ASA_to_Mach+C'1'     Skip to Channel 1
              DC  X'89'
              ORG

         LTORG

         PUSH  PRINT
         PRINT NOGEN

U_OUTFILE_DCB DCB DDNAME=OUTFILE,MACRF=PM,DSORG=PS
U_OUTFILE_DCB_Length EQU *-U_OUTFILE_DCB Length of OUTFILE DCB

U_SWAREQ SWAREQ MF=L                    Read Locate
U_SWAREQ_Length EQU *-U_SWAREQ          Length of SWAREQ Macro

U_OPEN   OPEN  (0,INPUT),MODE=31,MF=L
U_OPEN_Length EQU  *-U_OPEN

U_CLOSE  CLOSE (0),MODE=31,MF=L
U_CLOSE_Length EQU  *-U_CLOSE

         POP PRINT

U_Literals_End  DS  0H


@U_Dynam                  DSECT       Dynamic area for U0000
                          DS    18F    O/S Style save area
@U_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@U_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)

@U_DDName_Ptr             DS    AL4    A(DDName)
@U_Data_Ptr               DS    AL4    A(Data to be written)
@U_Data_Len_Ptr           DS    AL4    A(Length of data to be written)
@U_ASA_Char_Ptr           DS    AL4    A(ASA CC) or 0

@U_DCB_Ptr                DS    AL4    A(Current DCB)
@U_BLKSIZE                DS    HL2    BLKSIZE for RECFM=U DCB

@U_OutRec_Ptr             DS    AL4    A(Buffer for PUT)
@U_OutRec_Len             DS    FL4    A(Length of above buffer)

@U_Macros                 DS    0F
@U_OPEN                   DS    CL(U_OPEN_Length)
                          ORG   @U_Macros
@U_CLOSE                  DS    CL(U_CLOSE_Length)
                          ORG   @U_Macros
@U_EPA_Ptr                DS    AL4    A(EPA for SWAREQ)
@U_SWAREQ                 DS    CL(U_SWAREQ_Length)
                          DS    0F
@U_SWAEPAX                DS    CL(L'SWAEPAX)
                          ORG   ,
                          DS    0D     Alignment
@U_Dynam_Length           EQU   *-@U_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'V00010: Set up Statistics output lines'

         PUSH  USING

V00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: V00010                                                 *
*                                                                     *
*  Abstract  : Populate statistics lines in the Volume Table.         *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(VolTbl_Ent)                                *
*  Outputs   : R15: 0: OK                                             *
*                                                                     *
*  Notes     : N/A                                                    *
*                                                                     *
*  History:    2000/05/23 SDDA030 - V2.12                             *
*                                 - New                               *
*              2001/02/01 SDDA030 - V2.13                             *
*                                 - Populated Main task CPU time      *
*                                   stats line.                       *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Checked and flagged               *
*                                   VolTbl_Ent_Stats_Done so the stats*
*                                   lines are populated once only.    *
*              2002/06/11 SDDA030 - V2.18                             *
*                                   WAIT for VolTbl to be populated   *
*                                   before updating.                  *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,V_Literals           Point to our literals
         USING (V_Literals,V_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@V_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@V_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @V_Dynam,R13             Assign a base
         L     R15,@V_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@V_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@V_24Bit_Stack_Ptr_Ptr Save it

*---------------------------------------------------------------------*
*   Load the base register for VolTbl_Ent                             *
*---------------------------------------------------------------------*
         L     R9,12(0,R1)             Point to VolTbl_Ent
         USING VolTbl_Ent,R9           Tell the Assembler

*---------------------------------------------------------------------*
*   If this is a Stack Statistics line ...                            *
*---------------------------------------------------------------------*
         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack
         JZ    V00020                   Not 31-bit Stack stats, skip
         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?
         JO    V00060                   Yes, skip
         L     R8,@V_31Bit_Stack_Ptr_Ptr Get 31-bit stack pointer
         L     R8,0(0,R8)               and point to the stack
         J     V00030                   and skip
V00020   DS    0H
         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack
         JZ    V00080                   Not 24-bit Stack stats, skip
         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?
         JO    V00060                   Yes, skip
         L     R8,@V_24Bit_Stack_Ptr_Ptr No, get 24-bit stack pointer
         L     R8,0(0,R8)               and point to it
V00030   DS    0H
         L     R15,@_VolTbl_Ptr         A(VolTbl)
         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated
         JO    V00030C                  Yes, OK
         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it
V00030C  DS    0H
         LA    R14,V_Stats_Line4        A(Source)
         LHI   R15,V_Stats_Line4_Len    Length of source
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move Stats Line4
         TM    VolTbl_Ent_Stats_31Stack,L'VolTbl_Ent_Stats_31Stack
         JNO   V00040                   Not 31-bit stack, skip
         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+
               _Stats_Line4_Stack),=C'31'
         J     V00050
V00040   DS    0H
         TM    VolTbl_Ent_Stats_24Stack,L'VolTbl_Ent_Stats_24Stack
         JNO   V00050                   Not 24-bit stack, skip
         MVC   VolTbl_Ent_Display+V_Stats_Line4_Stack-V_Stats_Line4(L'V+
               _Stats_Line4_Stack),=C'24'
         J     V00050
V00050   DS    0H

         LTR   R0,R8                     Any Stack?
         JZ    V00050C                   No, default of 0
         L     R0,StackHdr_StackLen-StackHdr(R8) Get stack length
V00050C  DS    0H
         CVD   R0,@V_DBLWD               Pack it
         ED    VolTbl_Ent_Display+V_Stats_Line4_Size-V_Stats_Line4(L'V_+
               Stats_Line4_Size),@V_DBLWD+5

         LTR   R0,R8                     Any Stack?
         JZ    V00050E                   No, default of 0
         L     R0,StackHdr_HWM-StackHdr(R8) Get high-water mark
         SR    R0,R8                     as a length
V00050E  DS    0H
         CVD   R0,@V_DBLWD               Pack it
         ED    VolTbl_Ent_Display+V_Stats_Line4_HWM-V_Stats_Line4(L'V_S+
               tats_Line4_HWM),@V_DBLWD+5

         LTR   R0,R8                     Any Stack?
         JZ    V00050G                   No, default of 0
         L     R0,StackHdr_GETMAIN-StackHdr(R8) Get converted PUSHs
V00050G  DS    0H
         CVD   R0,@V_DBLWD               Pack it
         ED    VolTbl_Ent_Display+V_Stats_Line4_GETMAIN-V_Stats_Line4(L+
               'V_Stats_Line4_GETMAIN),@V_DBLWD+5

         LTR   R0,R8                     Any Stack?
         JZ    V00050I                   No, default of 0
         L     R0,StackHdr_Overflow_HWM-StackHdr(R8) GETMAIN HWM
V00050I  DS    0H
         CVD   R0,@V_DBLWD               Pack it
         ED    VolTbl_Ent_Display+V_Stats_Line4_GHWM-V_Stats_Line4(L'V_+
               Stats_Line4_GHWM),@V_DBLWD+5

         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now

         L     R0,VolTbl_Ent_ECB        Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    V00050K                  Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it
         JZ    V00060                   OK, skip the real POST
V00050K  DS    0H
         POST  VolTbl_Ent_ECB,0         POST line as complete

V00060   DS    0H
         LA    R15,0                    Clear return code
         J     V90010                   and exit

V00080   DS    0H
*---------------------------------------------------------------------*
*   If this is a CPU Stats Line ...                                   *
*---------------------------------------------------------------------*
         TM    VolTbl_Ent_Stats_CPUTime,L'VolTbl_Ent_Stats_CPUTime
         JZ    V01999                   Not CPU Time, skip
         TM    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done?
         JO    V00110                   Yes, skip
         L     R15,@_VolTbl_Ptr         A(VolTbl)
         TM    VolTbl_Hdr_ECB-VolTbl_Hdr(R15),X'40' Table populated
         JO    V00080C                  Yes, OK
         WAIT  ECB=VolTbl_Hdr_ECB-VolTbl_Hdr(R15) No, WAIT for it
V00080C  DS    0H
         LA    R14,V_Stats_Line5        A(Source)
         LHI   R15,V_Stats_Line5_Len    Length of source
         O     R15,=XL4'40000000'       Pad char of blank
         LA    R0,VolTbl_Ent_Display    A(Target)
         LHI   R1,VolTbl_Ent_Display_Len Length of target
         MVCL  R0,R14                   Move Stats Line5
         TIMEUSED STORADR=@V_DBLWD,     Get CPU time used              +
               LINKAGE=SYSTEM,           as recommended by IBM         +
               CPU=MIC                   get it in microseconds
         LM    R14,R15,@V_DBLWD         Get current TCB time
         LM    R0,R1,@_CPU_Time_Init    Get TCB Time used previously
         SLR   R15,R1                   Subtract
         JNM   V00090                   No overflow, OK
         SL    R14,=FL4'1'              Borrow, adjust
V00090   DS    0H
         SLR   R14,R0                   Adjust this one too

         AL    R15,@_CPU_Time_Used+4    Bump Accum CPU Time
         BRC   12,V00100                No Carry, OK
         AL    R14,=FL4'1'              Carry, bump it
V00100   DS    0H
         AL    R14,@_CPU_Time_Used      Bump Accum CPU Time
         D     R14,=FL4'1000'           To seconds (3 decimals)
         CVD   R15,@V_DBLWD              Pack it
         ED    VolTbl_Ent_Display+V_Stats_Line5_CPUTime-V_Stats_Line5(L+
               'V_Stats_Line5_CPUTime),@V_DBLWD+5

         TM    @_OW48527,L'@_OW48527     Is OW48527 on?
         JO    V00100B                   Yes, never went NONSWAP

         LA    R1,VolTbl_Ent_Display+V_Stats_Line5_CPUTime+L'V_Stats_Li+
               ne5_CPUTime-V_Stats_Line5 A(End of line)
         MVC   0(29,R1),=C', Non-Swappable Elapsed Time:'
         MVC   29(7,R1),=X'4021204B202020' Move mask
         LM    R14,R15,@_NSwap_Time      Get Non-swappable time
         SRDL  R14,12                    Convert to usec
         D     R14,=FL4'1000'            Convert to millisecs
         CVD   R15,@V_DBLWD              Pack it
         ED    29(7,R1),@V_DBLWD+5       Edit into message

V00100B  DS    0H
         OI    VolTbl_Ent_Stats_Done,L'VolTbl_Ent_Stats_Done Done now

         L     R0,VolTbl_Ent_ECB        Current contents of our ECB
         TM    VolTbl_Ent_ECB,X'80'     Anyone WAITing?
         JO    V00100C                  Yes, we need to POST
         L     R1,=XL4'40000000'        No, POST code of 0
         CS    R0,R1,VolTbl_Ent_ECB     Pseudo-POST it
         JZ    V00110                   OK, skip the real POST
V00100C  DS    0H
         POST  VolTbl_Ent_ECB,0         POST line as complete

V00110   DS    0H
         LA    R15,0                    Clear return code
         J     V90010                   and exit

V01999   DS    0H
*---------------------------------------------------------------------*
*   Unknown Stats Line, exit                                          *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     V90010                   and exit


V90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@V_Dynam              A(Local storage)
         L     R2,@V_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

V_Literals  DS  0H


V_Stats_Line4         EQU   *
                      DC    C' '
V_Stats_Line4_Stack   DC    C'31'
                      DC    C'-Bit Stack: Size:'
V_Stats_Line4_Size    DC    X'402020202120'
                      DC    C', HWM:'
V_Stats_Line4_HWM     DC    X'402020202120'
                      DC    C', GETMAINs:'
V_Stats_Line4_GETMAIN DC    X'402020202120'
                      DC    C', GETMAIN HWM:'
V_Stats_Line4_GHWM    DC    X'402020202120'
V_Stats_Line4_Len     EQU   *-V_Stats_Line4

V_Stats_Line5         EQU   *
                      DC    C' '
                      DC    C'Main Task CPU Time:'
V_Stats_Line5_CPUTime DC    X'4021204B202020'
V_Stats_Line5_Len     EQU   *-V_Stats_Line5

         LTORG

V_Literals_End  DS  0H


@V_Dynam                  DSECT        Dynamic area for V00000
                          DS    18F     O/S Style save area
@V_31Bit_Stack_Ptr_Ptr    DS    AL4     A(31-bit Stack Ptr)
@V_24Bit_Stack_Ptr_Ptr    DS    AL4     A(24-bit Stack Ptr)
@V_DBLWD                  DS    D       Work area
                          DS    0D      Alignment
@V_Dynam_Length           EQU   *-@V_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'W00010: Point to next free VolTbl entry'

         PUSH  USING

W00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: W00010                                                 *
*                                                                     *
*  Abstract  : Return a pointer to the next free entry in VolTbl. If  *
*              all entries are used, a larger VolTbl is GETMAINed, and*
*              the current table copied to the new                    *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R1 : A(Free entry) or 0 if storage unavailable         *
*                                                                     *
*  Notes     : N/A                                                    *
*                                                                     *
*  History:    1999/08/20 SDDA030 - V2.8                              *
*                                 - New                               *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used conditional STORAGE OBTAINs  *
*                                   when expanding VolTbl             *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,W_Literals           Point to our literals
         USING (W_Literals,W_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@W_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@W_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @W_Dynam,R13             Assign a base
         L     R15,@W_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@W_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@W_24Bit_Stack_Ptr_Ptr Save it

W00020   DS    0H
*---------------------------------------------------------------------*
*   Point to the next free entry                                      *
*---------------------------------------------------------------------*
         LA    R14,0                    Clear used length
         LA    R15,0                    Clear table length
         ICM   R1,B'1111',@_VolTbl_Ptr  A(Current table)
         JZ    W00030                   None, skip
         LHI   R14,VolTbl_Ent_Len       Yes, Length of 1 entry
         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Current entries used
         MR    R14,R14                  Get current length used
         LR    R14,R15                  Save it
         L     R15,VolTbl_Hdr_TbLen-VolTbl(R1) Get len of table
         AR    R15,R1                   Point to end of table
W00030   DS    0H
         LA    R1,VolTbl_Ent-VolTbl(R1,R14) Point to next (free) entry
         SR    R15,R1                   Get length remaining
         LHI   R0,VolTbl_Ent_Len        Length of 1 entry
         CR    R15,R0                   Do we have room to add?
         JNL   W00060                   Yes, skip

*---------------------------------------------------------------------*
*   We have to get a new table, so get the current number of entries  *
*---------------------------------------------------------------------*
         TM    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err
         JO    W80010                   Yes, just exit with error

         LHI   R15,99                   Initial nbr entries (1st time)
         ICM   R1,B'1111',@_VolTbl_Ptr  A(Table)
         JZ    W00040                   None, skip
         L     R15,VolTbl_Hdr_Count-VolTbl_Hdr(R1) Yes, get nbr ents

W00040   DS    0H
*---------------------------------------------------------------------*
*   Calculate the Min (1 more entry) and Max (double the number of    *
*    entries) lengths of the new table ...                            *
*---------------------------------------------------------------------*
         LA    R0,1(0,R15)              Min of 1 more entry
         LHI   R1,VolTbl_Ent_Len        Length of 1 entry
         MR    R0,R0                    Get new length of entries
         LA    R4,VolTbl_Ent-VolTbl(R1) Add length of header
         AHI   R4,7                     Make sure its
         SRL   R4,3                      a doubleword
         SLL   R4,3                      multiple

         LR    R0,R15                   Max len of double
         SLL   R0,1                      the number of entries
         LHI   R1,VolTbl_Ent_Len        Length of 1 entry
         MR    R0,R0                    Get new length of entries
         LA    R5,VolTbl_Ent-VolTbl(R1) Add length of header
         AHI   R5,7                     Make sure its
         SRL   R5,3                      a doubleword
         SLL   R5,3                      multiple

*---------------------------------------------------------------------*
*   ... and go get storage for it                                     *
*---------------------------------------------------------------------*
         BASR  R2,0
         USING (*,W00040_End-1),R2
         STORAGE OBTAIN,                Go get a table                 +
               LENGTH=((4),(5)),         this long                     +
               LOC=31,                   above-the-line                +
               COND=YES,                 let us know what happens      +
               ADDR=(3)                  return address here
W00040_End DS  0H
         DROP  R2

         LTR   R15,R15                  Did we get the storage?
         JNZ   W80010                   No, oh dear

*---------------------------------------------------------------------*
*   Copy the old table to the new.                                    *
*---------------------------------------------------------------------*
         LR    R4,R0                    Save new table length
         LR    R1,R0                    New table length
         LR    R0,R3                    Point to the new table
         LA    R15,0                    Clear old table length
         ICM   R14,B'1111',@_VolTbl_Ptr A(Old table)
         JZ    W00050                   None, skip
         L     R15,VolTbl_Hdr_TbLen-VolTbl(R14) Yes, get current length
W00050   DS    0H
         MVCL  R0,R14                   Move old to new
         ST    R4,VolTbl_Hdr_TbLen-VolTbl(R3) Update table length
         L     R1,@_VolTbl_Ptr          A(Old table)
         ST    R3,@_VolTbl_Ptr          Update with A(New table)
         LTR   R1,R1                    Is there an old table?
         JZ    W00020                   No, start again

*---------------------------------------------------------------------*
*   Free up the old table                                             *
*---------------------------------------------------------------------*
         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length
         BASR  R2,0
         USING (*,W00050_End-1),R2
         STORAGE RELEASE,               Free the old table             +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
W00050_End DS  0H
         DROP  R2
         J     W00020                   Start again

W00060   DS    0H
*---------------------------------------------------------------------*
*   We have an new entry: bump nbr entries used ...                   *
*---------------------------------------------------------------------*
         L     R15,@_VolTbl_Ptr         A(Volume Table)
         L     R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Get # used entries
         AHI   R14,1                    Bump it
         ST    R14,VolTbl_Hdr_Count-VolTbl_Hdr(R15) Save it

*---------------------------------------------------------------------*
*   ... and initialize the entry.                                     *
*---------------------------------------------------------------------*
         LR    R2,R1                    Save Entry address

         LR    R0,R2                    A(Target)
         LHI   R1,VolTbl_Ent_Len        Length of entry
         LA    R14,0                    A(Source)
         LA    R15,0                    Length of source
         MVCL  R0,R14                   Set table entry to X'00'

         LA    R0,VolTbl_Ent_Display-VolTbl_Ent(R2) A(Display area)
         LHI   R1,VolTbl_Ent_Display_Len Length of display area
         LA    R14,0                    A(Source)
         L     R15,=XL4'40000000'       Source len = 0, pad = blank
         MVCL  R0,R14                   Set display area to blanks

         LR    R1,R2                    A(Table entry)
         SLR   R15,R15                  Clear return code
         J     W90010                   and exit

W80010   DS    0H
*-------------------------------------------------------------------*
*    STORAGE OBTAIN error: set a flag so we don't try to get more,  *
*                          set return code, and exit                *
*-------------------------------------------------------------------*
         OI    @_VolTbl_GETMAIN_Err,L'@_VolTbl_GETMAIN_Err
         SLR   R1,R1                    Clear A(New entry)
         LA    R15,8                    Set return code
         J     W90010                   and exit

W90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R1                    Save A(Free entry)
         LR    R4,R15                   Save return code

         LA    R1,@W_Dynam              A(Local storage)
         L     R2,@W_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R1,R3                    Restore A(Free entry)
         LR    R15,R4                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         L     R0,20(0,R13)             Restore R0
         LM    R2,R12,28(R13)           Restore other registers
         BSM   0,R14                    and return

W_Literals  DS  0H

         LTORG

W_Literals_End  DS  0H


@W_Dynam                  DSECT       Dynamic area for W00000
@W_Save                   DS    18F    O/S Style save area
@W_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@W_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)
                          DS    0D     Alignment
@W_Dynam_Length           EQU   *-@W_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'X00010: Write data to OUTFIL'

         PUSH  USING

X00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: X00010                                                 *
*                                                                     *
*  Abstract  : This subroutine goes through the VolTbl, writing       *
*              detail lines to the DDName passed.                     *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(DDName)                                    *
*                        A(OutData flag)                              *
*  Outputs   : R15: 0 = OK                                            *
*                   8 = Error (DCB not OPEN, etc.)                    *
*                                                                     *
*  Operation : Set up parms for U00010                                *
*              Do for each Detail line in VolTbl                      *
*                Invoke U00010                                        *
*              EndDo                                                  *
*              Return to caller                                       *
*                                                                     *
*  History:    2000/01/19 SDDA030 - V2.11                             *
*                                   New                               *
*              2000/05/23 SDDA030 - V2.12                             *
*                                   Added check for OUTFILE(SYSPRINT) *
*                                   Checked BLKSIZE=0                 *
*              2001/02/26 SDDA030 - V2.14                             *
*                                   Output all detail entries from    *
*                                   VolTbl instead of one at a time.  *
*              2002/03/11 SDDA030 - V2.17                             *
*                                   Converted RDJFCB to SWAREQ.       *
*                                   Updated logic for LRECL, BLKSIZE. *
*                                   Improved efficiency.              *
*                                   Preserved BLKSIZE for RECFM=U.    *
*              2002/06/11 SDDA030 - V2.18                             *
*                                   WAIT for VolTbl_Ent to be populated
*                                   before outputting                 *
*              2003/10/07 SDDA030 - V2.21                             *
*                                   Accept DDName, OutData flag as    *
*                                   parms.                            *
*                                   Remove check for SYSPRINT.        *
*                                   Moved OPEN/CLOSE, I/O to U00010.  *
*              2006/04/21 SDDA030 - V2.24                             *
*                                   Used standardised calling sequence*
*              ____/__/__ ______                                      *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,X_Literals           Point to our literals
         USING (X_Literals,X_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@X_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@X_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @X_Dynam,R13             Assign a base
         L     R15,@X_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@X_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@X_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@X_Parms_Std         Save it
         L     R15,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@X_Parms_Std+4       Save it
         L     R15,@X_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@X_Parms_Std+8       Save it

*-------------------------------------------------------------------*
*    Build our parm list for U00010                                 *
*-------------------------------------------------------------------*
        ICM   R15,B'1111',12(R1)        A(DDName)
        JZ    X00350                    None, exit quietly
        ST    R15,@X_Parms_U00010       OK, save it

*-------------------------------------------------------------------*
*    Get the length and offset of the data we will be writing       *
*-------------------------------------------------------------------*
         ICM   R1,B'1111',16(R1)         A(OutData flag)
         TM    0(R1),L'@_OutData_DISPLAY  Display only?
         JNO   X00260                  No, skip
         LA    R14,VolTbl_Ent_Display-VolTbl_Ent Yes, Offset of start
         LHI   R15,VolTbl_Ent_Display_Len and get length
         J     X00280                  skip
X00260   DS    0H
         TM    0(R1),L'@_OutData_CB    Control Blocks only?
         JNO   X00270                  No, skip
         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent Yes, Offset of start
         LHI   R15,VolTbl_Ent_CB_End-VolTbl_Ent_CB_Start and length
         J     X00280                  and skip
X00270   DS    0H
         LA    R14,VolTbl_Ent_CB_Start-VolTbl_Ent ALL, Offset of CB)
         LHI   R15,VolTbl_Ent_Display_End-VolTbl_Ent_CB_Start Length
X00280   DS    0H
         ST    R14,@X_Source_Offset    Save Offset
         ST    R15,@X_Source_Len       Save Length
         LA    R15,@X_Source_Len       A(Length)
         ST    R15,@X_Parms_U00010+8   Save for U00010

         OI    @X_Parms_U00010+8,X'80'   Flag as last

*-------------------------------------------------------------------*
*    Go through VolTbl ...                                          *
*-------------------------------------------------------------------*
         ICM   R9,B'1111',@_VolTbl_Ptr A(Volume Table)
         JZ    X00350                  None, exit quietly
         ICM   R10,B'1111',VolTbl_Hdr_Count-VolTbl(R9) Get nbr vols
         JZ    X00350                  None, we're done
         LA    R9,VolTbl_Ent-VolTbl(R9) A(1st entry)

         Using VolTbl_Ent,R9           Tell the assembler

X00330   DS    0H
*-------------------------------------------------------------------*
*    If this is a detail line, write it out                         *
*-------------------------------------------------------------------*
         TM    VolTbl_Ent_Detail_Line,L'VolTbl_Ent_Detail_Line Detail?
         JNO   X00340                  No, skip it
         TM    VolTbl_Ent_SMS_Line,L'VolTbl_Ent_SMS_Line SMS Anomaly?
         JO    X00340                  Yes, skip it

         TM    VolTbl_Ent_ECB,X'40'    Yes, is it populated?
         JO    X00330C                 Yes, OK
         WAIT  ECB=VolTbl_Ent_ECB      No, WAIT 'till it is
X00330C  DS    0H
         LA    R15,VolTbl_Ent          A(Entry)
         A     R15,@X_Source_Offset    Point to our data
         ST    R15,@X_Parms_U00010+4   Save it

         LA    R1,@X_Parms             A(Parm list)
         BRAS  R14,U00010              Output it

X00340   DS    0H
*-------------------------------------------------------------------*
*    And process the next entry                                     *
*-------------------------------------------------------------------*
         AHI   R9,VolTbl_Ent_Len       A(Next VolTbl entry)
         BRCT  R10,X00330              and do the next

X00350   DS    0H
*-------------------------------------------------------------------*
*    Clear the return code, and exit.                               *
*-------------------------------------------------------------------*
         LA    R15,0                   Clear return code
         J     X90010                  and exit

X90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save Return Code

         LA    R1,@X_Dynam              A(Local storage)
         L     R2,@X_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore Return Code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

X_Literals  DS  0H

         LTORG

X_Literals_End  DS  0H


@X_Dynam                  DSECT       Dynamic area for 10000
                          DS    18F    O/S Style save area
@X_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@X_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)

@X_Source_Offset          DS    FL4    Offset (in VolTbl_Ent)
@X_Source_Len             DS    FL4    Length of data

@X_Parms                  DS    0F     Parms for called rtns
@X_Parms_Std              DS    3AL4    Standard 3 parms
@X_Parms_Extra            EQU   *       Extra parms
@X_Parms_U00010           DS    4AL4       for U00010
                          ORG   ,

                          DS    0D     Alignment
@X_Dynam_Length           EQU   *-@X_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'Y00010: SYSPRINT I/O Routine'

         PUSH  USING

Y00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: Y00010                                                 *
*                                                                     *
*  Abstract  : This subroutine manages messages destined for SYSPRINT.*
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*                        A(Data to be written) or 0                   *
*                        Length of data to be written                 *
*  Outputs   : R15: 0 = OK                                            *
*                   8 = Error (SYSPRINT not OPEN, etc.)               *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1998/10/01 SDDA030 - New                               *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Moved back into mainline code.    *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*              1999/09/30 SDDA030 - V2.10                             *
*                                 - Used @_Line_Count values to gen-  *
*                                   erate Hdr0-3.                     *
*              2001/02/26 SDDA030 - V2.14                             *
*                                 - Headings now in table.            *
*                                 - Only write DCBLRECLs worth of     *
*                                   data to SYSPRINT.                 *
*              2003/10/07 SDDA030 - V2.21                             *
*                                 - Moved OPEN/CLOSE, I/O to U00010.  *
*                                 - Trimmed trailing spaces.          *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*                                 - Checked length to be written      *
*                                   against LINESIZE()                *
*              ____/__/__ ______                                      *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,Y_Literals           Point to our literals
         USING (Y_Literals,Y_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@Y_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@Y_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @Y_Dynam,R13             Assign a base
         L     R15,@Y_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@Y_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@Y_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@Y_Parms_Std         Save it
         L     R15,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@Y_Parms_Std+4       Save it
         L     R15,@Y_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@Y_Parms_Std+8       Save it

*-------------------------------------------------------------------*
*    If we have nothing to do, just exit.                           *
*-------------------------------------------------------------------*
         ICM   R15,B'1111',12(R1)       A(Data to be printed)
         JZ    Y00130                   Nothing, just exit
         ICM   R0,B'1111',16(R1)        Len of data
         JZ    Y00130                   Nothing, just exit
         LR    R1,R15                   A(Date in proper register)
         ST    R15,@Y_Passed_Data_Ptr   Save A(Data)
         ST    R0,@Y_Passed_Data_Len    and length

         LA    R15,Y_SYSPRINT           A(DDNAme)
         ST    R15,@Y_Parms_U00010      Save it for U00010
         LA    R15,@Y_Data_Len          Point to length
         ST    R15,@Y_Parms_U00010+8    Update Parms
         LA    R15,@Y_ASA_Char          A(Our ASA character)
         ST    R15,@Y_Parms_U00010+12   Save it

*---------------------------------------------------------------------*
*       Set our max len to LINESIZE(), if applicable                  *
*---------------------------------------------------------------------*
         LHI   R15,VolTbl_Ent_Display_Len Max len of data
Y00020   DS    0H
         LH    R1,@_LineSize            Get linesize from command line
         LTR   R1,R1                    Anything?
         JNP   Y00040                   LINESIZE(MAX) or none, skip
         CR    R15,R1                   Can we display all the data?
         JNH   Y00040                   Yes, OK
         LR    R15,R1                   No, display as much as we can
Y00040   DS    0H
         STH   R15,@Y_LineSize          Save it

*---------------------------------------------------------------------*
*       Print headings, if required. By convention, the line count    *
*      determines what headings to print:                             *
*        =4095: Hdg1 only                                             *
*        =4094: Hdg2-4 only                                           *
*        >60  : Hdg1-4                                                *
*---------------------------------------------------------------------*
         MVI   @Y_ASA_Char,C' '         Assume single space

         LH    R15,@_Line_Count         Get current line count
         CHI   R15,60                   Over a page?
         JNH   Y00090                   No, skip
         TM    @_No_Headings,L'@_No_Headings Yes, do we want headings?
         JO    Y00090                   No, skip
         ICM   R9,B'1111',@_VolTbl_Ptr  Yes, get A(VolTbl)
         JZ    Y00090                   None, no headings

*-------------------------------------------------------------------*
*    We are about to print headings - set up the length field ...   *
*-------------------------------------------------------------------*
         LH    R0,@Y_LineSize          Length of source data
         ST    R0,@Y_Data_Len           Save it
         L     R10,VolTbl_Hdr_Count-VolTbl_Hdr(R9) Yes, get count
         AHI   R9,VolTbl_Ent-VolTbl     and point to first entry
         USING VolTbl_Ent,R9            Assign a base

         LH    R15,@_Line_Count         Get line count
         CHI   R15,4094                 Hdg2-4 only?
         JE    Y00070                   Yes, skip Hdg0

*-------------------------------------------------------------------*
*    ... Hdg0 ...                                                   *
*-------------------------------------------------------------------*
         CHI   R10,1                    Check VolTbl_Ent count
         JL    Y00090                   No heading, skip
         TM    VolTbl_Ent_Heading_Line1,L'VolTbl_Ent_Heading_Line1 Hdg1
         JNO   Y00060                   No, skip
         MVI   @Y_ASA_Char,C'1'         Yes, start a new page
         LA    R15,VolTbl_Ent_Display   Point to Heading 1
         ST    R15,@Y_Parms_U00010+4    Update Parms
         AHI   R15,VolTbl_Ent_Display_Len-8 A(Page Literal)
Y00050   DS    0H
         MVC   0(4,R15),=C'Page'        Move page lit
         LH    R0,@_Page_Count          Get Page count
         AHI   R0,1                     Bump it
         STH   R0,@_Page_Count          Save it
         CVD   R0,@Y_DBLWD              Pack it
         MVC   4(4,R15),=X'40202120'    Move mask
         ED    4(4,R15),@Y_DBLWD+6      Edit page count
         OI    7(R15),X'F0'             Make it readable
         LA    R1,@Y_Parms              A(Parm list)
         BRAS  R14,U00010               Output Hdg1

         MVI   @Y_ASA_Char,C'0'         skip a line
         LH    R15,@_Line_Count         Get line count
         CHI   R15,4094                 Hdg0 only?
         JNH   Y00070                   No, all headings
         LHI   R15,1                    Yes, initialize line count
         J     Y00090                   and skip

Y00060   DS    0H
*-------------------------------------------------------------------*
*    ... Hdg1-Hdg3 ...                                              *
*-------------------------------------------------------------------*
         TM    VolTbl_Ent_Heading_Line,L'VolTbl_Ent_Heading_Line Hdg?
         JNO   Y00080                   No, end of headings
         LA    R14,VolTbl_Ent_Display   A(Source data)
         ST    R14,@Y_Parms_U00010+4    Save it for U00010
         LA    R1,@Y_Parms              A(Parm list)
         BRAS  R14,U00010               Output it
         MVI   @Y_ASA_Char,C' '         single space
Y00070   DS    0H
         AHI   R9,VolTbl_Ent_Len        A(Next entry
         BRCT  R10,Y00060               and do next one
Y00080   DS    0H
         LHI   R15,5                    Re-init line count

         DROP  R9                       No more VolTbl_Ent base

Y00090   DS    0H
*---------------------------------------------------------------------*
*       ... and then write the data passed to us.                     *
*---------------------------------------------------------------------*
         AHI   R15,1                    Bump line count
         STH   R15,@_Line_Count         Save line count
         L     R0,@Y_Passed_Data_Len    Get length of data
         CH    R0,@Y_LineSize           Too long?
         JNH   Y00100                   No, OK
         LH    R0,@Y_LineSize           Yes, reset it
Y00100   DS    0H
         L     R1,@Y_Passed_Data_Ptr    A(Data)
         LR    R15,R1                   Point past
         AR    R15,R0                    last character
Y00110   DS    0H
         S     R15,=FL4'1'              Back up a byte
         CR    R15,R1                   Too far?
         JNH   Y00120                   Yes, skip
         CLI   0(R15),C' '              Trailing space?
         JE    Y00110                   Yes, back up and try again
Y00120   DS    0H
         SLR   R15,R1                   Length of
         AHI   R15,1                     data1
         ST    R15,@Y_Data_Len          Save length
         ST    R1,@Y_Parms_U00010+4     Save A(Data)
         LA    R1,@Y_Parms              A(Parm list)
         BRAS  R14,U00010               Output it

Y00130   DS    0H
*---------------------------------------------------------------------*
*       Exit with a return code of 0                                  *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     Y90010                   and exit


Y90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                   Save return code

         LA    R1,@Y_Dynam              A(Local storage)
         L     R2,@Y_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

Y_Literals  DS  0H

Y_SYSPRINT  DC  CL8'SYSPRINT'

         LTORG

Y_Literals_End  DS  0H


@Y_Dynam                  DSECT       Dynamic area for Y00000
                          DS    18F    O/S Style save area
@Y_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@Y_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)
@Y_DBLWD                  DS    D      Work area
@Y_LineSize               DS    HL2    Max line size
@Y_Passed_Data_Ptr        DS    AL4    A(Data passed to us)
@Y_Passed_Data_Len        DS    FL4    Len of data passed to us
@Y_Data_Len               DS    FL4    Length of data
@Y_ASA_Char               DS    X      Carriage control character

@Y_Parms                  DS    0F     Parms for called rtns
@Y_Parms_Std              DS    3AL4    Standard 3 parms
@Y_Parms_Extra            EQU   *       Extra parms
@Y_Parms_U00010           DS    4AL4        for U00010
                          ORG   ,
                          DS    0D     Alignment
@Y_Dynam_Length           EQU   *-@Y_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING
         TITLE 'Z00010: Termination'

         PUSH  USING

Z00010   DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Subroutine: Z00010                                                 *
*                                                                     *
*  Abstract  : Perform one-time termination processes based on        *
*              environment.                                           *
*                                                                     *
*  Inputs    : R1 : ---> A(@_Dynam)                                   *
*                        A(31-bit Stack Pointer)                      *
*                        A(24-bit Stack Pointer)                      *
*  Outputs   : R15: 0                                                 *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:    1990/06/11 SDDA030 - New                               *
*              1998/09/21 SDDA030 - Added CLOSEs for SYSIN and        *
*                                   SYSPRINT in batch mode            *
*              1998/10/01 SDDA030 - Free up 24-bit storage            *
*              1999/05/27 SDDA030 - V2.6                              *
*                                 - Used LIFO Stack for our dynamic   *
*                                   areas.                            *
*                                 - Remove CLOSE and STORAGE RELEASE  *
*              2002/03/11 SDDA030 - V2.17                             *
*                                 - Freed up the STORGRP selection    *
*                                   list                              *
*              2006/04/21 SDDA030 - V2.24                             *
*                                 - Used standardised calling sequence*
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R14,R12,12(R13)          Save callers registers
         LARL  R11,Z_Literals           Point to our literals
         USING (Z_Literals,Z_Literals_End),R11 Tell the assembler

         L     R12,0(0,R1)              A(@_Dynam)
         USING @_Dynam,R12              Tell the assembler

*-------------------------------------------------------------------*
*    Get an area on the stack for our local storage                 *
*-------------------------------------------------------------------*
         L     R2,4(0,R1)               A(31-bit stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         SSCSTACK PUSH,                 Get stack area                 +
               LEN=@Z_Dynam_Length,      this long                     +
               STACK=(R2)                using this stack

         LR    R3,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LHI   R1,@Z_Dynam_Length        Its length
         LA    R14,0                    Clear source address
         LA    R15,0                     and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R3                    Restore A(Our storage)

*-------------------------------------------------------------------*
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*-------------------------------------------------------------------*
         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @Z_Dynam,R13             Assign a base
         L     R15,@Z_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R15,4(0,R1)              A(31-bit Stack Pointer)
         ST    R15,@Z_31Bit_Stack_Ptr_Ptr Save it
         L     R15,8(0,R1)              A(24-bit Stack Pointer)
         ST    R15,@Z_24Bit_Stack_Ptr_Ptr Save it

*--------------------------------------------------------------------*
*   Initialize our standard parmlist                                 *
*--------------------------------------------------------------------*
         LA    R15,@_Dynam              A(Dynamic area)
         ST    R15,@Z_Parms_Std         Save it
         L     R15,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         ST    R15,@Z_Parms_Std+4       Save it
         L     R15,@Z_24Bit_Stack_Ptr_Ptr A(24-bit Stack Pointer)
         ST    R15,@Z_Parms_Std+8       Save it

*---------------------------------------------------------------------*
*   Reset our priority, if we changed it                              *
*---------------------------------------------------------------------*
         TM    @_CHAP_Done,L'@_CHAP_Done Did we lower our priority?
         JZ    Z00010I                  No, skip
         CHAP  1,'S'                    Yes, reset it
         NI    @_CHAP_Done,X'FF'-L'@_CHAP_Done and reset flag

Z00010I  DS    0H
*---------------------------------------------------------------------*
*   Free up the Volume Table, if there is one                         *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_VolTbl_Ptr A(Info Table)
         JZ    Z00020                  None, skip
         L     R0,VolTbl_Hdr_TbLen-VolTbl(R1) Get its length
         BASR  R2,0
         USING (*,Z00010_End-1),R2
         STORAGE RELEASE,               Free the table                 +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00010_End DS  0H
         DROP  R2
         LA    R15,0                    Clear work register
         ST    R15,@_VolTbl_Ptr         and clear VolTbl pointer

Z00020   DS    0H
*---------------------------------------------------------------------*
*   CLOSE and free any output DCBs                                    *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear pointer
         ST    R15,@Z_Parms_U00010      No DDName
         ST    R15,@Z_Parms_U00010+4    No data pointer
         ST    R15,@Z_Parms_U00010+8    No length either
         ST    R15,@Z_Parms_U00010+12   No ASA CC

         LA    R1,@Z_Parms              A(Parms)
         BRAS  R14,U00010               Close and free DCBs

Z00030   DS    0H
*---------------------------------------------------------------------*
*   Free up the UCB and Volume selection tables                       *
*---------------------------------------------------------------------*
         ICM   R1,B'1111',@_UCB_List_Ptr A(List of UCB Masks)
         JZ    Z00040                   None, skip
         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length
         BASR  R2,0
         USING (*,Z00030_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00030_End DS  0H
         DROP  R2
         XC    @_UCB_List_Ptr,@_UCB_List_Ptr Clear A(UCB List)

Z00040   DS    0H
         ICM   R1,B'1111',@_XUCB_List_Ptr A(List of XUCB Masks)
         JZ    Z00050                   None, skip
         L     R0,UCB_List_Hdr_Len-UCB_List_Hdr(R1)  Length
         BASR  R2,0
         USING (*,Z00040_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00040_End DS  0H
         DROP  R2
         XC    @_XUCB_List_Ptr,@_XUCB_List_Ptr Clear A(XUCB List)

Z00050   DS    0H
         ICM   R1,B'1111',@_Vol_List_Ptr A(List of Vol Masks)
         JZ    Z00060                   None, skip
         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length
         BASR  R2,0
         USING (*,Z00050_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00050_End DS  0H
         DROP  R2
         XC    @_VOL_List_Ptr,@_VOL_List_Ptr Clear A(Vol List)

Z00060   DS    0H
         ICM   R1,B'1111',@_XVol_List_Ptr A(List of XVol Masks)
         JZ    Z00070                   None, skip
         L     R0,Vol_List_Hdr_Len-Vol_List_Hdr(R1)  Length
         BASR  R2,0
         USING (*,Z00060_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00060_End DS  0H
         DROP  R2
         XC    @_XVOL_List_Ptr,@_XVOL_List_Ptr Clear A(XVol List)

Z00070   DS    0H
         ICM   R1,B'1111',@_STORGRP_List_Ptr A(List of STORGRP Masks)
         JZ    Z00070C                  None, skip
         L     R0,STORGRP_List_Hdr_Len-STORGRP_List_Hdr(R1) Length
         BASR  R2,0
         USING (*,Z00070_End-1),R2
         STORAGE RELEASE,               Free the storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z00070_End DS  0H
         DROP  R2
         XC    @_STORGRP_List_Ptr,@_STORGRP_List_Ptr Clear A(List)

Z00070C  DS    0H
         TM    @_TSO_Command,L'@_TSO_Command TSO Command?
         JZ    Z00080                   No, skip

*---------------------------------------------------------------------*
*       TSO Command Processing                                        *
*---------------------------------------------------------------------*
         LA    R15,0                    Clear return code
         J     Z90010                   and exit

Z00080   DS    0H
*---------------------------------------------------------------------*
*       Batch Job Processing                                          *
*---------------------------------------------------------------------*
         TM    @_Batch_Environ,L'@_Batch_Environ Is this batch?
         JZ    Z90010                   No, exit (??)

         LA    R15,0                    Clear return code
         J     Z90010                   and exit

Z90010   DS    0H
*-------------------------------------------------------------------*
*    Free up our local storage ...                                  *
*-------------------------------------------------------------------*
         LR    R3,R15                 Save return code

         LA    R1,@Z_Dynam              A(Local storage)
         L     R2,@Z_31Bit_Stack_Ptr_Ptr A(31-bit Stack Pointer)
         L     R2,0(0,R2)               A(31-bit Stack)
         L     R13,4(0,R13)             Rescue A(HSA)

         SSCSTACK POP,                  Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*    ... and return to caller                                       *
*-------------------------------------------------------------------*
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


Z_Literals DS   0H

         LTORG

Z_Literals_End DS   0H


@Z_Dynam                  DSECT       Dynamic area for Z00000
                          DS    18F    O/S Style save area
@Z_31Bit_Stack_Ptr_Ptr    DS    AL4    A(31-bit Stack Ptr)
@Z_24Bit_Stack_Ptr_Ptr    DS    AL4    A(24-bit Stack Ptr)


@Z_Parms                  DS    0F    Parms for called rtns
@Z_Parms_Std              DS    3AL4   Standard 3 parms
@Z_Parms_Extra            EQU   *      Extra parms
@Z_Parms_U00010           DS    4AL4      for U00010
                          ORG   ,

                          DS    0D    Alignment
@Z_Dynam_Length           EQU   *-@Z_Dynam Length of storage

&PGMNAME CSECT

         DROP  ,
         POP   USING

         END
